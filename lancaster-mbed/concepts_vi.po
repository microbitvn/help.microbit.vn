# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-10-25 14:56+0200\n"
"PO-Revision-Date: 2016-10-26 12:27+0200\n"
"Language: vi\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: \n"
"Language-Team: \n"
"X-Generator: Poedit 1.8.9\n"

#. type: Plain text
#: concepts.md:2
msgid "# Concepts"
msgstr "# Các khái niệm"

#. type: Plain text
#: concepts.md:9
msgid ""
"The micro:bit runtime provides an easy to use environment for programming the "
"BBC micro:bit in the C/C++ language. It contains device drivers for all the "
"hardware capabilities of the micro:bit, and also a suite of runtime mechanisms "
"to make programming the micro:bit easier and more flexible. These range from "
"control of the LED matrix display to peer-to-peer radio communication and secure "
"Bluetooth Low Energy services. The micro:bit runtime is proudly built on the "
"[ARM mbed](https://www.mbed.com)  and [Nordic nrf51](http://www.nordicsemi.com) "
"platforms."
msgstr ""
"Bộ lệnh micro:bit runtime cung cấp một môi trường dễ sử dụng để lập trình cho "
"BBC micro:bit bằng ngôn ngữ C/C++, viết bởi trường đại học Lancaster. Nó bao gồm "
"các thư viện drivers cho tất cả các chức năng phần cứng của micro:bit, và cũng "
"là một bộ các cơ chế thực thi (runtime) để giúp việc lập trình micro:bit được dễ "
"hơn và uyển chuyển hơn. Chúng bao gồm từ việc đều khiển một màn hình LED ma trận "
"đến truyền tín hiệu radio ngang cấp (peer-to-peer) và các dịch vụ Bluetooth năng "
"lượng thấp (BLE) có bảo mật. Bộ lệnh micro:bit runtime tự hào được xây dựng trên "
"các nền tảng [ARM mbed](https://www.mbed.com)  và [Nordic nrf51](http://www."
"nordicsemi.com)."

#. type: Plain text
#: concepts.md:14
msgid ""
"In addition to supporting development in C/C++, the runtime is also designed "
"specifically to support higher level languages provided by our partners that "
"target the micro:bit. It is currently used as a support library for all the "
"languages on the BBC [www.microbit.co.uk](http://www.microbit.co.uk) website, "
"including Microsoft Block Editor, Microsoft Touch Develop, Code Kingdoms "
"JavaScript and Micropython languages."
msgstr ""
"Ngoài việc hỗ trợ phát triển bằng C/C++, bộ lệnh này cũng được thiết kế đặc biệt "
"để hỗ trợ các ngôn ngữ lập trình cấp cao do các đối tác của chúng tôi phát triển "
"cho micro:bit. Nó đang được dùng như một thư viện hỗ trợ cho tất cả các ngôn ngữ "
"lập trình trên trang web BBC [www.microbit.co.uk](http://www.microbit.co.uk), "
"bao gồm các ngôn ngữ Microsoft Block Editor, Microsoft Touch Develop, Code  "
"Kingdom's JavaScript và Micropython."

#. type: Plain text
#: concepts.md:16
msgid "![micro:bit runtime](resources/examples/concepts/architecture.png)"
msgstr "![micro:bit runtime](resources/examples/concepts/architecture.png)"

#. type: Plain text
#: concepts.md:19
msgid "## A Component Based Approach"
msgstr "## Một cách tiếp cận từ thành phần"

#. type: Plain text
#: concepts.md:24
msgid ""
"Whenever computer scientists tackle large programming problems, we take the time "
"to split the problem into smaller, independent sections to make the problem "
"easier to solve (divide and conquer!).  The micro:bit runtime is no exception, "
"and is made up of a number of smaller components. Each of these components looks "
"after a specific job on the micro:bit."
msgstr ""
"\"Mỗi khi một nhà khoa học máy tính đụng phải một bài toán lập trình lớn, chúng "
"ta thường dành chút thời gian để chia bài toán đó ra thành các phần nhỏ và độc "
"tập, để giúp bài toán dễ giải quyết hơn (chiến lược \"chia để trị\"). Bộ micro:"
"bit runtime cũng không phải ngoại lệ, và nó được ghép từ khá nhiều thành phần "
"nhỏ. Mỗi thành phần lo cho một tác vụ riêng biệt trên micro:bit."

#. type: Plain text
#: concepts.md:29
msgid ""
"Building up software like this helps us to write code in a way that is much "
"easier to maintain as the amount of code grows. For example, a component called "
"[MicroBitDisplay](ubit/display.md)  controls the LEDs on the micro:bit, and lets "
"the programmer show images, animations and messages. The [MicroBitIO](ubit/io."
"md) component controls input and output through the pins on the edge of the "
"device."
msgstr ""
"Xây dần phần mềm kiểu này giúp chúng ta viết code bằng một cách rất dễ để bảo "
"quản khi số dòng lệnh tăng lên nhiều. Ví dụ, một thành phần tên là "
"[MicroBitDisplay](ubit/display.md) điều khiển các đèn LED trên micro:bit, và "
"giúp lập trình viên hiển thị hình ảnh, ảnh động và các thông điệp. Thành phần "
"[MicroBitIO](ubit/io.md) điều khiển các ngõ vào và ngõ ra qua các chân ở cạnh "
"của thiết bị."

#. type: Plain text
#: concepts.md:32
msgid ""
"The micro:bit runtime is object oriented, with each component typically being a C"
"++ class.  There are over 30 components making up the runtime, and they are "
"documented on these pages."
msgstr ""
"Bộ micro:bit runtime là hướng đối tượng, trong đó mỗi thành phần thường là một "
"lớp trong C++. Có trên 30 thành phần tạo nên bộ runtime, và chúng được ghi vào "
"tài liệu trong các trang này."

#. type: Plain text
#: concepts.md:35
msgid ""
"To make the runtime as easy to use as possible, there is also a grouping of the "
"most commonly used components in an object called [uBit](ubit.md) (The 'u' being "
"the greek letter mu - which often refers to 'micro' in scientific units!)."
msgstr ""
"Để tạo ra bộ runtime dễ dùng hết mức, có một nhóm các thành phần thường dùng "
"nhất đặt trong một đối tượng gọi là [uBit](ubit.md) (Chữ 'u' là chữ cái Hy Lạp "
"mu, đọc là \"muy\", thường chỉ đến tiền tố trong các đơn vị đo khoa học)."

#. type: Plain text
#: concepts.md:38
msgid ""
"The uBit object can be used to easily access most of the functionality of the "
"micro:bit. You can find the components and functions that can be accessed this "
"way in the `uBit` in the navigation bar."
msgstr ""
"Đối tượng uBit có thể được dùng để truy cập dễ dàng đến hầu hết các tính năng "
"của micro:bit. Bạn có thể tìm thấy các thành phần và hàm con truy cập được qua "
"cách này ở link `uBit` trong menu điều hướng."

#. type: Plain text
#: concepts.md:40
msgid ""
"To show just how easy it is to get started, the following code shows how you "
"would write a traditional Hello World program."
msgstr ""
"Để cho thấy có thể bắt đầu dễ như thế nào, đoạn code dưới đây trình diễn cách "
"viết chương trình Hello World kinh điển."

#. type: Plain text
#: concepts.md:43
msgid ""
"This uses the uBit object to access the display component, then instructs the "
"display to scroll the given string across the LEDs. Try to use the `uBit` menu "
"tab above to find the documentation for this scroll() function!"
msgstr ""
"Nó dùng đối tượng uBit để truy cập thành phần \"màn hình\", sau đó bảo màn hình "
"chạy một dòng chữ ngang qua các đèn LED. Hãy thử dùng link `uBit` ở menu trang "
"web để tìm phần tài liệu cho hàm scroll() này!"

#. type: Plain text
#: concepts.md:47
msgid "```cpp uBit.display.scroll(\"Hello micro:bit!\"); ```"
msgstr ""
"```cpp\n"
"uBit.display.scroll(\"Hello micro:bit!\");\n"
"```"

#. type: Plain text
#: concepts.md:50
#, no-wrap
msgid ""
"!!! note\n"
"    Did you know that you don't need to use the uBit object? Advanced users will likely prefer to create only the components they need to conserve memory on the device. See the [advanced](advanced.md) section for how to do this.\n"
msgstr ""
"!!! note \"Lưu ý\"\n"
"    Bạn có biết là bạn có thể không cần dùng đối tượng uBit? Người dùng nâng cao có thể ưa thích tạo ra chỉ các thành phần mà họ cần, để tiết kiệm bộ nhớ trên thiết bị. Xem phần [nâng cao](advanced.md) để biết cách làm này.\n"

#. type: Plain text
#: concepts.md:53
msgid "# Events"
msgstr "# Sự kiện"

#. type: Plain text
#: concepts.md:57
msgid ""
"Computer programs execute sequentially - one line after another, following the "
"logic of the program you have written.  Sometimes though, we want to be able to "
"determine *when* something has happened, and write some code to decide what "
"should happen in that case."
msgstr ""
"Các chương trình máy tính chạy một cách tuần tự - từng dòng nối tiếp nhau, theo "
"một logic của chương trình mà bạn đã viết. Tuy nhiên thỉnh thoảng chúng ta muốn "
"có khả năng xác định *khi nào* một điều gì đó xảy ra, và viết vài dòng lệnh để "
"quyết định việc gì sẽ thực hiện trong trường hợp đó."

#. type: Plain text
#: concepts.md:60
msgid ""
"For example, maybe you want to know when a button has been pressed, when your "
"micro:bit has been shaken, or when some data has been sent to you over the "
"device's radio. For these sorts of cases, we create a [MicroBitEvent](data-types/"
"event.md)."
msgstr ""
"Ví dụ, bạn có thể muốn biết khi nào một nút nhấn được nhấn, khi nào mạch micro:"
"bit của bạn đang được rung lắc, hoặc khi nào có dữ liệu gửi đến thiết bị của bạn "
"qua sóng không dây. Cho các kiểu trường hợp này, chúng ta tạo ra một "
"[MicroBitEvent](data-types/event.md)."

#. type: Plain text
#: concepts.md:63
msgid "## Creating Events"
msgstr "## Tạo ra sự kiện"

#. type: Plain text
#: concepts.md:68
msgid ""
"Many components will raise events when interesting things occur. For example, "
"['MicroBitAccelerometer'](ubit/accelerometer.md) will raise events to indicate "
"that the micro:bit has be been shaken, or is in freefall and ['MicroBitButton']"
"(ubit/button.md) will send events on a range of button up, down, click and hold "
"events.  Programmers are also free to send their own events whenever they feel "
"it would be useful. `MicroBitEvent`s are *very* simple, and consist of only two "
"numbers:"
msgstr ""
"Nhiều thành phần sẽ tạo ra các events khi có gì đáng quan tâm xảy ra. Ví dụ, "
"['MicroBitAccelerometer'](ubit/accelerometer.md) sẽ gây ra sự kiện để cho biết "
"là micro:bit vừa bị lắc, hoặc nó đang rơi tự do, và ['MicroBitButton'](ubit/"
"button.md) sẽ gửi sự kiện trong phạm vi các hoạt động ấn xuống, nhả lên, nhấn "
"rồi nhả (click) và nhấn giữ (hold). Lập trình viên có thể tự do gửi các sự kiện "
"của họ khi họ thấy việc đó có thể hữu ích. Các `MicroBitEvent` *rất* đơn giản, "
"và chỉ bao gồm 2 con số:"

#. type: Bullet: '  - '
#: concepts.md:71
msgid "`source` - A number identifying the component that created the event."
msgstr "`source` (nguồn) - Một con số để xác định thành phần nào tạo ra sự kiện."

#. type: Bullet: '  - '
#: concepts.md:71
msgid "`value` - A number unique to the source that identifies the event."
msgstr "`value` (giá trị) - Một con số độc nhất đối với nguồn để xác định sự kiện."

#. type: Plain text
#: concepts.md:75
msgid ""
"The documentation for each component defines its event source, and all the "
"events it may generate, and also gives a name to these event values. For "
"example, take a look at the [button documentation](ubit/button.md) to see that "
"the source MICROBIT_ID_BUTTON_A has the value '1', and an event "
"MICROBIT_BUTTON_EVT_CLICK with the value '3' is generated when a button is "
"clicked."
msgstr ""
"Tài liệu của từng thành phần xác định nguồn sự kiện của nó, và tất cả các sự "
"kiện nó có thể tạo ra, cũng như cho biết tên ứng với các giá trị sự kiện. Lấy ví "
"dụ, hãy xem thử [tài liệu về nút nhấn](ubit/button.md) để thấy là nguồn "
"MICROBIT_ID_BUTTON_A có giá trị '1', và một sự kiện MICROBIT_BUTTON_EVT_CLICK "
"với giá trị '3' được tạo ra khi một nút nhấn được bấm (click)."

#. type: Plain text
#: concepts.md:77
msgid ""
"Creating an event is easy - just create a MicroBitEvent with the `source` and "
"`value` you need, and the runtime takes care of the rest:"
msgstr ""
"Tạo ra một sự kiện thật dễ dàng - chỉ cần tạo ra một MicroBitEvent với `source` "
"và `value` bạn cần, và bộ runtime sẽ lo việc còn lại:"

#. type: Plain text
#: concepts.md:81
msgid "```cpp MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK); ```"
msgstr ""
"```cpp\n"
"MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);\n"
"```"

#. type: Plain text
#: concepts.md:84
msgid ""
"Feel free to create your own events lke this too. Just try to avoid using any "
"source ID that is already used by the runtime! :-)  See the [messageBus](ubit/"
"messageBus.md) page for a complete table of the reserved source IDs."
msgstr ""
"Hãy tự nhiên tạo ra các sự kiện của riêng bạn kiểu thế này. Chỉ cần cố gắng "
"tránh dùng bất kỳ ID nguồn nào đã được sử dụng trong bộ runtime! :-) Xem trang "
"[messageBus](ubit/messageBus.md) để thấy bảng đầy đủ các ID nguồn được dành "
"trước."

#. type: Plain text
#: concepts.md:87
msgid "## Detecting Events"
msgstr "## Dò đón các sự kiện"

#. type: Plain text
#: concepts.md:90
msgid ""
"The micro:bit runtime has a component called the [`MicroBitMessageBus`](ubit/"
"messageBus.md), and its job is remember which events your program is interested "
"in, and to deliver `MicroBitEvent`s to your program as they occur."
msgstr ""
"Bộ micro:bit runtime có một thành phần tên là [`MicroBitMessageBus`](ubit/"
"messageBus.md), nó có nhiệm vụ ghi nhớ những sự kiện nào mà chương trình của bạn "
"quan tâm, và chuyển các `MicroBitEvent` đến chương trình của bạn khi chúng xảy "
"ra."

#. type: Plain text
#: concepts.md:93
msgid ""
"To find out when an event happens, you need to create a function in your "
"program, then tell the message bus which event you want to attach this function "
"to. This is known as writing an **event handler**."
msgstr ""
"Để biết khi nào một sự kiện xảy ra, bạn cần tạo một hàm trong chương trình của "
"mình, rồi bảo cái đường truyền tin nhắn (message bus) sự kiện nào bạn muốn gắn "
"với hàm này. Việc này xem như là viết một **trình xử lý sự kiện** (event "
"handler)."

#. type: Plain text
#: concepts.md:95
msgid ""
"You write an event handler through the `MicroBitMessageBus` [listen](ubit/"
"messageBus.md) function."
msgstr ""
"Bạn viết một trình xử lý sự kiện (event handler) qua hàm `MicroBitMessageBus` "
"[listen](ubit/messageBus.md)."

#. type: Plain text
#: concepts.md:101
#, no-wrap
msgid ""
"```cpp\n"
"void onButtonA(MicroBitEvent e)\n"
"{\n"
"    uBit.display.print(\"A\");\n"
"}\n"
msgstr ""
"```cpp\n"
"void onButtonA(MicroBitEvent e)\n"
"{\n"
"    uBit.display.print(\"A\");\n"
"}\n"

#. type: Plain text
#: concepts.md:107
#, no-wrap
msgid ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n"
"}\n"
"```\n"
msgstr ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n"
"}\n"
"```\n"

#. type: Plain text
#: concepts.md:109
msgid ""
"Now, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by "
"MICROBIT_ID_BUTTON_A, your code inside function 'onButtonA' will be "
"automatically executed."
msgstr ""
"Bây giờ, mỗi khi sự kiện MICROBIT_BUTTON_EVT_CLICK được gây ra bởi "
"MICROBIT_ID_BUTTON_A, mã lệnh bạn để bên trong hàm 'onButtonA' sẽ được tự động "
"thực thi."

# There seem to be a typo in the English text: "attached functions" should be corrected as "attach functions".
#. type: Plain text
#: concepts.md:112
msgid ""
"You can call listen as many times as you want to attached functions to each of "
"the events that are useful for your program. In fact, a block like the following "
"in the Microsoft Block language translates into code just like that shown above "
"when it is run on a micro:bit!"
msgstr ""
"Bạn có thể gọi hàm [listen](ubit/messageBus.md) bao nhiêu lần tùy thích để gắn "
"các hàm với từng sự kiện hữu ích cho chương trình của bạn. Kỳ thực, một khối "
"lệnh như dưới đây trong ngôn ngữ Microsoft Block sẽ được dịch thành mã lệnh "
"giống như khối lệnh ở trên, khi nó được chạy trên micro:bit."

#. type: Plain text
#: concepts.md:114
msgid ""
"![on button a, equivalent in blocks](resources/examples/concepts/example-"
"listener.png)"
msgstr ""
"![on button a, equivalent in blocks](resources/examples/concepts/example-"
"listener.png)"

#. type: Plain text
#: concepts.md:117
msgid "##Wildcard Events"
msgstr "## Sự kiện đại diện (wildcard events)"

#. type: Plain text
#: concepts.md:120
msgid ""
"Sometimes though, you want to capture all events generated by some component. "
"For example, you might want to know when any changes in a button has happened.  "
"In this case, there is a special event value called 'MICROBIT_EVT_ANY'. If you "
"call listen with this value, then ALL events from the given source component "
"will be delivered to your function."
msgstr ""
"Tuy nhiên, thỉnh thoảng bạn muốn bắt được tất cả sự kiện được sinh ra bởi một "
"thành phần. Lấy ví dụ, bạn có thể muốn biết khi nào có thay đổi bất kỳ xảy ra "
"đối với một nút bấm. Trong trường hợp này, có một giá trị sự kiện đặc biệt gọi "
"là 'MICROBIT_EVT_ANY'. Nếu bạn gọi hàm listen với giá trị này, thì TẤT CẢ các sự "
"kiện sinh ra từ thành phần nguồn sẽ được chuyển đến hàm của bạn."

#. type: Plain text
#: concepts.md:122
msgid ""
"You can find out which ones by looking at the `MicroBitEvent` delivered to your "
"function - it contains the `source` and `value` variables that the "
"`MicroBitEvent` was created with."
msgstr ""
"Bạn có thể tìm ra cái nào bằng cách nhìn vào `MicroBitEvent` được chuyển đến hàm "
"của bạn - nó bao gồm các tham số `source` và `value` mà sự kiện `MicroBitEvent` "
"được tạo ra."

#. type: Plain text
#: concepts.md:129
#, no-wrap
msgid ""
"For example, you could write a program like this:\n"
"```cpp\n"
"void onButtonA(MicroBitEvent e)\n"
"{\n"
"    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n"
"        uBit.display.scroll(\"CLICK\");\n"
msgstr ""
"Lấy ví dụ, bạn có thể viết một chương trình kiểu này:\n"
"```cpp\n"
"void onButtonA(MicroBitEvent e)\n"
"{\n"
"    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n"
"        uBit.display.scroll(\"CLICK\");\n"

#. type: Plain text
#: concepts.md:133
#, no-wrap
msgid ""
"    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n"
"        uBit.display.scroll(\"DOWN\");\n"
"}\n"
msgstr ""
"    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n"
"        uBit.display.scroll(\"DOWN\");\n"
"}\n"

#. type: Plain text
#: concepts.md:139
#, no-wrap
msgid ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n"
"}\n"
"```\n"
msgstr ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n"
"}\n"
"```\n"

#. type: Plain text
#: concepts.md:141
msgid ""
"If you *REALLY* want even more events, there is also a MICROBIT_ID_ANY source, "
"that allows you to attach a function to event generated from any component."
msgstr ""
"Nếu bạn *THẬT SỰ* muốn nhiều sự kiện hơn nữa, có một nguồn MICROBIT_ID_ANY, cho "
"phép bạn gắn một hàm với một sự kiện sinh ra bởi bất kỳ thành phần nào."

#. type: Plain text
#: concepts.md:143
msgid "Use this sparingly though, as this could be quite a lot of events!"
msgstr ""
"Tuy nhiên, hãy sử dụng cái này một cách tiết kiệm, vì nó có thể làm ra nhiều sự "
"kiện!"

#. type: Plain text
#: concepts.md:150
#, no-wrap
msgid ""
"The following code would attach the `onEvent` function to receive all the events from the whole runtime:\n"
"```cpp\n"
"void onEvent(MicroBitEvent e)\n"
"{\n"
"    uBit.display.scroll(\"SOMETHING HAPPENED!\");\n"
"}\n"
msgstr ""
"Đoạn mã dưới đây sẽ gắn một hàm `onEvent` để nhận tất cả các sự kiện từ toàn bộ runtime:\n"
"```cpp\n"
"void onEvent(MicroBitEvent e)\n"
"{\n"
"    uBit.display.scroll(\"CO CHUYEN ROI!\");\n"
"}\n"

#. type: Plain text
#: concepts.md:156
#, no-wrap
msgid ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n"
"}\n"
"```\n"
msgstr ""
"int main()\n"
"{\n"
"    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n"
"}\n"
"```\n"

#. type: Plain text
#: concepts.md:158
msgid "## Queued Events"
msgstr "## Các sự kiện xếp hàng"

#. type: Plain text
#: concepts.md:160
msgid ""
"When you write an event handler, your function will be called each time the "
"relevant event is raised. But what happens if your handler takes a long time to "
"execute?"
msgstr ""
"Khi bạn viết một trình xử lý sự kiện, hàm của bạn sẽ được gọi mỗi khi sự kiện "
"liên quan được sinh ra. Nhưng điều gì xảy ra nếu trình xử lý sự kiện của bạn tốn "
"nhiều thời gian để chạy?"

#. type: Plain text
#: concepts.md:162
msgid ""
"The example above will scroll \"SOMETHING HAPPENED\" whenever any event is "
"raised... but scrolling that message will take several seconds to complete!"
msgstr ""
"Ví dụ ở trên sẽ chạy ngang chữ \"CO CHUYEN ROI!\" mỗi khi một sự kiện được gây "
"ra... nhưng khi chạy thông điệp đó sẽ cần vài giây để hoàn tất!"

#. type: Plain text
#: concepts.md:164
msgid ""
"What if another event happens during this time? By default, the runtime will "
"queue any events for your event handler until it has finished what its already "
"doing."
msgstr ""
"Điều gì xảy ra nếu một sự kiện khác xuất hiện trong thời gian này? Mặc định thì "
"bộ runtime sẽ cho xếp hàng tất cả các sự kiện để đợi đến khi trình xử lý sự kiện "
"của bạn kết thúc việc đang làm."

#. type: Plain text
#: concepts.md:166
msgid ""
"As soon as your handler is finished processing an event, the next one will be "
"delivered (any other event handlers will be unaffected though - just because one "
"event handler is busy, doesn't mean that another one can't receive its events!)."
msgstr ""
"Ngay khi trình xử lý hoàn tất việc xử lý một sự kiện, cái tiếp theo sẽ được "
"chuyển tới (bất kỳ trình xử lý sự kiện nào khác cũng sẽ không bị ảnh hưởng - chỉ "
"bởi vì một trình xử lý sự kiện đang bận rộn, không có nghĩa là một cái khác "
"không nhận được sự kiện của nó)."

#. type: Plain text
#: concepts.md:168
msgid ""
"The runtime does allow you to change this behaviour if you want to though. See "
"the advanced documentation in [MicroBitMessageBus](ubit/messageBus.md) for more "
"details."
msgstr ""
"Dù vậy, bộ runtime vẫn cho phép bạn thay đổi cách làm này nếu bạn muốn. Hãy xem "
"phần tài liệu nâng cao trong [MicroBitMessageBus](ubit/messageBus.md) để biết cụ "
"thể hơn."

#. type: Plain text
#: concepts.md:171
#, no-wrap
msgid ""
"!!! note\n"
"    More advanced programmers might be interested to know that you can also attach event handler to member function of C++ objects. See the other forms of listen function in [MicroBitMessageBus](ubit/messageBus.md) for more details.\n"
msgstr ""
"!!! note \"Lưu ý\"\n"
"    Những lập trình viên kinh nghiệm hơn chắc quan tâm đến việc là các bạn cũng có thể gắn trình xử lý sự kiện vào một hàm thành viên của đối tượng trong C++. Hãy xem các dạng khác của hàm listen trong [MicroBitMessageBus](ubit/messageBus.md) để biết thêm chi tiết.\n"

#. type: Plain text
#: concepts.md:174
msgid "# Concurrency"
msgstr "# Tính đồng thời"

#. type: Plain text
#: concepts.md:177
msgid ""
"It is not uncommon to want to write programs that can do more than one thing at "
"a time. For example, it takes quite a long time to scroll a message over the LED "
"matrix, so what if you want your program to do something else while this is "
"happening?"
msgstr ""
"Người ta không xa lạ với việc viết các chương trình có thể làm nhiều hơn một "
"việc vào cùng thời điểm. Lấy ví dụ, sẽ mất khá nhiều thời gian để chạy ngang một "
"thông điệp trên cái LED ma trận, vậy khi bạn muốn chương trình của bạn làm việc "
"gì khác khi việc này đang xảy ra thì làm thế nào?"

#. type: Plain text
#: concepts.md:179
msgid ""
"Programs that do more than one thing at a time are called **concurrent "
"programs**."
msgstr ""
"Các chương trình làm nhiều hơn một việc tại cùng thời điểm được gọi là **chương "
"trình đồng thời** (concurrent programs)."

#. type: Plain text
#: concepts.md:181
msgid "The runtime provides two ways you can achieve concurrency in your programs:"
msgstr ""
"Bộ runtime cung cấp hai cách để bạn đạt được sự đồng thời trong các chương trình "
"của mình:"

#. type: Bullet: ' -  '
#: concepts.md:183
msgid ""
"Functions that may take a very long time to complete (e.g. display.scroll) often "
"have \"Async\" versions (e.g. `display.scrollAsync`)."
msgstr ""
"Các hàm có thể tốn thời gian rất dài để hoàn thành (ví dụ display.scroll) thường "
"có một phiên bản \"Async\" (ví dụ `display.scrollAsync`)."

#. type: Plain text
#: concepts.md:185
#, no-wrap
msgid "    These functions have the exact same behaviour as their counterparts, but don't wait for the effect to finish before allowing the user's program to continue.\n"
msgstr "    Các hàm này có cách hành xử y hệt hàm tương đương của chúng, tuy nhiên không phải đợi đến khi làm xong tác vụ rồi mới cho phép chương trình của người dùng được chạy.\n"

#. type: Plain text
#: concepts.md:187
#, no-wrap
msgid "    Instead, as soon as the function is called, the user's program carries on executing (and can go an do something else while the task is running in the background).\n"
msgstr "    Thay vào đó, ngay khi hàm này được gọi, chương trình của người dùng vẫn tiếp tục được thực thi (và có thể làm việc gì khác trong khi tác vụ kia đang chạy ở chế độ nền (background).\n"

#. type: Plain text
#: concepts.md:192
#, no-wrap
msgid ""
" - Users can also make use of the runtime fiber scheduler. This lets you run parts of your program in the background, and share the processor on your micro:bit between those parts\n"
"as they need it.\n"
msgstr ""
" - Người dùng cũng có thể sử dụng trình đặt lịch fiber của bộ runtime. Nó hỗ trợ cho bạn chạy các phần của chương trình của bạn trong chế độ nền, và chia sẻ bộ xử lý trên micro:bit giữa các phần đó\n"
"khi chúng cần nó.\n"

#. type: Plain text
#: concepts.md:194
#, no-wrap
msgid "    In fact, whenever you write an event handler, the runtime will normally execute your handler in the background in this way, so that it reduces the impact on the rest of your program!\n"
msgstr "    Thật ra, mỗi khi bạn muốn viết một trình xử lý sự kiện, bộ runtime mặc định thực thi trình xử lý của bạn trong chế độ nền như kiểu này, nhằm giảm tác động lên phần còn lại trong chương trình của bạn!\n"

#. type: Plain text
#: concepts.md:197
#, no-wrap
msgid ""
"    The scheduler is a type of *non-preemptive scheduler*. This means that the runtime will never take control away from your program - it will wait for it to make a call to a runtime\n"
"function that is *blocking*.\n"
msgstr ""
"    Trình xếp lịch thuộc về loại *xếp lịch không ưu tiên* (non-preemptive scheduler). Điều này có nghĩa là bộ runtime sẽ không bao giờ tước đi quyền quản lý từ chương trình của bạn - nó sẽ đợi cho đến lúc chương trình gọi đến một hàm runtime\n"
"đang *chặn*.\n"

#. type: Plain text
#: concepts.md:198
#, no-wrap
msgid "    All the functions that are blocking are listed as such in their documentation.  You can create **fibers** at any time.\n"
msgstr "    Tất cả các hàm đang chặn được liệt kê trong tài liệu về chúng. Bạn có thể tạo các **fibers** bất cứ lúc nào.\n"
