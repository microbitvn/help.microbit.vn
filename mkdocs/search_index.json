{
    "docs": [
        {
            "location": "/",
            "text": "B\u1ed9 t\u00e0i li\u1ec7u BBC Microbit ti\u1ebfng Vi\u1ec7t\n#\n\n\n\n\nN\u1ed9i dung cung c\u1ea5p\n#\n\n\nB\u1ea3n quy\u1ec1n\n#\n\n\nTo\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA\n\n\nGhi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, v\u00e0 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.\n\n\nB\u1ea5t k\u1ef3 nh\u1eefng n\u1ed9i dung ph\u00e2n ph\u1ed1i b\u1edfi website n\u00e0y c\u00f3 gi\u1ea5y ph\u00e9p ri\u00eang th\u00ec tu\u00e2n th\u1ee7 theo gi\u1ea5y ph\u00e9p c\u1ee7a n\u1ed9i dung \u0111\u00f3.",
            "title": "Trang ch\u1ee7"
        },
        {
            "location": "/#bo-tai-lieu-bbc-microbit-tieng-viet",
            "text": "",
            "title": "B\u1ed9 t\u00e0i li\u1ec7u BBC Microbit ti\u1ebfng Vi\u1ec7t"
        },
        {
            "location": "/#noi-dung-cung-cap",
            "text": "",
            "title": "N\u1ed9i dung cung c\u1ea5p"
        },
        {
            "location": "/#ban-quyen",
            "text": "To\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA  Ghi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, v\u00e0 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.  B\u1ea5t k\u1ef3 nh\u1eefng n\u1ed9i dung ph\u00e2n ph\u1ed1i b\u1edfi website n\u00e0y c\u00f3 gi\u1ea5y ph\u00e9p ri\u00eang th\u00ec tu\u00e2n th\u1ee7 theo gi\u1ea5y ph\u00e9p c\u1ee7a n\u1ed9i dung \u0111\u00f3.",
            "title": "B\u1ea3n quy\u1ec1n"
        },
        {
            "location": "/lancaster-mbed/",
            "text": "Gi\u1edbi thi\u1ec7u\n\n\nB\u1ed9 l\u1ec7nh micro:bit runtime cung c\u1ea5p m\u1ed9t m\u00f4i tr\u01b0\u1eddng d\u1ec5 s\u1eed d\u1ee5ng \u0111\u1ec3 l\u1eadp tr\u00ecnh\ncho BBC micro:bit b\u1eb1ng ng\u00f4n ng\u1eef C/C++, vi\u1ebft b\u1edfi tr\u01b0\u1eddng \u0111\u1ea1i h\u1ecdc Lancaster. N\u00f3\nbao g\u1ed3m c\u00e1c th\u01b0 vi\u1ec7n drivers cho t\u1ea5t c\u1ea3 c\u00e1c ch\u1ee9c n\u0103ng ph\u1ea7n c\u1ee9ng c\u1ee7a\nmicro:bit, v\u00e0 c\u0169ng l\u00e0 m\u1ed9t b\u1ed9 c\u00e1c c\u01a1 ch\u1ebf th\u1ef1c thi (runtime) \u0111\u1ec3 gi\u00fap vi\u1ec7c l\u1eadp\ntr\u00ecnh micro:bit \u0111\u01b0\u1ee3c d\u1ec5 h\u01a1n v\u00e0 uy\u1ec3n chuy\u1ec3n h\u01a1n. Ch\u00fang bao g\u1ed3m t\u1eeb vi\u1ec7c \u0111\u1ec1u\nkhi\u1ec3n m\u1ed9t m\u00e0n h\u00ecnh LED ma tr\u1eadn \u0111\u1ebfn truy\u1ec1n t\u00edn hi\u1ec7u radio ngang c\u1ea5p\n(peer-to-peer) v\u00e0 c\u00e1c d\u1ecbch v\u1ee5 Bluetooth n\u0103ng l\u01b0\u1ee3ng th\u1ea5p (BLE) c\u00f3 b\u1ea3o m\u1eadt. B\u1ed9\nl\u1ec7nh micro:bit runtime t\u1ef1 h\u00e0o \u0111\u01b0\u1ee3c x\u00e2y d\u1ef1ng tr\u00ean c\u00e1c n\u1ec1n t\u1ea3ng \nARM\nmbed\n  v\u00e0 \nNordic nrf51\n.\n\n\nNgo\u00e0i vi\u1ec7c h\u1ed7 tr\u1ee3 ph\u00e1t tri\u1ec3n b\u1eb1ng C/C++, b\u1ed9 l\u1ec7nh n\u00e0y c\u0169ng \u0111\u01b0\u1ee3c thi\u1ebft k\u1ebf \u0111\u1eb7c\nbi\u1ec7t \u0111\u1ec3 h\u1ed7 tr\u1ee3 c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh c\u1ea5p cao do c\u00e1c \u0111\u1ed1i t\u00e1c c\u1ee7a ch\u00fang t\u00f4i\nph\u00e1t tri\u1ec3n cho micro:bit. N\u00f3 \u0111ang \u0111\u01b0\u1ee3c d\u00f9ng nh\u01b0 m\u1ed9t th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 cho t\u1ea5t\nc\u1ea3 c\u00e1c ng\u00f4n ng\u1eef l\u1eadp tr\u00ecnh tr\u00ean trang web BBC\n\nwww.microbit.co.uk\n, bao g\u1ed3m c\u00e1c ng\u00f4n ng\u1eef\nMicrosoft Block Editor, Microsoft Touch Develop, Code Kingdom\u2019s JavaScript\nv\u00e0 Micropython.\n\n\nTr\u00ean c\u00e1c trang n\u00e0y, b\u1ea1n s\u1ebd t\u00ecm th\u1ea5y h\u01b0\u1edbng d\u1eabn l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 b\u1eaft \u0111\u1ea7u s\u1eed d\u1ee5ng\nb\u1ed9 l\u1ec7nh runtime trong C/C++, t\u00f3m t\u1eaft c\u1ee7a t\u1ea5t c\u1ea3 c\u00e1c th\u00e0nh ph\u1ea7n c\u1ea5u t\u1ea1o n\u00ean\nh\u1ec7 th\u1ed1ng, v\u00e0 m\u1ed9t b\u1ed9 t\u00e0i li\u1ec7u \u0111\u1ea7y \u0111\u1ee7 v\u1ec1 c\u00e1c API (c\u00e1c h\u00e0m m\u00e0 b\u1ea1n c\u00f3 th\u1ec3 d\u00f9ng\n\u0111\u1ec3 \u0111i\u1ec1u khi\u1ec3n micro:bit).\n\n\n\u0110\u1ec3 th\u1eed th\u1ea5y vi\u1ec7c b\u1eaft tay v\u00e0o d\u1ec5 nh\u01b0 th\u1ebf n\u00e0o, h\u00e3y xem m\u1ed9t \nch\u01b0\u01a1ng tr\u00ecnh m\u1eabu\n.\n\n\nB\u1eaft \u0111\u1ea7u t\u00ecm hi\u1ec3u\n#\n\n\nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh v\u1edbi micro:bit runtime th\u1eadt \u0111\u01a1n gi\u1ea3n, sau \u0111\u00e2y l\u00e0 nh\u1eefng c\u00e1ch\nkh\u00e1c nhau \u0111\u1ec3 t\u1ea1o ra c\u00e1c ch\u01b0\u01a1ng tr\u00ecnh cho thi\u1ebft b\u1ecb c\u1ee7a b\u1ea1n.\n\n\n\n    \n\n        \nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh online\n\n    \n\n    \n\n        M\u1ed9t b\u1ea3n h\u01b0\u1edbng d\u1eabn c\u01a1 b\u1ea3n \u0111\u1ec3 x\u00e2y d\u1ef1ng m\u1ed9t d\u1ef1 \u00e1n\n        trong m\u00f4i tr\u01b0\u1eddng l\u1eadp tr\u00ecnh online.\n    \n\n    \n\n        \n\n            \n\n                C\u00e1c c\u00f4ng c\u1ee5 ph\u00e1t tri\u1ec3n online\n            \n\n        \n\n    \n\n\n\n\n\n\n    \n\n        \nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh offline\n\n    \n\n    \n\n        M\u1ed9t b\u1ea3n h\u01b0\u1edbng d\u1eabn \u0111\u1ea7y \u0111\u1ee7 \u0111\u1ec3 c\u00e0i \u0111\u1eb7t c\u00e1c c\u00f4ng c\u1ee5 ph\u00e1t tri\u1ec3n ch\u01b0\u01a1ng tr\u00ecnh tr\u00ean m\u00e1y t\u00ednh, v\u00e0 m\u1ed9t tutorial \u0111\u1ec3\n        x\u00e2y d\u1ef1ng m\u1ed9t d\u1ef1 \u00e1n l\u00e0m v\u00ed d\u1ee5.\n    \n\n    \n\n        \n\n            \n\n                C\u00e1c c\u00f4ng c\u1ee5 ph\u00e1t tri\u1ec3n offline\n            \n\n        \n\n    \n\n\n\n\n\nC\u00e1c b\u01b0\u1edbc k\u1ebf ti\u1ebfp\n#\n\n\nSau khi b\u1ea1n \u0111\u00e3 ch\u1ecdn m\u00f4i tr\u01b0\u1eddng ph\u00e1t tri\u1ec3n ch\u01b0\u01a1ng tr\u00ecnh, b\u01b0\u1edbc k\u1ebf ti\u1ebfp ph\u1ea3i\nl\u00e0: \nL\u1eacP TR\u00ccNH\n!\n\n\n\u0110\u00e2y l\u00e0 v\u00e0i \u0111o\u1ea1n code m\u1eabu \u0111\u1ec3 b\u1ea1n b\u1eaft \u0111\u1ea7u:\n\n\n#include \"MicroBit.h\"\n\nMicroBit uBit;\n\nint main()\n{\n    uBit.init();\n\n    uBit.display.scroll(\"HELLO WORLD!\");\n\n    release_fiber();\n}\n\n\n\n\nuBit l\u00e0 g\u00ec?\n#\n\n\nuBit l\u00e0 m\u1ed9t b\u1ea3n hi\u1ec7n th\u1ef1c h\u00f3a l\u1edbp \nMicroBit\n \u0111\u1ec3 cung c\u1ea5p m\u1ed9t c\u00e1ch\nth\u1eadt s\u1ef1 \u0111\u01a1n gi\u1ea3n nh\u1eb1m t\u01b0\u01a1ng t\u00e1c v\u1edbi c\u00e1c th\u00e0nh ph\u1ea7n kh\u00e1c nhau tr\u00ean m\u1ea1ch\nmicro:bit.\n\n\nS\u1ef1 \u0111\u01a1n gi\u1ea3n c\u00f3 th\u1ec3 th\u1ea5y qua m\u1ed9t d\u00f2ng l\u1ec7nh n\u00e0y:\n\n\ncpp uBit.display.scroll(\"HELLO WORLD!\");\n\n\nD\u00f2ng l\u1ec7nh n\u00e0y ch\u1ea1y ch\u1eef \nHELLO WORLD!\n ngang m\u00e0n h\u00ecnh c\u1ee7a micro:bit.\n\n\nKh\u1edfi t\u1ea1o\n#\n\n\nTrong v\u00ed d\u1ee5 tr\u00ean, c\u00f3 m\u1ed9t d\u00f2ng l\u1ec7nh d\u00f9ng \u0111\u1ec3 kh\u1edfi t\u1ea1o m\u1ed9t \u0111\u1ed1i t\u01b0\u1ee3ng uBit:\n\n\ncpp uBit.init();\n\n\nTrong l\u1ec7nh g\u1ecdi \u0111\u1ebfn tr\u00ecnh x\u1ebfp l\u1ecbch (scheduler) n\u00e0y, ch\u01b0\u01a1ng tr\u00ecnh c\u1ea5p ph\u00e1t b\u1ed9\nnh\u1edb v\u00e0 ng\u0103n x\u1ebfp Bluetooth \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o.\n\n\n\n\nL\u01b0u \u00fd\n\n\nD\u00f2ng n\u00e0y \u0111\u01b0\u1ee3c x\u00f3a \u0111i trong t\u1ea5t c\u1ea3 c\u00e1c v\u00ed d\u1ee5 b\u1ea1n s\u1ebd th\u1ea5y tr\u00ean trang web n\u00e0y, ch\u1ec9 \u0111\u1ec3 tr\u00e1nh\nl\u1eb7p l\u1ea1i!\n\n\n\n\n\u201cfiber\u201d l\u00e0 g\u00ec v\u00e0 t\u1ea1i sao ch\u00fang ta gi\u1ea3i ph\u00f3ng n\u00f3?\n#\n\n\n\u201cFiber\u201d l\u00e0 c\u00e1c lu\u1ed3ng h\u1ea1ng nh\u1eb9, \u0111\u01b0\u1ee3c d\u00f9ng b\u1edfi b\u1ed9 runtime \u0111\u1ec3 th\u1ef1c hi\u1ec7n c\u00e1c t\u00e1c\nv\u1ee5 kh\u00f4ng \u0111\u1ed3ng b\u1ed9.\n\n\nM\u1ed9t h\u00e0m g\u1ecdi \nrelease_fiber();\n \u0111\u01b0\u1ee3c khuy\u00ean d\u00f9ng khi k\u1ebft th\u00fac ch\u01b0\u01a1ng tr\u00ecnh\nch\u00ednh \u0111\u1ec3 gi\u1ea3i ph\u00f3ng c\u00e1i fiber ch\u00ednh, v\u00e0 nh\u1ea3y v\u00e0o ch\u01b0\u01a1ng tr\u00ecnh x\u1ebfp l\u1ecbch v\u00f4\nth\u1eddi h\u1ea1n nh\u01b0 b\u1ea1n c\u00f3 th\u1ec3 th\u1ea5y c\u00e1c fiber kh\u00e1c ch\u1ea1y \u1edf \u0111\u00e2u \u0111\u00f3 trong ch\u01b0\u01a1ng\ntr\u00ecnh. N\u00f3 c\u0169ng c\u00f3 ngh\u0129a l\u00e0 b\u1ed9 x\u1eed l\u00fd s\u1ebd nh\u1ea3y v\u00e0o m\u1ed9t ch\u1ebf \u0111\u1ed9 ng\u1ee7 \u0111\u1ec3 ti\u1ebft ki\u1ec7m\nn\u0103ng l\u01b0\u1ee3ng, khi kh\u00f4ng c\u00f3 ti\u1ebfn tr\u00ecnh n\u00e0o \u0111ang ch\u1ea1y.\n\n\nN\u1ebfu d\u00f2ng n\u00e0y b\u1ecb b\u1ecf \u0111i, ch\u01b0\u01a1ng tr\u00ecnh c\u1ee7a b\u1ea1n s\u1ebd ng\u1eebng th\u1ef1c  hi\u1ec7n m\u1ecdi t\u00e1c v\u1ee5.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/#bat-au-tim-hieu",
            "text": "Vi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh v\u1edbi micro:bit runtime th\u1eadt \u0111\u01a1n gi\u1ea3n, sau \u0111\u00e2y l\u00e0 nh\u1eefng c\u00e1ch\nkh\u00e1c nhau \u0111\u1ec3 t\u1ea1o ra c\u00e1c ch\u01b0\u01a1ng tr\u00ecnh cho thi\u1ebft b\u1ecb c\u1ee7a b\u1ea1n.",
            "title": "B\u1eaft \u0111\u1ea7u t\u00ecm hi\u1ec3u"
        },
        {
            "location": "/lancaster-mbed/#cac-buoc-ke-tiep",
            "text": "Sau khi b\u1ea1n \u0111\u00e3 ch\u1ecdn m\u00f4i tr\u01b0\u1eddng ph\u00e1t tri\u1ec3n ch\u01b0\u01a1ng tr\u00ecnh, b\u01b0\u1edbc k\u1ebf ti\u1ebfp ph\u1ea3i\nl\u00e0:  L\u1eacP TR\u00ccNH !  \u0110\u00e2y l\u00e0 v\u00e0i \u0111o\u1ea1n code m\u1eabu \u0111\u1ec3 b\u1ea1n b\u1eaft \u0111\u1ea7u:  #include \"MicroBit.h\"\n\nMicroBit uBit;\n\nint main()\n{\n    uBit.init();\n\n    uBit.display.scroll(\"HELLO WORLD!\");\n\n    release_fiber();\n}",
            "title": "C\u00e1c b\u01b0\u1edbc k\u1ebf ti\u1ebfp"
        },
        {
            "location": "/lancaster-mbed/#ubit-la-gi",
            "text": "uBit l\u00e0 m\u1ed9t b\u1ea3n hi\u1ec7n th\u1ef1c h\u00f3a l\u1edbp  MicroBit  \u0111\u1ec3 cung c\u1ea5p m\u1ed9t c\u00e1ch\nth\u1eadt s\u1ef1 \u0111\u01a1n gi\u1ea3n nh\u1eb1m t\u01b0\u01a1ng t\u00e1c v\u1edbi c\u00e1c th\u00e0nh ph\u1ea7n kh\u00e1c nhau tr\u00ean m\u1ea1ch\nmicro:bit.  S\u1ef1 \u0111\u01a1n gi\u1ea3n c\u00f3 th\u1ec3 th\u1ea5y qua m\u1ed9t d\u00f2ng l\u1ec7nh n\u00e0y:  cpp uBit.display.scroll(\"HELLO WORLD!\");  D\u00f2ng l\u1ec7nh n\u00e0y ch\u1ea1y ch\u1eef  HELLO WORLD!  ngang m\u00e0n h\u00ecnh c\u1ee7a micro:bit.",
            "title": "uBit l\u00e0 g\u00ec?"
        },
        {
            "location": "/lancaster-mbed/#khoi-tao",
            "text": "Trong v\u00ed d\u1ee5 tr\u00ean, c\u00f3 m\u1ed9t d\u00f2ng l\u1ec7nh d\u00f9ng \u0111\u1ec3 kh\u1edfi t\u1ea1o m\u1ed9t \u0111\u1ed1i t\u01b0\u1ee3ng uBit:  cpp uBit.init();  Trong l\u1ec7nh g\u1ecdi \u0111\u1ebfn tr\u00ecnh x\u1ebfp l\u1ecbch (scheduler) n\u00e0y, ch\u01b0\u01a1ng tr\u00ecnh c\u1ea5p ph\u00e1t b\u1ed9\nnh\u1edb v\u00e0 ng\u0103n x\u1ebfp Bluetooth \u0111\u01b0\u1ee3c kh\u1edfi t\u1ea1o.   L\u01b0u \u00fd  D\u00f2ng n\u00e0y \u0111\u01b0\u1ee3c x\u00f3a \u0111i trong t\u1ea5t c\u1ea3 c\u00e1c v\u00ed d\u1ee5 b\u1ea1n s\u1ebd th\u1ea5y tr\u00ean trang web n\u00e0y, ch\u1ec9 \u0111\u1ec3 tr\u00e1nh\nl\u1eb7p l\u1ea1i!",
            "title": "Kh\u1edfi t\u1ea1o"
        },
        {
            "location": "/lancaster-mbed/#fiber-la-gi-va-tai-sao-chung-ta-giai-phong-no",
            "text": "\u201cFiber\u201d l\u00e0 c\u00e1c lu\u1ed3ng h\u1ea1ng nh\u1eb9, \u0111\u01b0\u1ee3c d\u00f9ng b\u1edfi b\u1ed9 runtime \u0111\u1ec3 th\u1ef1c hi\u1ec7n c\u00e1c t\u00e1c\nv\u1ee5 kh\u00f4ng \u0111\u1ed3ng b\u1ed9.  M\u1ed9t h\u00e0m g\u1ecdi  release_fiber();  \u0111\u01b0\u1ee3c khuy\u00ean d\u00f9ng khi k\u1ebft th\u00fac ch\u01b0\u01a1ng tr\u00ecnh\nch\u00ednh \u0111\u1ec3 gi\u1ea3i ph\u00f3ng c\u00e1i fiber ch\u00ednh, v\u00e0 nh\u1ea3y v\u00e0o ch\u01b0\u01a1ng tr\u00ecnh x\u1ebfp l\u1ecbch v\u00f4\nth\u1eddi h\u1ea1n nh\u01b0 b\u1ea1n c\u00f3 th\u1ec3 th\u1ea5y c\u00e1c fiber kh\u00e1c ch\u1ea1y \u1edf \u0111\u00e2u \u0111\u00f3 trong ch\u01b0\u01a1ng\ntr\u00ecnh. N\u00f3 c\u0169ng c\u00f3 ngh\u0129a l\u00e0 b\u1ed9 x\u1eed l\u00fd s\u1ebd nh\u1ea3y v\u00e0o m\u1ed9t ch\u1ebf \u0111\u1ed9 ng\u1ee7 \u0111\u1ec3 ti\u1ebft ki\u1ec7m\nn\u0103ng l\u01b0\u1ee3ng, khi kh\u00f4ng c\u00f3 ti\u1ebfn tr\u00ecnh n\u00e0o \u0111ang ch\u1ea1y.  N\u1ebfu d\u00f2ng n\u00e0y b\u1ecb b\u1ecf \u0111i, ch\u01b0\u01a1ng tr\u00ecnh c\u1ee7a b\u1ea1n s\u1ebd ng\u1eebng th\u1ef1c  hi\u1ec7n m\u1ecdi t\u00e1c v\u1ee5.",
            "title": "\"fiber\" l\u00e0 g\u00ec v\u00e0 t\u1ea1i sao ch\u00fang ta gi\u1ea3i ph\u00f3ng n\u00f3?"
        },
        {
            "location": "/lancaster-mbed/concepts/",
            "text": "Concepts\n#\n\n\nThe micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED matrix display to peer-to-peer radio communication and secure\nBluetooth Low Energy services. The micro:bit runtime is proudly built on the \nARM mbed\n\nand \nNordic nrf51\n platforms.\n\n\nIn addition to supporting development in C/C++, the runtime is also designed specifically to support\nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the\nlanguages on the BBC \nwww.microbit.co.uk\n website, including Microsoft Block Editor, Microsoft Touch Develop, Code Kingdoms\nJavaScript and Micropython languages.\n\n\n\n\nA Component Based Approach\n#\n\n\nWhenever computer scientists tackle large programming problems, we take the time to split the problem into smaller,\nindependent sections to make the problem easier to solve (divide and conquer!).  The micro:bit runtime is no exception,\nand is made up of a number of smaller components. Each of these components looks after\na specific job on the micro:bit.\n\n\nBuilding up software like this helps us to write code in a way that is\nmuch easier to maintain as the amount of code grows. For example, a component called \nMicroBitDisplay\n\ncontrols the LEDs on the micro:bit, and lets the programmer show images, animations and messages. The\n\nMicroBitIO\n component controls input and output through the pins on the edge of the device.\n\n\nThe micro:bit runtime is object oriented, with each component typically being a C++ class.\nThere are over 30 components making up the runtime, and they are documented on these pages.\n\n\nTo make the runtime as easy to use as possible, there is also a grouping of the most commonly used components in\nan object called \nuBit\n (The \u2018u\u2019 being the greek letter mu - which often refers to \u2018micro\u2019 in scientific units!).\n\n\nThe uBit object can be used to easily access most of the functionality of the micro:bit. You can find the components\nand functions that can be accessed this way in the \nuBit\n in the navigation bar.\n\n\nTo show just how easy it is to get started, the following code shows how you would write a traditional Hello World program.\n\n\nThis uses the uBit object to access the display component, then instructs the display to scroll the given string across\nthe LEDs. Try to use the \nuBit\n menu tab above to find the documentation for this scroll() function!\n\n\nuBit.display.scroll(\"Hello micro:bit!\");\n\n\n\n\n\n\nNote\n\n\nDid you know that you don\u2019t need to use the uBit object? Advanced users will likely prefer to create only the components they need to conserve memory on the device. See the \nadvanced\n section for how to do this.\n\n\n\n\nEvents\n#\n\n\nComputer programs execute sequentially - one line after another, following the logic of the program you have written.\nSometimes though, we want to be able to determine \nwhen\n something has happened, and write some code to decide what should\nhappen in that case.\n\n\nFor example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the device\u2019s radio. For these sorts of cases, we create a \nMicroBitEvent\n.\n\n\nCreating Events\n#\n\n\nMany components will raise events when interesting things occur. For example, \n\u2018MicroBitAccelerometer\u2019\n will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall and \n\u2018MicroBitButton\u2019\n will send events on a range of button up, down, click and hold events.\nProgrammers are also free to send their own events whenever they feel it would be useful. \nMicroBitEvent\ns are \nvery\n simple, and consist of\nonly two numbers:\n\n\n\n\nsource\n - A number identifying the component that created the event.\n\n\nvalue\n - A number unique to the source that identifies the event.\n\n\n\n\nThe documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the \nbutton documentation\n to see that the source MICROBIT_ID_BUTTON_A has the value \u20181\u2019,\nand an event MICROBIT_BUTTON_EVT_CLICK with the value \u20183\u2019 is generated when a button is clicked.\n\n\nCreating an event is easy - just create a MicroBitEvent with the \nsource\n and \nvalue\n you need, and the runtime takes care of the rest:\n\n\nMicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);\n\n\n\n\nFeel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the \nmessageBus\n page for a complete table of the reserved source IDs.\n\n\nDetecting Events\n#\n\n\nThe micro:bit runtime has a component called the \nMicroBitMessageBus\n, and its job is remember which events your program is interested in, and\nto deliver \nMicroBitEvent\ns to your program as they occur.\n\n\nTo find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an \nevent handler\n.\n\n\nYou write an event handler through the \nMicroBitMessageBus\n \nlisten\n function.  \n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}\n\n\n\n\nNow, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function \u2018onButtonA\u2019 will be automatically executed.  \n\n\nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program. In fact, a block like the\nfollowing in the Microsoft Block language translates into code just like that shown above when it is run on a micro:bit!\n\n\n\n\nWildcard Events\n#\n\n\nSometimes though, you want to capture all events generated by some component. For example, you might want to know when any changes in a button has happened.\nIn this case, there is a special event value called \u2018MICROBIT_EVT_ANY\u2019. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\n\n\nYou can find out which ones by looking at the \nMicroBitEvent\n delivered to your function - it contains the \nsource\n and \nvalue\n variables that the \nMicroBitEvent\n was created with.\n\n\nFor example, you could write a program like this:\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\"CLICK\");\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\"DOWN\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}\n\n\n\n\nIf you \nREALLY\n want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component.\n\n\nUse this sparingly though, as this could be quite a lot of events!\n\n\nThe following code would attach the \nonEvent\n function to receive all the events from the whole runtime:\n\n\nvoid onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll(\"SOMETHING HAPPENED!\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}\n\n\n\n\nQueued Events\n#\n\n\nWhen you write an event handler, your function will be called each time the relevant event is raised. But what happens if your handler takes a long time to execute?\n\n\nThe example above will scroll \u201cSOMETHING HAPPENED\u201d whenever any event is raised\u2026 but scrolling that message will take several seconds to complete!\n\n\nWhat if another event happens during this time?  By default, the runtime will queue any events for your event handler until it has finished what its already doing.\n\n\nAs soon as your handler is finished processing an event, the next one will be delivered (any other event handlers will be unaffected though - just because one event handler is busy, doesn\u2019t mean that another one can\u2019t receive its events!).\n\n\nThe runtime does allow you to change this behaviour if you want to though. See the advanced documentation in \nMicroBitMessageBus\n for more details.\n\n\n\n\nNote\n\n\nMore advanced programmers might be interested to know that you can also attach event handler to member function of C++ objects. See the other forms of listen function in \nMicroBitMessageBus\n for more details.\n\n\n\n\nConcurrency\n#\n\n\nIt is not uncommon to want to write programs that can do more than one thing at a time. For example, it takes quite a long time to scroll a message over the LED matrix, so what if you want\nyour program to do something else while this is happening?\n\n\nPrograms that do more than one thing at a time are called \nconcurrent programs\n.\n\n\nThe runtime provides two ways you can achieve concurrency in your programs:\n\n\n\n\n\n\nFunctions that may take a very long time to complete (e.g. display.scroll) often have \u201cAsync\u201d versions (e.g. \ndisplay.scrollAsync\n).         \n\n\nThese functions have the exact same behaviour as their counterparts, but don\u2019t wait for the effect to finish before allowing the user\u2019s program to continue.\n\n\nInstead, as soon as the function is called, the user\u2019s program carries on executing (and can go an do something else while the task is running in the background).\n\n\n\n\n\n\nUsers can also make use of the runtime fiber scheduler. This lets you run parts of your program in the background, and share the processor on your micro:bit between those parts\nas they need it.\n\n\nIn fact, whenever you write an event handler, the runtime will normally execute your handler in the background in this way, so that it reduces the impact on the rest of your program!\n\n\nThe scheduler is a type of \nnon-preemptive scheduler\n. This means that the runtime will never take control away from your program - it will wait for it to make a call to a runtime\nfunction that is \nblocking\n.\n\n\nAll the functions that are blocking are listed as such in their documentation.  You can create \nfibers\n at any time.",
            "title": "Concepts"
        },
        {
            "location": "/lancaster-mbed/concepts/#concepts",
            "text": "The micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED matrix display to peer-to-peer radio communication and secure\nBluetooth Low Energy services. The micro:bit runtime is proudly built on the  ARM mbed \nand  Nordic nrf51  platforms.  In addition to supporting development in C/C++, the runtime is also designed specifically to support\nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the\nlanguages on the BBC  www.microbit.co.uk  website, including Microsoft Block Editor, Microsoft Touch Develop, Code Kingdoms\nJavaScript and Micropython languages.",
            "title": "Concepts"
        },
        {
            "location": "/lancaster-mbed/concepts/#a-component-based-approach",
            "text": "Whenever computer scientists tackle large programming problems, we take the time to split the problem into smaller,\nindependent sections to make the problem easier to solve (divide and conquer!).  The micro:bit runtime is no exception,\nand is made up of a number of smaller components. Each of these components looks after\na specific job on the micro:bit.  Building up software like this helps us to write code in a way that is\nmuch easier to maintain as the amount of code grows. For example, a component called  MicroBitDisplay \ncontrols the LEDs on the micro:bit, and lets the programmer show images, animations and messages. The MicroBitIO  component controls input and output through the pins on the edge of the device.  The micro:bit runtime is object oriented, with each component typically being a C++ class.\nThere are over 30 components making up the runtime, and they are documented on these pages.  To make the runtime as easy to use as possible, there is also a grouping of the most commonly used components in\nan object called  uBit  (The \u2018u\u2019 being the greek letter mu - which often refers to \u2018micro\u2019 in scientific units!).  The uBit object can be used to easily access most of the functionality of the micro:bit. You can find the components\nand functions that can be accessed this way in the  uBit  in the navigation bar.  To show just how easy it is to get started, the following code shows how you would write a traditional Hello World program.  This uses the uBit object to access the display component, then instructs the display to scroll the given string across\nthe LEDs. Try to use the  uBit  menu tab above to find the documentation for this scroll() function!  uBit.display.scroll(\"Hello micro:bit!\");   Note  Did you know that you don\u2019t need to use the uBit object? Advanced users will likely prefer to create only the components they need to conserve memory on the device. See the  advanced  section for how to do this.",
            "title": "A Component Based Approach"
        },
        {
            "location": "/lancaster-mbed/concepts/#events",
            "text": "Computer programs execute sequentially - one line after another, following the logic of the program you have written.\nSometimes though, we want to be able to determine  when  something has happened, and write some code to decide what should\nhappen in that case.  For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the device\u2019s radio. For these sorts of cases, we create a  MicroBitEvent .",
            "title": "Events"
        },
        {
            "location": "/lancaster-mbed/concepts/#creating-events",
            "text": "Many components will raise events when interesting things occur. For example,  \u2018MicroBitAccelerometer\u2019  will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall and  \u2018MicroBitButton\u2019  will send events on a range of button up, down, click and hold events.\nProgrammers are also free to send their own events whenever they feel it would be useful.  MicroBitEvent s are  very  simple, and consist of\nonly two numbers:   source  - A number identifying the component that created the event.  value  - A number unique to the source that identifies the event.   The documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the  button documentation  to see that the source MICROBIT_ID_BUTTON_A has the value \u20181\u2019,\nand an event MICROBIT_BUTTON_EVT_CLICK with the value \u20183\u2019 is generated when a button is clicked.  Creating an event is easy - just create a MicroBitEvent with the  source  and  value  you need, and the runtime takes care of the rest:  MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);  Feel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the  messageBus  page for a complete table of the reserved source IDs.",
            "title": "Creating Events"
        },
        {
            "location": "/lancaster-mbed/concepts/#detecting-events",
            "text": "The micro:bit runtime has a component called the  MicroBitMessageBus , and its job is remember which events your program is interested in, and\nto deliver  MicroBitEvent s to your program as they occur.  To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an  event handler .  You write an event handler through the  MicroBitMessageBus   listen  function.    void onButtonA(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}  Now, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function \u2018onButtonA\u2019 will be automatically executed.    You can call listen as many times as you want to attached functions to each of the events that are useful for your program. In fact, a block like the\nfollowing in the Microsoft Block language translates into code just like that shown above when it is run on a micro:bit!",
            "title": "Detecting Events"
        },
        {
            "location": "/lancaster-mbed/concepts/#wildcard-events",
            "text": "Sometimes though, you want to capture all events generated by some component. For example, you might want to know when any changes in a button has happened.\nIn this case, there is a special event value called \u2018MICROBIT_EVT_ANY\u2019. If you call listen with this value, then ALL events from the given source component will be delivered to your function.  You can find out which ones by looking at the  MicroBitEvent  delivered to your function - it contains the  source  and  value  variables that the  MicroBitEvent  was created with.  For example, you could write a program like this:  void onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\"CLICK\");\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\"DOWN\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}  If you  REALLY  want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component.  Use this sparingly though, as this could be quite a lot of events!  The following code would attach the  onEvent  function to receive all the events from the whole runtime:  void onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll(\"SOMETHING HAPPENED!\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}",
            "title": "Wildcard Events"
        },
        {
            "location": "/lancaster-mbed/concepts/#queued-events",
            "text": "When you write an event handler, your function will be called each time the relevant event is raised. But what happens if your handler takes a long time to execute?  The example above will scroll \u201cSOMETHING HAPPENED\u201d whenever any event is raised\u2026 but scrolling that message will take several seconds to complete!  What if another event happens during this time?  By default, the runtime will queue any events for your event handler until it has finished what its already doing.  As soon as your handler is finished processing an event, the next one will be delivered (any other event handlers will be unaffected though - just because one event handler is busy, doesn\u2019t mean that another one can\u2019t receive its events!).  The runtime does allow you to change this behaviour if you want to though. See the advanced documentation in  MicroBitMessageBus  for more details.   Note  More advanced programmers might be interested to know that you can also attach event handler to member function of C++ objects. See the other forms of listen function in  MicroBitMessageBus  for more details.",
            "title": "Queued Events"
        },
        {
            "location": "/lancaster-mbed/concepts/#concurrency",
            "text": "It is not uncommon to want to write programs that can do more than one thing at a time. For example, it takes quite a long time to scroll a message over the LED matrix, so what if you want\nyour program to do something else while this is happening?  Programs that do more than one thing at a time are called  concurrent programs .  The runtime provides two ways you can achieve concurrency in your programs:    Functions that may take a very long time to complete (e.g. display.scroll) often have \u201cAsync\u201d versions (e.g.  display.scrollAsync ).           These functions have the exact same behaviour as their counterparts, but don\u2019t wait for the effect to finish before allowing the user\u2019s program to continue.  Instead, as soon as the function is called, the user\u2019s program carries on executing (and can go an do something else while the task is running in the background).    Users can also make use of the runtime fiber scheduler. This lets you run parts of your program in the background, and share the processor on your micro:bit between those parts\nas they need it.  In fact, whenever you write an event handler, the runtime will normally execute your handler in the background in this way, so that it reduces the impact on the rest of your program!  The scheduler is a type of  non-preemptive scheduler . This means that the runtime will never take control away from your program - it will wait for it to make a call to a runtime\nfunction that is  blocking .  All the functions that are blocking are listed as such in their documentation.  You can create  fibers  at any time.",
            "title": "Concurrency"
        },
        {
            "location": "/lancaster-mbed/advanced/",
            "text": "Advanced Features of the Runtime\n#\n\n\nUnder the surface, the micro:bit runtime is a highly configurable, modular and component based piece of software.\n\n\nThe \nuBit\n object is provided as a collection of the commonly used components, all gathered together in one place\nto make it easier for novice users to access the functionality of the device. However, there is no obligation to\nuse the \nuBit\n abstraction. More advanced users may prefer to create and use only the parts of the runtime they\nneed.\n\n\nThis provides more control and often frees up more memory resource for the application program - but does so\nat the expense of the user taking more responsibility and additional complexity in their programs.\n\n\nUsing Components Directly\n#\n\n\nTaking advantage of the modular structure of the micro:bit runtime is fairly straightforward.\n\n\n\n\nFirstly, create a program that does \nnot\n create or initialise a uBit object.\n\n\nInclude \nMicroBit.h\n (or if you prefer, just the header files of the components you want to use). Including \nMicroBit.h\n is however, simpler.\n\n\nInstead, create C++ object instances of the classes that you want to use \nas global variables\n in your program. Create as many components as you need. You are free to use any of the constructors in this documentation.\n\n\nCall functions on those instances to elicit the behaviour you need, using the name of your object instances instead of \nuBit.*\n\n\n\n\nFor example, if you wanted to create a program that just used the LED matrix display driver, you might write a program like this:\n\n\n#include \"MicroBit.h\"\n\nMicroBitDisplay display;\n\nint main()\n{\n    while(1)\n        display.scroll(\":)\");\n}\n\n\n\n\nIf you need other components, add them to your program in the same way.\n\n\nIf a component has a dependency on another component (e.g. in the example below, the accelerometer is dependent on an I2C bus), then this will be requested as a mandatory parameter in the constructor.\n\n\nSee the \u2018Constructor\u2019 section of the each components\u2019 API documentation for details and examples.\n\n\n#include \"MicroBit.h\"\n\nMicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0);\nMicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);\nMicroBitDisplay display;\n\nint main()\n{\n    while(1)\n        display.scroll(accelerometer.getX());\n}\n\n\n\n\n\n\nWarning\n\n\nmicro:bit runtime components should \nalways\n be brought up as global variables. They should \nnot\n be created as local variables - either in your main method or anywhere else. The reason for this is the the runtime is a multi-threaded environment, and any variables created in stack memory (like local variables) may be paged out by the scheduler, and result in instability if they utilise interrupts or are accessed by other threads. So\u2026 don\u2019t do it!\n\n\n\n\nSystem Components\n#\n\n\nThere are also system components that provide background services. Without the \nuBit\n object, these will not be created by default.  Examples include the fiber scheduler, message bus and heap allocator.\n\n\nYou are not required to initialise these components, but you should do so if you want to benefit from the functionality they provide. The following section describe how to do this.\n\n\nInitialising the Message Bus\n#\n\n\nThe \nMicroBitMessageBus\n allows events to be created and delivered to applications.  So if a \nMicroBitMessageBus\n is not created, then all events in the micro:bit runtime will be quietly ignored.\n\n\nTo enable this functionality, simply create an instance of the \nMicroBitMessageBus\n class. From that point onward in your program, you can raise and listen for events as described in the \nMicroBitMessageBus\n documentation.\n\n\n#include \"MicroBit.h\"\n\nMicroBitMessageBus bus;\nMicroBitButton buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);\nMicroBitDisplay display;\n\nvoid onPressed(MicroBitEvent e)\n{\n    display.print(\"S\");    \n}\n\nint main()\n{\n    bus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onPressed);\n\n    while(1)\n    {\n    }\n}\n\n\n\n\n\n\nWarning\n\n\nRunning a MessageBus without the Fiber Scheduler will result in all event handlers being registered as MESSAGE_BUS_LISTENER_IMMEDIATE (see \nMicroBitMessageBus\n for details). This means that your event handler will be executed in the context of the code that raised the event. This may include interrupt context, which may not be safe for all operations. It is recommend that you always run the MessageBus with the Fiber Scheduler in order to allow the event to be decoupled from interrupt context.\n\n\n\n\nInitialising the Fiber Scheduler\n#\n\n\nOften when using asynchronous events, it is also useful to run the fiber scheduler. Without a scheduler in operation, all event handlers (such as the one above) will be executed with the threading mode \nMESSAGE_BUS_LISTENER_IMMEDIATE\n, as\ndescribed on the \nMicroBitMessageBus\n documentation.\n\n\nAlso, it is not really possible to transparently enter a power efficient sleep - as illustrated in the busy loop in the above example.\n\n\nInitialising the fiber scheduler is simple, and is demonstrated in the following example.\n\n\nFrom the moment the fiber scheduler is initialised, it is then possible to block the processor in a power efficient way and to operate threaded event handlers:\n\n\n#include \"MicroBit.h\"\n\nMicroBitMessageBus bus;\nMicroBitButton buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);\nMicroBitDisplay display;\n\nvoid onPressed(MicroBitEvent e)\n{\n    display.print(\"S\");    \n}\n\nint main()\n{\n    scheduler_init(bus);\n\n    bus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onPressed);\n\n    while(1)\n        fiber_sleep(1000);\n}\n\n\n\n\n\n\nNote\n\n\nFunction calls to \nuBit.sleep()\n must be replaced with the direct, equivalent calls to the scheduler using \nfiber_sleep()\n.\n\n\n\n\nInitialising the Heap Allocator\n#\n\n\nThe micro:bit runtime provides an optional, heap memory allocator. This is primarily to permit the use of \nmultiple\n regions of memory to be used as heap memory space for your variables.\n\n\nThe \nuBit\n initialisation function will automatically release any memory unused by the Bluetooth stack for general purpose use in this fashion (this typically provides an additional 1K of SRAM under Bluetooth enabled builds, and another 8K if Bluetooth is disabled).\n\n\nShould you wish to also reclaim memory in this way, you can do so as follows:\n\n\n#include \"MicroBit.h\"\n\nint main()\n{\n    microbit_create_heap(MICROBIT_SD_GATT_TABLE_START + MICROBIT_SD_GATT_TABLE_SIZE, MICROBIT_SD_LIMIT);\n}\n\n\n\n\nCompile Time Configuration Options\n#\n\n\nIn addition to the flexibility to initialise only the components that you need, the runtime also provides a central, compile time configuration file called \nMicroBitConfig.h\n.\n\n\nYou can use this to reconfigure the default behaviour of the runtime.\n\n\nThe default settings will provide a stable working environment, but advanced users may want to further tailor the behaviour.\n\n\nTo tailor the behaviour, simply edit the \nMicroBitConfig.h\n file to change the settings, and then perform a clean rebuild.\n\n\nCompile Time Options with MicroBitConfig.h\n#\n\n\nThe following options are configurable at compile time through \nMicroBitConfig.h\n:\n\n\n\n\n\n\n\n\nConfiguration option\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nMICROBIT_HEAP_ALLOCATOR\n\n\nEnables or disables the MicroBitHeapAllocator for \nuBit\n based builds.\n\n\n\n\n\n\nMICROBIT_HEAP_BLOCK_SIZE\n\n\nThe Block size used by the heap allocator in bytes.\n\n\n\n\n\n\nMICROBIT_NESTED_HEAP_SIZE\n\n\nThe proportion of SRAM available on the mbed heap to reserve for the micro:bit heap.\n\n\n\n\n\n\nMICROBIT_HEAP_REUSE_SD\n\n\nIf set to \u20181\u2019, any unused areas of the Soft Device GATT table will be automatically reused as heap memory.\n\n\n\n\n\n\nMICROBIT_SD_GATT_TABLE_SIZE\n\n\nThe amount of memory (bytes) to dedicate to the SoftDevice GATT table.\n\n\n\n\n\n\nSYSTEM_TICK_PERIOD_MS\n\n\nThe default scheduling quantum\n\n\n\n\n\n\nEVENT_LISTENER_DEFAUT_FLAGS\n\n\nThe default threading mode used when a \nMicroBitMessageBus\n listener is created.\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_MAX_QUEUE_DEPTH\n\n\nMaximum event queue depth. If a queue exceeds this depth, further events will be dropped.\n\n\n\n\n\n\nMICROBIT_SYSTEM_COMPONENTS\n\n\nThe maximum size of the interrupt callback list.\n\n\n\n\n\n\nMICROBIT_IDLE_COMPONENTS\n\n\nThe maximum size of the idle callback list.\n\n\n\n\n\n\nMICROBIT_BLE_ENABLED\n\n\nEnable/Disable Bluetooth during normal operation. If disabled, no Bluetooth communication is possible, but radio functionality is made possible, and an additional 8K of SRAM is released\n\n\n\n\n\n\nMICROBIT_BLE_PAIRING_MODE\n\n\nEnable/Disable Bluetooth pairing mode with A+B / reset at power up\n\n\n\n\n\n\nMICROBIT_BLE_PRIVATE_ADDRESSES\n\n\nEnable/Disable the use of private resolvable addresses. \nThis is known to be a feature that suffers compatibility issues with many Bluetooth central devices.\n\n\n\n\n\n\nMICROBIT_BLE_OPEN\n\n\nEnable/Disable Bluetooth security entirely. Open Bluetooth links are not secure, but are highly useful during the development of Bluetooth services\n\n\n\n\n\n\nMICROBIT_BLE_SECURITY_LEVEL\n\n\nDefine the default, global Bluetooth security requirements for MicroBit Bluetooth services\n\n\n\n\n\n\nMICROBIT_BLE_WHITELIST\n\n\nEnable/Disable the use of Bluetooth whitelisting.\n\n\n\n\n\n\nMICROBIT_BLE_ADVERTISING_TIMEOUT\n\n\nDefine the period of time for which the Bluetooth stack will advertise (seconds).\n\n\n\n\n\n\nMICROBIT_BLE_DEFAULT_TX_POWER\n\n\nDefines default power level of the Bluetooth radio transmitter.\n\n\n\n\n\n\nMICROBIT_BLE_DFU_SERVICE\n\n\nEnable/Disable Bluetooth Service: MicroBitDFU. This allows over the air programming during normal operation.\n\n\n\n\n\n\nMICROBIT_BLE_EVENT_SERVICE\n\n\nEnable/Disable Bluetooth Service: MicroBitEventService. This allows routing of events from the micro:bit message bus over Bluetooth.\n\n\n\n\n\n\nMICROBIT_BLE_DEVICE_INFORMATION_SERVICE\n\n\nEnable/Disable Bluetooth Service: MicroBitDeviceInformationService. This enables the standard Bluetooth device information service.\n\n\n\n\n\n\nMICROBIT_BLE_EDDYSTONE_URL\n\n\nEnable/Disable Eddystone URL support. Enabling this enables you to broadcast a physical web url from the microbit\n\n\n\n\n\n\nUSE_ACCEL_LSB\n\n\nEnable 10 bit sampling on the accelerometer. By default, a more efficient 8 bit sampling if used.\n\n\n\n\n\n\nMICROBIT_DISPLAY_TYPE\n\n\nSelects the default matrix configuration for the display driver.\n\n\n\n\n\n\nMICROBIT_DISPLAY_MINIMUM_BRIGHTNESS\n\n\nSelects the minimum permissible brightness level for the device.\n\n\n\n\n\n\nMICROBIT_DISPLAY_MAXIMUM_BRIGHTNESS\n\n\nSelects the maximum permissible brightness level for the device.\n\n\n\n\n\n\nMICROBIT_DISPLAY_DEFAULT_BRIGHTNESS\n\n\nSelects the default brightness level for the device.\n\n\n\n\n\n\nMICROBIT_DEFAULT_SCROLL_SPEED\n\n\nSelects the time taken to scroll a single pixel, in milliseconds.\n\n\n\n\n\n\nMICROBIT_DEFAULT_SCROLL_STRIDE\n\n\nSelects the number of pixels a scroll will move in each quantum.\n\n\n\n\n\n\nMICROBIT_DEFAULT_PRINT_SPEED\n\n\nSelects the time each character will be shown on the display during print operations, in milliseconds.\n\n\n\n\n\n\nMICROBIT_DEFAULT_SERIAL_MODE\n\n\nConfigures the default serial mode used by serial read and send calls.\n\n\n\n\n\n\nMICROBIT_DEFAULT_PULLMODE\n\n\nDefine the default mode in which the digital input pins are configured. Valid options are PullDown, PullUp and PullNone.\n\n\n\n\n\n\nMICROBIT_PANIC_HEAP_FULL\n\n\nEnable this to invoke a panic on out of memory conditions.\n\n\n\n\n\n\nMICROBIT_DBG\n\n\nEnable this to route debug messages through the USB serial interface.\n\n\n\n\n\n\nMICROBIT_HEAP_DBG\n\n\nEnable this to receive detailed diagnostic messages from the heap allocator via the USB serial interface.\n\n\n\n\n\n\nMICROBIT_DAL_VERSION\n\n\nDefine the default version information of the runtime.\n\n\n\n\n\n\n\n\nThere are also some constants that define the geometry of the micro:bit memory\n\n\n\n\nWarning\n\n\nOnly change these if you really know what you are doing!\n\n\n\n\n\n\n\n\n\n\nConfiguration option\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nMICROBIT_SRAM_BASE\n\n\nThe start address of usable RAM memory.\n\n\n\n\n\n\nMICROBIT_SRAM_END\n\n\nThe end address of usable RAM memory.\n\n\n\n\n\n\nMICROBIT_SD_LIMIT\n\n\nThe end address of RAM memory reserved for Soft Device (Nordic\u2019s Bluetooth stack).\n\n\n\n\n\n\nMICROBIT_SD_GATT_TABLE_START\n\n\nThe start address of the Bluetooth GATT table in RAM.\n\n\n\n\n\n\nCORTEX_M0_STACK_BASE\n\n\nThe memory address of the top of the system stack.\n\n\n\n\n\n\nMICROBIT_STACK_SIZE\n\n\nAmount of memory reserved for the stack (in bytes).\n\n\n\n\n\n\nMICROBIT_HEAP_END\n\n\nThe end address of the mbed heap space\n\n\n\n\n\n\n\n\nCompile Time Options with Yotta\n#\n\n\nRather than edit the \nMicroBitConfig.h\n file to change the default behaviour of the runtime, if you are using\n\nyotta\n, you can also provide a \nconfig.json\n in your project.\n\n\nHere\u2019s a \nconfig.json\n, using all available configuration options, that matches the default values specified in \nMicroBitConfig.h\n:\n\n\n{\n    \"microbit-dal\":{\n        \"bluetooth\":{\n            \"enabled\": 1,\n            \"pairing_mode\": 1,\n            \"private_addressing\": 0,\n            \"open\": 0,\n            \"whitelist\": 1,\n            \"advertising_timeout\": 0,\n            \"tx_power\": 0,\n            \"dfu_service\": 1,\n            \"event_service\": 1,\n            \"device_info_service\": 1,\n            \"eddystone_url\": 0\n        },\n        \"reuse_sd\": 1,\n        \"default_pullmode\":\"PullDown\",\n        \"gatt_table_size\": \"0x300\",\n        \"heap_allocator\": 1,\n        \"nested_heap_proportion\": 0.75,\n        \"system_tick_period\": 6,\n        \"system_components\": 10,\n        \"idle_components\": 6,\n        \"use_accel_lsb\": 0,\n        \"min_display_brightness\": 1,\n        \"max_display_brightness\": 255,\n        \"display_scroll_speed\": 120,\n        \"display_scroll_stride\": -1,\n        \"display_print_speed\": 400,\n        \"panic_on_heap_full\": 1,\n        \"debug\": 0,\n        \"heap_debug\": 0,\n        \"stack_size\":2048,\n        \"sram_base\":\"0x20000008\",\n        \"sram_end\":\"0x20004000\",\n        \"sd_limit\":\"0x20002000\",\n        \"gatt_table_start\":\"0x20001900\"\n    }\n}\n\n\n\n\nIt should be noted that \nall\n of the above options are optional, and will revert to their default values\nif not specified. This means that we can also provide a subset of these options, to configure specific\nparts of the runtime:\n\n\n{\n    \"microbit-dal\":{\n        \"bluetooth\":{\n            \"open\": 1\n        },\n        \"debug\":1\n    }\n}\n\n\n\n\nAdditionally, the options provided through \nconfig.json\n intuitively map onto the \n#defines\n\nlisted in \nMicroBitConfig.h\n\n\nAn example of \nconfig.json\n in operation is available at the \nmicrobit-samples\n GitHub repository.",
            "title": "Advanced"
        },
        {
            "location": "/lancaster-mbed/advanced/#advanced-features-of-the-runtime",
            "text": "Under the surface, the micro:bit runtime is a highly configurable, modular and component based piece of software.  The  uBit  object is provided as a collection of the commonly used components, all gathered together in one place\nto make it easier for novice users to access the functionality of the device. However, there is no obligation to\nuse the  uBit  abstraction. More advanced users may prefer to create and use only the parts of the runtime they\nneed.  This provides more control and often frees up more memory resource for the application program - but does so\nat the expense of the user taking more responsibility and additional complexity in their programs.",
            "title": "Advanced Features of the Runtime"
        },
        {
            "location": "/lancaster-mbed/advanced/#using-components-directly",
            "text": "Taking advantage of the modular structure of the micro:bit runtime is fairly straightforward.   Firstly, create a program that does  not  create or initialise a uBit object.  Include  MicroBit.h  (or if you prefer, just the header files of the components you want to use). Including  MicroBit.h  is however, simpler.  Instead, create C++ object instances of the classes that you want to use  as global variables  in your program. Create as many components as you need. You are free to use any of the constructors in this documentation.  Call functions on those instances to elicit the behaviour you need, using the name of your object instances instead of  uBit.*   For example, if you wanted to create a program that just used the LED matrix display driver, you might write a program like this:  #include \"MicroBit.h\"\n\nMicroBitDisplay display;\n\nint main()\n{\n    while(1)\n        display.scroll(\":)\");\n}  If you need other components, add them to your program in the same way.  If a component has a dependency on another component (e.g. in the example below, the accelerometer is dependent on an I2C bus), then this will be requested as a mandatory parameter in the constructor.  See the \u2018Constructor\u2019 section of the each components\u2019 API documentation for details and examples.  #include \"MicroBit.h\"\n\nMicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0);\nMicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);\nMicroBitDisplay display;\n\nint main()\n{\n    while(1)\n        display.scroll(accelerometer.getX());\n}   Warning  micro:bit runtime components should  always  be brought up as global variables. They should  not  be created as local variables - either in your main method or anywhere else. The reason for this is the the runtime is a multi-threaded environment, and any variables created in stack memory (like local variables) may be paged out by the scheduler, and result in instability if they utilise interrupts or are accessed by other threads. So\u2026 don\u2019t do it!",
            "title": "Using Components Directly"
        },
        {
            "location": "/lancaster-mbed/advanced/#system-components",
            "text": "There are also system components that provide background services. Without the  uBit  object, these will not be created by default.  Examples include the fiber scheduler, message bus and heap allocator.  You are not required to initialise these components, but you should do so if you want to benefit from the functionality they provide. The following section describe how to do this.",
            "title": "System Components"
        },
        {
            "location": "/lancaster-mbed/advanced/#initialising-the-message-bus",
            "text": "The  MicroBitMessageBus  allows events to be created and delivered to applications.  So if a  MicroBitMessageBus  is not created, then all events in the micro:bit runtime will be quietly ignored.  To enable this functionality, simply create an instance of the  MicroBitMessageBus  class. From that point onward in your program, you can raise and listen for events as described in the  MicroBitMessageBus  documentation.  #include \"MicroBit.h\"\n\nMicroBitMessageBus bus;\nMicroBitButton buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);\nMicroBitDisplay display;\n\nvoid onPressed(MicroBitEvent e)\n{\n    display.print(\"S\");    \n}\n\nint main()\n{\n    bus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onPressed);\n\n    while(1)\n    {\n    }\n}   Warning  Running a MessageBus without the Fiber Scheduler will result in all event handlers being registered as MESSAGE_BUS_LISTENER_IMMEDIATE (see  MicroBitMessageBus  for details). This means that your event handler will be executed in the context of the code that raised the event. This may include interrupt context, which may not be safe for all operations. It is recommend that you always run the MessageBus with the Fiber Scheduler in order to allow the event to be decoupled from interrupt context.",
            "title": "Initialising the Message Bus"
        },
        {
            "location": "/lancaster-mbed/advanced/#initialising-the-fiber-scheduler",
            "text": "Often when using asynchronous events, it is also useful to run the fiber scheduler. Without a scheduler in operation, all event handlers (such as the one above) will be executed with the threading mode  MESSAGE_BUS_LISTENER_IMMEDIATE , as\ndescribed on the  MicroBitMessageBus  documentation.  Also, it is not really possible to transparently enter a power efficient sleep - as illustrated in the busy loop in the above example.  Initialising the fiber scheduler is simple, and is demonstrated in the following example.  From the moment the fiber scheduler is initialised, it is then possible to block the processor in a power efficient way and to operate threaded event handlers:  #include \"MicroBit.h\"\n\nMicroBitMessageBus bus;\nMicroBitButton buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);\nMicroBitDisplay display;\n\nvoid onPressed(MicroBitEvent e)\n{\n    display.print(\"S\");    \n}\n\nint main()\n{\n    scheduler_init(bus);\n\n    bus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onPressed);\n\n    while(1)\n        fiber_sleep(1000);\n}   Note  Function calls to  uBit.sleep()  must be replaced with the direct, equivalent calls to the scheduler using  fiber_sleep() .",
            "title": "Initialising the Fiber Scheduler"
        },
        {
            "location": "/lancaster-mbed/advanced/#initialising-the-heap-allocator",
            "text": "The micro:bit runtime provides an optional, heap memory allocator. This is primarily to permit the use of  multiple  regions of memory to be used as heap memory space for your variables.  The  uBit  initialisation function will automatically release any memory unused by the Bluetooth stack for general purpose use in this fashion (this typically provides an additional 1K of SRAM under Bluetooth enabled builds, and another 8K if Bluetooth is disabled).  Should you wish to also reclaim memory in this way, you can do so as follows:  #include \"MicroBit.h\"\n\nint main()\n{\n    microbit_create_heap(MICROBIT_SD_GATT_TABLE_START + MICROBIT_SD_GATT_TABLE_SIZE, MICROBIT_SD_LIMIT);\n}",
            "title": "Initialising the Heap Allocator"
        },
        {
            "location": "/lancaster-mbed/advanced/#compile-time-configuration-options",
            "text": "In addition to the flexibility to initialise only the components that you need, the runtime also provides a central, compile time configuration file called  MicroBitConfig.h .  You can use this to reconfigure the default behaviour of the runtime.  The default settings will provide a stable working environment, but advanced users may want to further tailor the behaviour.  To tailor the behaviour, simply edit the  MicroBitConfig.h  file to change the settings, and then perform a clean rebuild.",
            "title": "Compile Time Configuration Options"
        },
        {
            "location": "/lancaster-mbed/advanced/#compile-time-options-with-microbitconfigh",
            "text": "The following options are configurable at compile time through  MicroBitConfig.h :     Configuration option  Brief Description      MICROBIT_HEAP_ALLOCATOR  Enables or disables the MicroBitHeapAllocator for  uBit  based builds.    MICROBIT_HEAP_BLOCK_SIZE  The Block size used by the heap allocator in bytes.    MICROBIT_NESTED_HEAP_SIZE  The proportion of SRAM available on the mbed heap to reserve for the micro:bit heap.    MICROBIT_HEAP_REUSE_SD  If set to \u20181\u2019, any unused areas of the Soft Device GATT table will be automatically reused as heap memory.    MICROBIT_SD_GATT_TABLE_SIZE  The amount of memory (bytes) to dedicate to the SoftDevice GATT table.    SYSTEM_TICK_PERIOD_MS  The default scheduling quantum    EVENT_LISTENER_DEFAUT_FLAGS  The default threading mode used when a  MicroBitMessageBus  listener is created.    MESSAGE_BUS_LISTENER_MAX_QUEUE_DEPTH  Maximum event queue depth. If a queue exceeds this depth, further events will be dropped.    MICROBIT_SYSTEM_COMPONENTS  The maximum size of the interrupt callback list.    MICROBIT_IDLE_COMPONENTS  The maximum size of the idle callback list.    MICROBIT_BLE_ENABLED  Enable/Disable Bluetooth during normal operation. If disabled, no Bluetooth communication is possible, but radio functionality is made possible, and an additional 8K of SRAM is released    MICROBIT_BLE_PAIRING_MODE  Enable/Disable Bluetooth pairing mode with A+B / reset at power up    MICROBIT_BLE_PRIVATE_ADDRESSES  Enable/Disable the use of private resolvable addresses.  This is known to be a feature that suffers compatibility issues with many Bluetooth central devices.    MICROBIT_BLE_OPEN  Enable/Disable Bluetooth security entirely. Open Bluetooth links are not secure, but are highly useful during the development of Bluetooth services    MICROBIT_BLE_SECURITY_LEVEL  Define the default, global Bluetooth security requirements for MicroBit Bluetooth services    MICROBIT_BLE_WHITELIST  Enable/Disable the use of Bluetooth whitelisting.    MICROBIT_BLE_ADVERTISING_TIMEOUT  Define the period of time for which the Bluetooth stack will advertise (seconds).    MICROBIT_BLE_DEFAULT_TX_POWER  Defines default power level of the Bluetooth radio transmitter.    MICROBIT_BLE_DFU_SERVICE  Enable/Disable Bluetooth Service: MicroBitDFU. This allows over the air programming during normal operation.    MICROBIT_BLE_EVENT_SERVICE  Enable/Disable Bluetooth Service: MicroBitEventService. This allows routing of events from the micro:bit message bus over Bluetooth.    MICROBIT_BLE_DEVICE_INFORMATION_SERVICE  Enable/Disable Bluetooth Service: MicroBitDeviceInformationService. This enables the standard Bluetooth device information service.    MICROBIT_BLE_EDDYSTONE_URL  Enable/Disable Eddystone URL support. Enabling this enables you to broadcast a physical web url from the microbit    USE_ACCEL_LSB  Enable 10 bit sampling on the accelerometer. By default, a more efficient 8 bit sampling if used.    MICROBIT_DISPLAY_TYPE  Selects the default matrix configuration for the display driver.    MICROBIT_DISPLAY_MINIMUM_BRIGHTNESS  Selects the minimum permissible brightness level for the device.    MICROBIT_DISPLAY_MAXIMUM_BRIGHTNESS  Selects the maximum permissible brightness level for the device.    MICROBIT_DISPLAY_DEFAULT_BRIGHTNESS  Selects the default brightness level for the device.    MICROBIT_DEFAULT_SCROLL_SPEED  Selects the time taken to scroll a single pixel, in milliseconds.    MICROBIT_DEFAULT_SCROLL_STRIDE  Selects the number of pixels a scroll will move in each quantum.    MICROBIT_DEFAULT_PRINT_SPEED  Selects the time each character will be shown on the display during print operations, in milliseconds.    MICROBIT_DEFAULT_SERIAL_MODE  Configures the default serial mode used by serial read and send calls.    MICROBIT_DEFAULT_PULLMODE  Define the default mode in which the digital input pins are configured. Valid options are PullDown, PullUp and PullNone.    MICROBIT_PANIC_HEAP_FULL  Enable this to invoke a panic on out of memory conditions.    MICROBIT_DBG  Enable this to route debug messages through the USB serial interface.    MICROBIT_HEAP_DBG  Enable this to receive detailed diagnostic messages from the heap allocator via the USB serial interface.    MICROBIT_DAL_VERSION  Define the default version information of the runtime.     There are also some constants that define the geometry of the micro:bit memory   Warning  Only change these if you really know what you are doing!      Configuration option  Brief Description      MICROBIT_SRAM_BASE  The start address of usable RAM memory.    MICROBIT_SRAM_END  The end address of usable RAM memory.    MICROBIT_SD_LIMIT  The end address of RAM memory reserved for Soft Device (Nordic\u2019s Bluetooth stack).    MICROBIT_SD_GATT_TABLE_START  The start address of the Bluetooth GATT table in RAM.    CORTEX_M0_STACK_BASE  The memory address of the top of the system stack.    MICROBIT_STACK_SIZE  Amount of memory reserved for the stack (in bytes).    MICROBIT_HEAP_END  The end address of the mbed heap space",
            "title": "Compile Time Options with MicroBitConfig.h"
        },
        {
            "location": "/lancaster-mbed/advanced/#compile-time-options-with-yotta",
            "text": "Rather than edit the  MicroBitConfig.h  file to change the default behaviour of the runtime, if you are using yotta , you can also provide a  config.json  in your project.  Here\u2019s a  config.json , using all available configuration options, that matches the default values specified in  MicroBitConfig.h :  {\n    \"microbit-dal\":{\n        \"bluetooth\":{\n            \"enabled\": 1,\n            \"pairing_mode\": 1,\n            \"private_addressing\": 0,\n            \"open\": 0,\n            \"whitelist\": 1,\n            \"advertising_timeout\": 0,\n            \"tx_power\": 0,\n            \"dfu_service\": 1,\n            \"event_service\": 1,\n            \"device_info_service\": 1,\n            \"eddystone_url\": 0\n        },\n        \"reuse_sd\": 1,\n        \"default_pullmode\":\"PullDown\",\n        \"gatt_table_size\": \"0x300\",\n        \"heap_allocator\": 1,\n        \"nested_heap_proportion\": 0.75,\n        \"system_tick_period\": 6,\n        \"system_components\": 10,\n        \"idle_components\": 6,\n        \"use_accel_lsb\": 0,\n        \"min_display_brightness\": 1,\n        \"max_display_brightness\": 255,\n        \"display_scroll_speed\": 120,\n        \"display_scroll_stride\": -1,\n        \"display_print_speed\": 400,\n        \"panic_on_heap_full\": 1,\n        \"debug\": 0,\n        \"heap_debug\": 0,\n        \"stack_size\":2048,\n        \"sram_base\":\"0x20000008\",\n        \"sram_end\":\"0x20004000\",\n        \"sd_limit\":\"0x20002000\",\n        \"gatt_table_start\":\"0x20001900\"\n    }\n}  It should be noted that  all  of the above options are optional, and will revert to their default values\nif not specified. This means that we can also provide a subset of these options, to configure specific\nparts of the runtime:  {\n    \"microbit-dal\":{\n        \"bluetooth\":{\n            \"open\": 1\n        },\n        \"debug\":1\n    }\n}  Additionally, the options provided through  config.json  intuitively map onto the  #defines \nlisted in  MicroBitConfig.h  An example of  config.json  in operation is available at the  microbit-samples  GitHub repository.",
            "title": "Compile Time Options with Yotta"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/",
            "text": "Web-based C/C++ environments supporting the runtime\n#\n\n\n\n\n\n\n\n\nOnline compiler\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nARM mbed has an online IDE for C/C++ development available at \nhttp://developer.mbed.org\n. It is free to use and the BBC micro:bit is one of its officially supported platforms. This online IDE provides a simple interface for writing, compiling and sharing projects like the micro:bit DAL, which is based on the \nmbed SDK\n.\n\n\n\n\n\n\n\n\nOur friends using the runtime\n#\n\n\n\n\n\n\n\n\nLanguage\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n\n\nThe Microsoft Programming Experience Toolkit (PXT) provides a programming experience based around JavaScript. The experience has a built-in progression from simple block-based editor, through in-browser text editor with robust auto-completion and auto-fixing, all the way to a professional integrated development environment, Visual Studio Code.\n\n\n\n\n\n\n \n\n\nWith its touch-based interface, Touch Develop has been designed for mobile devices with touchscreens. It can also be used with a pc, keyboard and mouse. Touch Develop introduces a statically-typed scripting language with syntax-directed editor. It can be used to produce web-based apps that can run online on any platform.\n\n\n\n\n\n\n\n\nThe Block Editor is a visual editor and provides an introduction to structured programming via drag and drop coding blocks that snap together. You can also convert a Block Editor script into a Touch Develop script which helps with the transition to text-based programming.\n\n\n\n\n\n\n\n\nCode Kingdoms is a visual JavaScript editor. It has a drag-and-drop interface making it accessible to beginners. You can also change from the visual editor to a text-based editor which supports the transition to text-based programming as the learner\u2019s coding skills progress.\n\n\n\n\n\n\n\n\nMicroPython is a completely text-based editor, perfect for those who want to push their coding skills further. A selection of \u2018snippets\u2019 are on hand to help auto-complete trickier tasks and a range of premade images and music are built-in to give you a helping hand with your code.\n\n\n\n\n\n\n\n\nmbed\n#\n\n\nARM mbed has an online IDE for C/C++ development available at \nhttp://developer.mbed.org\n. It is free to use and the BBC micro:bit is one of its officially supported platforms.\n\n\nThe online IDE provides a simple interface for writing, compiling and sharing projects like the micro:bit DAL, which is based on the \nmbed SDK\n.\n\n\n\n\nGetting started with mbed.org\n#\n\n\n\n\n\nHello World on mbed.org\n#\n\n\n\n\n\n\nCreate an account on \ndeveloper.mbed.org\n.\n\n\n\n\n\n\nVisit the \nmicro:bit platform page\n and \nadd the micro:bit to your compiler\n by clicking the \u201cAdd to your mbed compiler\u201d button in the right hand sidebar.\n\n\n\n\n\n\nGo to the \nmicrobit-samples\n project, and click the \nImport this program\n button for that project. The online IDE will open.\n\n\n\n\n\n\nComplete the import of the project and then select it in the sidebar and click the \nCompile\n button. The build will start. The first build will take longer than subsequent builds.\n\n\n\n\n\n\nYour browser will prompt you to download a file. Save this file locally, then drag and drop it onto your micro:bit. The copy triggers the orange LED on the back of the micro:bit to flash; it will stop flashing when the download is complete.\n\n\n\n\n\n\nWhen the copy process finishes, the micro:bit drive will reset and disconnect from your computer. At this point, your code will also start running!\n\n\n\n\n\n\nThere is a more detailed guide for using the micro:bit in mbed on the \nLancaster-University team wiki on mbed",
            "title": "Web-based Development"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/#web-based-cc-environments-supporting-the-runtime",
            "text": "Online compiler  Description       ARM mbed has an online IDE for C/C++ development available at  http://developer.mbed.org . It is free to use and the BBC micro:bit is one of its officially supported platforms. This online IDE provides a simple interface for writing, compiling and sharing projects like the micro:bit DAL, which is based on the  mbed SDK .",
            "title": "Web-based C/C++ environments supporting the runtime"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/#our-friends-using-the-runtime",
            "text": "Language  Description       The Microsoft Programming Experience Toolkit (PXT) provides a programming experience based around JavaScript. The experience has a built-in progression from simple block-based editor, through in-browser text editor with robust auto-completion and auto-fixing, all the way to a professional integrated development environment, Visual Studio Code.       With its touch-based interface, Touch Develop has been designed for mobile devices with touchscreens. It can also be used with a pc, keyboard and mouse. Touch Develop introduces a statically-typed scripting language with syntax-directed editor. It can be used to produce web-based apps that can run online on any platform.     The Block Editor is a visual editor and provides an introduction to structured programming via drag and drop coding blocks that snap together. You can also convert a Block Editor script into a Touch Develop script which helps with the transition to text-based programming.     Code Kingdoms is a visual JavaScript editor. It has a drag-and-drop interface making it accessible to beginners. You can also change from the visual editor to a text-based editor which supports the transition to text-based programming as the learner\u2019s coding skills progress.     MicroPython is a completely text-based editor, perfect for those who want to push their coding skills further. A selection of \u2018snippets\u2019 are on hand to help auto-complete trickier tasks and a range of premade images and music are built-in to give you a helping hand with your code.",
            "title": "Our friends using the runtime"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/#mbed",
            "text": "ARM mbed has an online IDE for C/C++ development available at  http://developer.mbed.org . It is free to use and the BBC micro:bit is one of its officially supported platforms.  The online IDE provides a simple interface for writing, compiling and sharing projects like the micro:bit DAL, which is based on the  mbed SDK .",
            "title": "mbed"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/#getting-started-with-mbedorg",
            "text": "",
            "title": "Getting started with mbed.org"
        },
        {
            "location": "/lancaster-mbed/online-toolchains/#hello-world-on-mbedorg",
            "text": "Create an account on  developer.mbed.org .    Visit the  micro:bit platform page  and  add the micro:bit to your compiler  by clicking the \u201cAdd to your mbed compiler\u201d button in the right hand sidebar.    Go to the  microbit-samples  project, and click the  Import this program  button for that project. The online IDE will open.    Complete the import of the project and then select it in the sidebar and click the  Compile  button. The build will start. The first build will take longer than subsequent builds.    Your browser will prompt you to download a file. Save this file locally, then drag and drop it onto your micro:bit. The copy triggers the orange LED on the back of the micro:bit to flash; it will stop flashing when the download is complete.    When the copy process finishes, the micro:bit drive will reset and disconnect from your computer. At this point, your code will also start running!    There is a more detailed guide for using the micro:bit in mbed on the  Lancaster-University team wiki on mbed",
            "title": "Hello World on mbed.org"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/",
            "text": "Yotta\n#\n\n\nThe micro:bit DAL is built on top of \nARM mbed\n and hence uses \nyotta\n as an offline build system.\n\n\nWhen using \nyotta\n to build micro:bit projects there are currently two supported toolchains:\n\n\n\n\nGCC\n\n\nARMCC\n\n\n\n\nInstallation on Windows\n#\n\n\nInstall yotta and dependencies\n#\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n.\n\n\nFor the micro:bit targets you currently still need the \nsrecord\n tools, which can be installed on \nWindows\n from \nsourceforge\n.\n\n\nsrecord\n is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\nFetch the example project\n#\n\n\ngit clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples\n\n\n\n\nSet your yotta target\n#\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we\u2019ll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\n\n\nNote\n\n\nIn microbit-samples this target will be configured by default.\n\n\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\nBuild the project\n#\n\n\nyt build\n\n\n\n\nFlash your micro:bit\n#\n\n\nThe final step is to check your hex works.\n\n\nThe \nyt build\n command will place files in \n/build/<TARGET_NAME>/source\n. The file you will need to flash will be microbit-combined.hex.  Simply drag and drop the hex onto the MICROBIT usb device.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \nE:\n) as follows:\n\n\ncopy build\\bbc-microbit-classic-gcc\\source\\microbit-samples-combined.hex E:\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nHELLO WORLD! :)\n on its display.\n\n\n\n\nInstallation on Mac OSX\n#\n\n\nInstall yotta and dependencies\n#\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n.\n\n\nFor the micro:bit targets you currently still need the \nsrecord\n tools, which can be installed on \nMac OSX\n using\n\nbrew\n:\n\n\nbrew install srecord\n\n\n\n\nYou can also install it manually from \nsourceforge\n.\n\n\nsrecord\n is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\nFetch the example project\n#\n\n\ngit clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples\n\n\n\n\nSet your yotta target\n#\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we\u2019ll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\n\n\nNote\n\n\nIn microbit-samples this target will be configured by default.\n\n\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\nBuild the project\n#\n\n\nyt build\n\n\n\n\nFlash your micro:bit\n#\n\n\nThe final step is to check your hex works.\n\n\nThe \nyt build\n command will place files in \n/build/<TARGET_NAME>/source\n. The file you will need to flash will be \nmicrobit-samples-combined.hex\n. Simply drag and drop the hex onto the MICROBIT usb device.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \n/Volumes/\"MICROBIT\"\n) as follows:\n\n\ncp ./build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex /Volumes/\"MICROBIT\"\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nHELLO WORLD! :)\n on its display.\n\n\n\n\nNote\n\n\nNote that if you\u2019d like to copy the file from the command line, you can use the following command in any \nyotta\n project to do so, though it assumes you have only one micro:bit plugged in:\n\n\ncp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex  /Volumes/\"MICROBIT\"\n\n\n\n\n\n\nInstallation on Linux\n#\n\n\nInstall yotta and dependencies\n#\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n.\n\n\nFor the micro:bit targets you currently still need the \nsrecord\n tools, which can be installed on \nUbuntu\n using\n\n\nsudo apt-get install srecord\n\n\n\n\nYou can also install it manually from \nsourceforge\n.\n\n\nsrecord\n is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\nFetch the example project\n#\n\n\ngit clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples\n\n\n\n\nSet your yotta target\n#\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we\u2019ll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\n\n\nNote\n\n\nIn microbit-samples this target will be configured by default.\n\n\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\nBuild the project\n#\n\n\nyt build\n\n\n\n\nFlash your micro:bit\n#\n\n\nThe final step is to check your hex works.\n\n\nThe \nyt build\n command will place files in \n/build/<TARGET_NAME>/source\n. The file you will need to flash will be \nmicrobit-samples-combined.hex\n. Simply drag and drop the hex onto the MICROBIT usb device.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \n/media/MICROBIT\n) as follows:\n\n\ncp ./build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex /media/MICROBIT\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nHELLO WORLD! :)\n on its display.\n\n\n\n\nNote\n\n\nNote that if you\u2019d like to copy the file from the command line, you can use the following command in any \nyotta\n project to do so, though it assumes you have only one micro:bit plugged in:\n\n\ncp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/",
            "title": "Offline Development"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#yotta",
            "text": "The micro:bit DAL is built on top of  ARM mbed  and hence uses  yotta  as an offline build system.  When using  yotta  to build micro:bit projects there are currently two supported toolchains:   GCC  ARMCC",
            "title": "Yotta"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#installation-on-windows",
            "text": "",
            "title": "Installation on Windows"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#install-yotta-and-dependencies",
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here .  For the micro:bit targets you currently still need the  srecord  tools, which can be installed on  Windows  from  sourceforge .  srecord  is used to create the final binaries for the micro:bit so is an essential dependency.",
            "title": "Install yotta and dependencies"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#fetch-the-example-project",
            "text": "git clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples",
            "title": "Fetch the example project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#set-your-yotta-target",
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we\u2019ll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc   Note  In microbit-samples this target will be configured by default.   You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).",
            "title": "Set your yotta target"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#build-the-project",
            "text": "yt build",
            "title": "Build the project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#flash-your-microbit",
            "text": "The final step is to check your hex works.  The  yt build  command will place files in  /build/<TARGET_NAME>/source . The file you will need to flash will be microbit-combined.hex.  Simply drag and drop the hex onto the MICROBIT usb device.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  E: ) as follows:  copy build\\bbc-microbit-classic-gcc\\source\\microbit-samples-combined.hex E:  The expected result will be that the micro:bit will scroll  HELLO WORLD! :)  on its display.",
            "title": "Flash your micro:bit"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#installation-on-mac-osx",
            "text": "",
            "title": "Installation on Mac OSX"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#install-yotta-and-dependencies_1",
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here .  For the micro:bit targets you currently still need the  srecord  tools, which can be installed on  Mac OSX  using brew :  brew install srecord  You can also install it manually from  sourceforge .  srecord  is used to create the final binaries for the micro:bit so is an essential dependency.",
            "title": "Install yotta and dependencies"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#fetch-the-example-project_1",
            "text": "git clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples",
            "title": "Fetch the example project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#set-your-yotta-target_1",
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we\u2019ll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc   Note  In microbit-samples this target will be configured by default.   You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).",
            "title": "Set your yotta target"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#build-the-project_1",
            "text": "yt build",
            "title": "Build the project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#flash-your-microbit_1",
            "text": "The final step is to check your hex works.  The  yt build  command will place files in  /build/<TARGET_NAME>/source . The file you will need to flash will be  microbit-samples-combined.hex . Simply drag and drop the hex onto the MICROBIT usb device.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  /Volumes/\"MICROBIT\" ) as follows:  cp ./build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex /Volumes/\"MICROBIT\"  The expected result will be that the micro:bit will scroll  HELLO WORLD! :)  on its display.   Note  Note that if you\u2019d like to copy the file from the command line, you can use the following command in any  yotta  project to do so, though it assumes you have only one micro:bit plugged in:  cp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex  /Volumes/\"MICROBIT\"",
            "title": "Flash your micro:bit"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#installation-on-linux",
            "text": "",
            "title": "Installation on Linux"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#install-yotta-and-dependencies_2",
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here .  For the micro:bit targets you currently still need the  srecord  tools, which can be installed on  Ubuntu  using  sudo apt-get install srecord  You can also install it manually from  sourceforge .  srecord  is used to create the final binaries for the micro:bit so is an essential dependency.",
            "title": "Install yotta and dependencies"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#fetch-the-example-project_2",
            "text": "git clone https://github.com/lancaster-university/microbit-samples\ncd microbit-samples",
            "title": "Fetch the example project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#set-your-yotta-target_2",
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we\u2019ll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc   Note  In microbit-samples this target will be configured by default.   You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).",
            "title": "Set your yotta target"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#build-the-project_2",
            "text": "yt build",
            "title": "Build the project"
        },
        {
            "location": "/lancaster-mbed/offline-toolchains/#flash-your-microbit_2",
            "text": "The final step is to check your hex works.  The  yt build  command will place files in  /build/<TARGET_NAME>/source . The file you will need to flash will be  microbit-samples-combined.hex . Simply drag and drop the hex onto the MICROBIT usb device.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  /media/MICROBIT ) as follows:  cp ./build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex /media/MICROBIT  The expected result will be that the micro:bit will scroll  HELLO WORLD! :)  on its display.   Note  Note that if you\u2019d like to copy the file from the command line, you can use the following command in any  yotta  project to do so, though it assumes you have only one micro:bit plugged in:  cp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/",
            "title": "Flash your micro:bit"
        },
        {
            "location": "/lancaster-mbed/device/",
            "text": "About the micro:bit\n#\n\n\n\n\nThe central processing unit (CPU) for the micro:bit is the \nNordic nRF51822\n\nand it controls all functionality offered by the micro:bit.\n\n\nOn board the micro:bit there is already:\n\n\n\n\na 5 x 5 LED matrix \ndisplay\n.\n\n\n2 programmable \nbuttons\n.\n\n\na 3-axis \naccelerometer\n.\n\n\nan \ne-compass\n.\n\n\nBluetooth\n.\n\n\n20 user controlled \npins\n, with Analog and Digital capabilities.\n\n\nserial\n capabilities over USB and the edge connector.\n\n\n\n\nDatasheets\n#\n\n\n\n    \nNordic nRF51822\n\n    \n\n        The central processing unit of the micro:bit, the nRF51822, controls and drives all functionality on\n        the micro:bit.\n    \n\n    \n\n        \n\n            Datasheet\n        \n\n    \n\n\n\n\n\n\n    \nNXP MAG3110\n\n    \n\n        The MAG3110 magnetometer is used in conjunction with with the 3-axis accelerometer\n        (MMA8653) to create an e-compass.\n    \n\n    \n\n        \n\n            Datasheet\n        \n\n    \n\n\n\n\n\n\n    \nNXP MMA8653\n\n    \n\n        The MMA8653 accelerometer provides orientation and acceleration information\n        of the micro:bit.\n    \n\n    \n\n        \n\n            Datasheet",
            "title": "Hardware"
        },
        {
            "location": "/lancaster-mbed/device/#about-the-microbit",
            "text": "The central processing unit (CPU) for the micro:bit is the  Nordic nRF51822 \nand it controls all functionality offered by the micro:bit.  On board the micro:bit there is already:   a 5 x 5 LED matrix  display .  2 programmable  buttons .  a 3-axis  accelerometer .  an  e-compass .  Bluetooth .  20 user controlled  pins , with Analog and Digital capabilities.  serial  capabilities over USB and the edge connector.",
            "title": "About the micro:bit"
        },
        {
            "location": "/lancaster-mbed/device/#datasheets",
            "text": "",
            "title": "Datasheets"
        },
        {
            "location": "/lancaster-mbed/help/",
            "text": "Need help?\n#\n\n\n\n\nIf you have any questions about the software or the hardware\nfor the micro:bit, please visit our \nstack exchange site\n as\nsomeone may have already answered your question! If they haven\u2019t, ask away!\n\n\n\n\nNote\n\n\nThis site is currently in the proposal stages of the StackExchange process, and\nwill hopefully become a fully fledged StackExchange area.\n\n\n\n\nIf you have found an issue with our \ndocumentation\n, or if something is not clear\nin the documentation, please file an issue on the \nmicrobit-docs github repository\n.\n\n\nIf you have found an issue with the \nruntime software\n, please file an issue on the\n\nmicrobit-dal github repository\n.",
            "title": "Help"
        },
        {
            "location": "/lancaster-mbed/help/#need-help",
            "text": "If you have any questions about the software or the hardware\nfor the micro:bit, please visit our  stack exchange site  as\nsomeone may have already answered your question! If they haven\u2019t, ask away!   Note  This site is currently in the proposal stages of the StackExchange process, and\nwill hopefully become a fully fledged StackExchange area.   If you have found an issue with our  documentation , or if something is not clear\nin the documentation, please file an issue on the  microbit-docs github repository .  If you have found an issue with the  runtime software , please file an issue on the microbit-dal github repository .",
            "title": "Need help?"
        },
        {
            "location": "/lancaster-mbed/ubit/",
            "text": "MicroBit\n#\n\n\nOverview\n#\n\n\nAlthough the runtime is built from lots of small components, we also provide an easy to use pre-packaged collection of the commonly used components\nall in one place. This makes it much easier to start programming your micro:bit in C.\n\n\nThis grouping is provided by a C++ class called \nMicroBit\n.  The \nMicroBit\n class has a number of\nmember variables, that operate as device drivers to control the most commonly used features of the micro:bit.\n\n\nThere is an instance of the \nMicroBit\n class created as a global variable in all the sample programs, called \nuBit\n:\n\n\n\n\nuBit {\n\n   \u2003\u2003\n.i2c\n,\n\n   \u2003\u2003\n.storage\n,\n\n   \u2003\u2003\n.serial\n,\n\n   \u2003\u2003\n.MessageBus\n,\n\n   \u2003\u2003\n.buttonA\n,\n\n   \u2003\u2003\n.buttonB\n,\n\n   \u2003\u2003\n.buttonAB\n,\n\n   \u2003\u2003\n.display\n,\n\n   \u2003\u2003\n.accelerometer\n,\n\n   \u2003\u2003\n.compass\n,\n\n   \u2003\u2003\n.thermometer\n,\n\n   \u2003\u2003\n.io\n,\n\n   \u2003\u2003\n.radio\n,\n\n   }\n\n\n\n\nYou can use dot operator \u2018.\u2019 to any of these resources inside uBit to access any of the functions they provide. There is a complete list of the\nfunctions available under the \nuBit\n menu item in the navigation bar at the top of the page.\n\n\nFor example, if we needed to scroll some text across the display, we simply would write the following:\n\n\nuBit.display.scroll(\"HELLO!\");\n\n\n\n\nSimilarly, if we wanted to send some text over serial, we could write the following\ncode:\n\n\nfor(int i = 3; i > 0; i--)\n{\n    uBit.serial.printf(\"%d...\", i);\n    uBit.sleep(1000);\n}\n\n// or alternatively...\nuBit.serial.send(\"Code!\");\n\n\n\n\nThe runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.\n\n\nTo place the current fiber into a power efficient \nsleep\n write the following:\n\n\n// where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\nNone\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\nNone\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBit()\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a representation of a  MicroBit  device, which includes member variables that represent various device drivers used to control aspects of the micro:bit.           \n\n\ninit\n#\n\n\n\n\nvoid\n \ninit\n()\n#\n\n\nDescription\n#\n\n\nPost constructor initialisation method.  \n\n\nThis call will initialised the scheduler, memory allocator and Bluetooth stack.  \n\n\nThis is required as the Bluetooth stack can\u2019t be brought up in a static context i.e. in a constructor.  \n\n\nExample\n#\n\n\n uBit.init(); \n\n\n\n\n\n\nNote\n\n\nThis method must be called before user code utilises any functionality contained by uBit. \n\n\n\n\nreset\n#\n\n\n\n\nvoid\n \nreset\n()\n#\n\n\nDescription\n#\n\n\nWill reset the micro:bit when called.  \n\n\nExample\n#\n\n\n uBit.reset(); \n\n\n\n\nsleep\n#\n\n\n\n\nvoid\n \nsleep\n( \nuint32_t\n milliseconds)\n#\n\n\nDescription\n#\n\n\nDelay execution for the given amount of time.  \n\n\nIf the scheduler is running, this will deschedule the current fiber and perform a power efficient, concurrent sleep operation.  \n\n\nIf the scheduler is disabled or we\u2019re running in an interrupt context, this will revert to a busy wait.  \n\n\nAlternatively: wait, wait_ms, wait_us can be used which will perform a blocking sleep operation.  \n\n\nParameters\n#\n\n\n\n\nuint32_t\n milliseconds - the amount of time, in ms, to wait for. This number cannot be negative.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.\n\n\nExample\n#\n\n\n uBit.sleep(20); //sleep for 20ms \n\n\n\n\n\n\nNote\n\n\nThis operation is currently limited by the rate of the system timer, therefore the granularity of the sleep operation is limited to 6 ms unless the rate of the system timer is modified. \n\n\n\n\nseedRandom\n#\n\n\n\n\nvoid\n \nseedRandom\n()\n#\n\n\nDescription\n#\n\n\nSeed the pseudo random number generator using the hardware random number generator.  \n\n\nExample\n#\n\n\n uBit.seedRandom(); \n\n\n\n\n\n\nvoid\n \nseedRandom\n( \nuint32_t\n seed)\n#\n\n\nDescription\n#\n\n\nSeed the pseudo random number generator using the given value.  \n\n\nParameters\n#\n\n\n\n\nuint32_t\n seed - The 32-bit value to seed the generator with.\n\n\n\n\nExample\n#\n\n\n uBit.seedRandom(0xBB5EED); \n\n\n\n\nrandom\n#\n\n\n\n\nint\n \nrandom\n( \nint\n max)\n#\n\n\nDescription\n#\n\n\nGenerate a random number in the given range. We use a simple Galois LFSR random number generator here, as a Galois LFSR is sufficient for our applications, and much more lightweight than the hardware random number generator built int the processor, which takes a long time and uses a lot of energy.  \n\n\nKIDS: You shouldn\u2019t use this is the real world to generate cryptographic keys though\u2026 have a think why not. :-)  \n\n\nParameters\n#\n\n\n\n\nint\n max - the upper range to generate a number for. This number cannot be negative.\n\n\n\n\nReturns\n#\n\n\nA random, natural number between 0 and the max-1. Or MICROBIT_INVALID_VALUE if max is <= 0.\n\n\nExample\n#\n\n\n uBit.random(200); //a number between 0 and 199 \n\n\n\n\nsystemTime\n#\n\n\n\n\nunsigned long\n \nsystemTime\n()\n#\n\n\nDescription\n#\n\n\nDetermine the time since this  MicroBit  was last reset.  \n\n\nReturns\n#\n\n\nThe time since the last reset, in milliseconds.\n\n\n\n\nNote\n\n\nThis will value overflow after 1.6 months. \n\n\n\n\nsystemVersion\n#\n\n\n\n\nconst char *\n \nsystemVersion\n()\n#\n\n\nDescription\n#\n\n\nDetermine the version of the micro:bit runtime currently in use.  \n\n\nReturns\n#\n\n\nA textual description of the version of the micro:bit runtime that is currently running on this device. \n\n\npanic\n#\n\n\n\n\nvoid\n \npanic\n()\n#\n\n\nDescription\n#\n\n\nTriggers a microbit panic where an loop will display a panic face and the status code, if provided.  \n\n\nThis loop will continue for panic_timeout iterations, defaults to 0 (infinite).  \n\n\npanic_timeout can be configured via a call to microbit_panic_timeout.  \n\n\nExample\n#\n\n\n microbit_panic_timeout(4); \n\n // will display loop for 4 iterations. \n uBit.panic(10); \n\n\n\n\n\n\nvoid\n \npanic\n( \nint\n statusCode)\n#\n\n\nDescription\n#\n\n\nTriggers a microbit panic where an loop will display a panic face and the status code, if provided.  \n\n\nThis loop will continue for panic_timeout iterations, defaults to 0 (infinite).  \n\n\npanic_timeout can be configured via a call to microbit_panic_timeout.  \n\n\nParameters\n#\n\n\n\n\nint\n statusCode - the status code of the associated error.\n\n\n\n\nExample\n#\n\n\n microbit_panic_timeout(4); \n\n // will display loop for 4 iterations. \n uBit.panic(10); \n\n\n\n\naddSystemComponent\n#\n\n\n\n\nint\n \naddSystemComponent\n( \nMicroBitComponent  *\n component)\n#\n\n\nDescription\n#\n\n\nAdd a component to the array of system components. This component will then receive periodic callbacks, once every tick period in interrupt context.  \n\n\nParameters\n#\n\n\n\n\nMicroBitComponent  *\n component - The component to add.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success or MICROBIT_NO_RESOURCES if the component array is full.\n\n\nExample\n#\n\n\n // heap allocated - otherwise it will be paged out! \n MicroBitDisplay* display = new MicroBitDisplay(); \n\n uBit.addSystemComponent(display); \n\n\n\n\n\n\nNote\n\n\nThis interface is now deprecated, and will be removed in the next major release. Please use  system_timer_add_component() . \n\n\n\n\nremoveSystemComponent\n#\n\n\n\n\nint\n \nremoveSystemComponent\n( \nMicroBitComponent  *\n component)\n#\n\n\nDescription\n#\n\n\nRemove a component from the array of system components. This component will no longer receive periodic callbacks.  \n\n\nParameters\n#\n\n\n\n\nMicroBitComponent  *\n component - The component to remove.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success or MICROBIT_INVALID_PARAMETER is returned if the given component has not been previously added.\n\n\nExample\n#\n\n\n // heap allocated - otherwise it will be paged out! \n MicroBitDisplay* display = new MicroBitDisplay(); \n\n uBit.addSystemComponent(display); \n\n uBit.removeSystemComponent(display); \n\n\n\n\n\n\nNote\n\n\nThis interface is now deprecated, and will be removed in the next major release. Please use  system_timer_remove_component() . \n\n\n\n\naddIdleComponent\n#\n\n\n\n\nint\n \naddIdleComponent\n( \nMicroBitComponent  *\n component)\n#\n\n\nDescription\n#\n\n\nAdds a component to the array of idle thread components, which are processed when the run queue is empty.  \n\n\nThe system timer will poll isIdleCallbackNeeded on each component to determine if the scheduler should schedule the idle_task imminently.  \n\n\nParameters\n#\n\n\n\n\nMicroBitComponent  *\n component - The component to add to the array.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success or MICROBIT_NO_RESOURCES if the fiber components array is full.\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n // heap allocated - otherwise it will be paged out! \n MicroBitAccelerometer* accelerometer = new MicroBitAccelerometer(i2c); \n\n fiber_add_idle_component(accelerometer); \n\n\n\n\n\n\nNote\n\n\nThis interface is now deprecated, and will be removed in the next major release. Please use  fiber_add_idle_component() . \n\n\n\n\nremoveIdleComponent\n#\n\n\n\n\nint\n \nremoveIdleComponent\n( \nMicroBitComponent  *\n component)\n#\n\n\nDescription\n#\n\n\nRemove a component from the array of idle thread components  \n\n\nParameters\n#\n\n\n\n\nMicroBitComponent  *\n component - The component to remove from the idle component array.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previously added.\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n // heap allocated - otherwise it will be paged out! \n MicroBitAccelerometer* accelerometer = new MicroBitAccelerometer(i2c); \n\n uBit.addIdleComponent(accelerometer); \n\n uBit.removeIdleComponent(accelerometer); \n\n\n\n\n\n\nNote\n\n\nThis interface is now deprecated, and will be removed in the next major release. Please use  fiber_remove_idle_component() .",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/#microbit",
            "text": "",
            "title": "MicroBit"
        },
        {
            "location": "/lancaster-mbed/ubit/#overview",
            "text": "Although the runtime is built from lots of small components, we also provide an easy to use pre-packaged collection of the commonly used components\nall in one place. This makes it much easier to start programming your micro:bit in C.  This grouping is provided by a C++ class called  MicroBit .  The  MicroBit  class has a number of\nmember variables, that operate as device drivers to control the most commonly used features of the micro:bit.  There is an instance of the  MicroBit  class created as a global variable in all the sample programs, called  uBit :   uBit { \n   \u2003\u2003 .i2c , \n   \u2003\u2003 .storage , \n   \u2003\u2003 .serial , \n   \u2003\u2003 .MessageBus , \n   \u2003\u2003 .buttonA , \n   \u2003\u2003 .buttonB , \n   \u2003\u2003 .buttonAB , \n   \u2003\u2003 .display , \n   \u2003\u2003 .accelerometer , \n   \u2003\u2003 .compass , \n   \u2003\u2003 .thermometer , \n   \u2003\u2003 .io , \n   \u2003\u2003 .radio , \n   }   You can use dot operator \u2018.\u2019 to any of these resources inside uBit to access any of the functions they provide. There is a complete list of the\nfunctions available under the  uBit  menu item in the navigation bar at the top of the page.  For example, if we needed to scroll some text across the display, we simply would write the following:  uBit.display.scroll(\"HELLO!\");  Similarly, if we wanted to send some text over serial, we could write the following\ncode:  for(int i = 3; i > 0; i--)\n{\n    uBit.serial.printf(\"%d...\", i);\n    uBit.sleep(1000);\n}\n\n// or alternatively...\nuBit.serial.send(\"Code!\");  The runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.  To place the current fiber into a power efficient  sleep  write the following:  // where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/#message-bus-id",
            "text": "None",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/#message-bus-events",
            "text": "None",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/#microbit_1",
            "text": "",
            "title": "MicroBit()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description",
            "text": "Constructor.    Create a representation of a  MicroBit  device, which includes member variables that represent various device drivers used to control aspects of the micro:bit.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#init",
            "text": "",
            "title": "init"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-init",
            "text": "",
            "title": "void init()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_1",
            "text": "Post constructor initialisation method.    This call will initialised the scheduler, memory allocator and Bluetooth stack.    This is required as the Bluetooth stack can\u2019t be brought up in a static context i.e. in a constructor.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#example",
            "text": "uBit.init();    Note  This method must be called before user code utilises any functionality contained by uBit.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#reset",
            "text": "",
            "title": "reset"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-reset",
            "text": "",
            "title": "void reset()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_2",
            "text": "Will reset the micro:bit when called.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_1",
            "text": "uBit.reset();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#sleep",
            "text": "",
            "title": "sleep"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-sleep-uint32_t-milliseconds",
            "text": "",
            "title": "void sleep( uint32_t milliseconds)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_3",
            "text": "Delay execution for the given amount of time.    If the scheduler is running, this will deschedule the current fiber and perform a power efficient, concurrent sleep operation.    If the scheduler is disabled or we\u2019re running in an interrupt context, this will revert to a busy wait.    Alternatively: wait, wait_ms, wait_us can be used which will perform a blocking sleep operation.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters",
            "text": "uint32_t  milliseconds - the amount of time, in ms, to wait for. This number cannot be negative.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_2",
            "text": "uBit.sleep(20); //sleep for 20ms    Note  This operation is currently limited by the rate of the system timer, therefore the granularity of the sleep operation is limited to 6 ms unless the rate of the system timer is modified.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#seedrandom",
            "text": "",
            "title": "seedRandom"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-seedrandom",
            "text": "",
            "title": "void seedRandom()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_4",
            "text": "Seed the pseudo random number generator using the hardware random number generator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_3",
            "text": "uBit.seedRandom();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-seedrandom-uint32_t-seed",
            "text": "",
            "title": "void seedRandom( uint32_t seed)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_5",
            "text": "Seed the pseudo random number generator using the given value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_1",
            "text": "uint32_t  seed - The 32-bit value to seed the generator with.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_4",
            "text": "uBit.seedRandom(0xBB5EED);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#random",
            "text": "",
            "title": "random"
        },
        {
            "location": "/lancaster-mbed/ubit/#int-random-int-max",
            "text": "",
            "title": "int random( int max)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_6",
            "text": "Generate a random number in the given range. We use a simple Galois LFSR random number generator here, as a Galois LFSR is sufficient for our applications, and much more lightweight than the hardware random number generator built int the processor, which takes a long time and uses a lot of energy.    KIDS: You shouldn\u2019t use this is the real world to generate cryptographic keys though\u2026 have a think why not. :-)",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_2",
            "text": "int  max - the upper range to generate a number for. This number cannot be negative.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_1",
            "text": "A random, natural number between 0 and the max-1. Or MICROBIT_INVALID_VALUE if max is <= 0.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_5",
            "text": "uBit.random(200); //a number between 0 and 199",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#systemtime",
            "text": "",
            "title": "systemTime"
        },
        {
            "location": "/lancaster-mbed/ubit/#unsigned-long-systemtime",
            "text": "",
            "title": "unsigned long systemTime()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_7",
            "text": "Determine the time since this  MicroBit  was last reset.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_2",
            "text": "The time since the last reset, in milliseconds.   Note  This will value overflow after 1.6 months.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#systemversion",
            "text": "",
            "title": "systemVersion"
        },
        {
            "location": "/lancaster-mbed/ubit/#const-char-42-systemversion",
            "text": "",
            "title": "const char * systemVersion()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_8",
            "text": "Determine the version of the micro:bit runtime currently in use.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_3",
            "text": "A textual description of the version of the micro:bit runtime that is currently running on this device.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#panic",
            "text": "",
            "title": "panic"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-panic",
            "text": "",
            "title": "void panic()"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_9",
            "text": "Triggers a microbit panic where an loop will display a panic face and the status code, if provided.    This loop will continue for panic_timeout iterations, defaults to 0 (infinite).    panic_timeout can be configured via a call to microbit_panic_timeout.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_6",
            "text": "microbit_panic_timeout(4); \n\n // will display loop for 4 iterations. \n uBit.panic(10);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#void-panic-int-statuscode",
            "text": "",
            "title": "void panic( int statusCode)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_10",
            "text": "Triggers a microbit panic where an loop will display a panic face and the status code, if provided.    This loop will continue for panic_timeout iterations, defaults to 0 (infinite).    panic_timeout can be configured via a call to microbit_panic_timeout.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_3",
            "text": "int  statusCode - the status code of the associated error.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_7",
            "text": "microbit_panic_timeout(4); \n\n // will display loop for 4 iterations. \n uBit.panic(10);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#addsystemcomponent",
            "text": "",
            "title": "addSystemComponent"
        },
        {
            "location": "/lancaster-mbed/ubit/#int-addsystemcomponent-microbitcomponent-42-component",
            "text": "",
            "title": "int addSystemComponent( MicroBitComponent  * component)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_11",
            "text": "Add a component to the array of system components. This component will then receive periodic callbacks, once every tick period in interrupt context.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_4",
            "text": "MicroBitComponent  *  component - The component to add.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_4",
            "text": "MICROBIT_OK on success or MICROBIT_NO_RESOURCES if the component array is full.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_8",
            "text": "// heap allocated - otherwise it will be paged out! \n MicroBitDisplay* display = new MicroBitDisplay(); \n\n uBit.addSystemComponent(display);    Note  This interface is now deprecated, and will be removed in the next major release. Please use  system_timer_add_component() .",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#removesystemcomponent",
            "text": "",
            "title": "removeSystemComponent"
        },
        {
            "location": "/lancaster-mbed/ubit/#int-removesystemcomponent-microbitcomponent-42-component",
            "text": "",
            "title": "int removeSystemComponent( MicroBitComponent  * component)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_12",
            "text": "Remove a component from the array of system components. This component will no longer receive periodic callbacks.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_5",
            "text": "MicroBitComponent  *  component - The component to remove.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_5",
            "text": "MICROBIT_OK on success or MICROBIT_INVALID_PARAMETER is returned if the given component has not been previously added.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_9",
            "text": "// heap allocated - otherwise it will be paged out! \n MicroBitDisplay* display = new MicroBitDisplay(); \n\n uBit.addSystemComponent(display); \n\n uBit.removeSystemComponent(display);    Note  This interface is now deprecated, and will be removed in the next major release. Please use  system_timer_remove_component() .",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#addidlecomponent",
            "text": "",
            "title": "addIdleComponent"
        },
        {
            "location": "/lancaster-mbed/ubit/#int-addidlecomponent-microbitcomponent-42-component",
            "text": "",
            "title": "int addIdleComponent( MicroBitComponent  * component)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_13",
            "text": "Adds a component to the array of idle thread components, which are processed when the run queue is empty.    The system timer will poll isIdleCallbackNeeded on each component to determine if the scheduler should schedule the idle_task imminently.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_6",
            "text": "MicroBitComponent  *  component - The component to add to the array.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_6",
            "text": "MICROBIT_OK on success or MICROBIT_NO_RESOURCES if the fiber components array is full.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_10",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n // heap allocated - otherwise it will be paged out! \n MicroBitAccelerometer* accelerometer = new MicroBitAccelerometer(i2c); \n\n fiber_add_idle_component(accelerometer);    Note  This interface is now deprecated, and will be removed in the next major release. Please use  fiber_add_idle_component() .",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/#removeidlecomponent",
            "text": "",
            "title": "removeIdleComponent"
        },
        {
            "location": "/lancaster-mbed/ubit/#int-removeidlecomponent-microbitcomponent-42-component",
            "text": "",
            "title": "int removeIdleComponent( MicroBitComponent  * component)"
        },
        {
            "location": "/lancaster-mbed/ubit/#description_14",
            "text": "Remove a component from the array of idle thread components",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/#parameters_7",
            "text": "MicroBitComponent  *  component - The component to remove from the idle component array.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/#returns_7",
            "text": "MICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previously added.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/#example_11",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n // heap allocated - otherwise it will be paged out! \n MicroBitAccelerometer* accelerometer = new MicroBitAccelerometer(i2c); \n\n uBit.addIdleComponent(accelerometer); \n\n uBit.removeIdleComponent(accelerometer);    Note  This interface is now deprecated, and will be removed in the next major release. Please use  fiber_remove_idle_component() .",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/",
            "text": "uBit.i2c\n#\n\n\nOverview\n#\n\n\ni2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.\n\n\nOnboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the \naccelerometer\n and the \ncompass\n.\n\n\nAs well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.\n\n\nMessage Bus ID\n#\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\nNone.\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitI2C( \nPinName\n sda,  \nPinName\n scl)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate an instance of  MicroBitI2C  for I2C communication.  \n\n\nParameters\n#\n\n\n\n\nPinName\n sda - the Pin to be used for SDA\n\n\nPinName\n scl - the Pin to be used for SCL\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n\n\n\n\n\nNote\n\n\nThis class presents a wrapped mbed call to capture failed I2C operations caused by a known silicon bug in the nrf51822. Attempts to automatically reset and restart the I2C hardware if this case is detected. \n\n\n\n\nread\n#\n\n\n\n\nint\n \nread\n( \nint\n address,  \nchar *\n data,  \nint\n length)\n#\n\n\nDescription\n#\n\n\nPerforms a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.  \n\n\nParameters\n#\n\n\n\n\nint\n address - 8-bit I2C slave address [ addr | 1 ]\n\n\nchar *\n data - A pointer to a byte buffer used for storing retrieved data.\n\n\nint\n length - Number of bytes to read.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected. \n\n\n\nint\n \nread\n( \nint\n address,  \nchar *\n data,  \nint\n length,  \nbool\n repeated)\n#\n\n\nDescription\n#\n\n\nPerforms a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.  \n\n\nParameters\n#\n\n\n\n\nint\n address - 8-bit I2C slave address [ addr | 1 ]\n\n\nchar *\n data - A pointer to a byte buffer used for storing retrieved data.\n\n\nint\n length - Number of bytes to read.\n\n\nbool\n repeated - if true, stop is not sent at the end. Defaults to false.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected. \n\n\nwrite\n#\n\n\n\n\nint\n \nwrite\n( \nint\n address,  \nconst char *\n data,  \nint\n length)\n#\n\n\nDescription\n#\n\n\nPerforms a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.  \n\n\nParameters\n#\n\n\n\n\nint\n address - 8-bit I2C slave address [ addr | 0 ]\n\n\nconst char *\n data - A pointer to a byte buffer containing the data to write.\n\n\nint\n length - Number of bytes to write\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected. \n\n\n\nint\n \nwrite\n( \nint\n address,  \nconst char *\n data,  \nint\n length,  \nbool\n repeated)\n#\n\n\nDescription\n#\n\n\nPerforms a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.  \n\n\nParameters\n#\n\n\n\n\nint\n address - 8-bit I2C slave address [ addr | 0 ]\n\n\nconst char *\n data - A pointer to a byte buffer containing the data to write.\n\n\nint\n length - Number of bytes to write\n\n\nbool\n repeated - if true, stop is not sent at the end. Defaults to false.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.",
            "title": "i2c"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#ubiti2c",
            "text": "",
            "title": "uBit.i2c"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#overview",
            "text": "i2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.  Onboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the  accelerometer  and the  compass .  As well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#message-bus-id",
            "text": "None.",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#message-bus-events",
            "text": "None.",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#microbiti2c-pinname-sda-pinname-scl",
            "text": "",
            "title": "MicroBitI2C( PinName sda,  PinName scl)"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#description",
            "text": "Constructor.    Create an instance of  MicroBitI2C  for I2C communication.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#parameters",
            "text": "PinName  sda - the Pin to be used for SDA  PinName  scl - the Pin to be used for SCL",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#example",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0);    Note  This class presents a wrapped mbed call to capture failed I2C operations caused by a known silicon bug in the nrf51822. Attempts to automatically reset and restart the I2C hardware if this case is detected.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#read",
            "text": "",
            "title": "read"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#int-read-int-address-char-42-data-int-length",
            "text": "",
            "title": "int read( int address,  char * data,  int length)"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#description_1",
            "text": "Performs a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#parameters_1",
            "text": "int  address - 8-bit I2C slave address [ addr | 1 ]  char *  data - A pointer to a byte buffer used for storing retrieved data.  int  length - Number of bytes to read.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#returns",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#int-read-int-address-char-42-data-int-length-bool-repeated",
            "text": "",
            "title": "int read( int address,  char * data,  int length,  bool repeated)"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#description_2",
            "text": "Performs a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#parameters_2",
            "text": "int  address - 8-bit I2C slave address [ addr | 1 ]  char *  data - A pointer to a byte buffer used for storing retrieved data.  int  length - Number of bytes to read.  bool  repeated - if true, stop is not sent at the end. Defaults to false.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#returns_1",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#write",
            "text": "",
            "title": "write"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#int-write-int-address-const-char-42-data-int-length",
            "text": "",
            "title": "int write( int address,  const char * data,  int length)"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#description_3",
            "text": "Performs a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#parameters_3",
            "text": "int  address - 8-bit I2C slave address [ addr | 0 ]  const char *  data - A pointer to a byte buffer containing the data to write.  int  length - Number of bytes to write",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#returns_2",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#int-write-int-address-const-char-42-data-int-length-bool-repeated",
            "text": "",
            "title": "int write( int address,  const char * data,  int length,  bool repeated)"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#description_4",
            "text": "Performs a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#parameters_4",
            "text": "int  address - 8-bit I2C slave address [ addr | 0 ]  const char *  data - A pointer to a byte buffer containing the data to write.  int  length - Number of bytes to write  bool  repeated - if true, stop is not sent at the end. Defaults to false.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/i2c/#returns_3",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/",
            "text": "uBit.storage\n#\n\n\nOverview\n#\n\n\nMicroBitStorage\n provides a simple way to store data on the micro:bit that persists\nthrough power cycles. It currently takes the form of a key value store which contains\na number of key value pairs.\n\n\nIf a user wanted to determine if a micro:bit has just been flashed over USB they\ncould simply write the following:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n\n    KeyValuePair* firstTime = uBit.storage.get(\"boot\");\n\n    int stored;\n\n    if(firstTime == NULL)\n    {\n        //this is the first boot after a flash. Store a value!\n        stored = 1;\n        uBit.storage.put(\"boot\", (uint8_t *)&stored, sizeof(int));\n        uBit.display.scroll(\"Stored!\");\n    }\n    else\n    {\n        //this is not the first boot, scroll our stored value.\n        memcpy(&stored, firstTime->value, sizeof(int));\n        delete firstTime;\n        uBit.display.scroll(stored);\n    }\n}\n\n\n\n\nWhat is flash memory?\n#\n\n\nThe micro:bit has 256 kB flash memory and 16 kB random access memory (RAM). Flash memory\nis \nnon-volatile\n, which essentially means that data is not forgotten when the device\nis powered off, this is the technology that many USB sticks use.\n\n\nThe alternative, Random Access Memory (also known as \nvolatile\n memory), cannot be persisted through power cycling the device as its\noperation relies upon maintaining a constant supply of power.\n\n\nTherefore, \nMicroBitStorage\n utilises the \nnon-volatile\n nature of flash memory, to\nstore its data. This class is utilised by the \ncompass\n, \naccelerometer\n\nand \nbleManager\n to improve the user experience by persisting calibration\nand bonding data.\n\n\nOperations\n#\n\n\nYou can \nput()\n, \nget()\n and \nremove()\n key value pairs from the store.\n\n\nKey Value pairs have a fixed length key of \n16 bytes\n, and a fixed length value of\n\n32 bytes\n. This class only populates a single block (\n1024 bytes\n) in its current state,\nwhich means that \n21\n Key Value pairs can be stored.\n\n\nMessage Bus ID\n#\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\nNone.\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitStorage()\n#\n\n\nDescription\n#\n\n\nDefault constructor.  \n\n\nCreates an instance of  MicroBitStorage  which acts like a  KeyValueStore  that allows the retrieval, addition and deletion of KeyValuePairs.           \n\n\nwriteBytes\n#\n\n\n\n\nint\n \nwriteBytes\n( \nuint8_t *\n buffer,  \nuint32_t\n address,  \nint\n length)\n#\n\n\nDescription\n#\n\n\nWrites the given number of bytes to the address specified.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - the data to write.\n\n\nuint32_t\n address - the location in memory to write to.\n\n\nint\n length - the number of bytes to write.\n\n\n\n\n\n\nNote\n\n\ncurrently not implemented. \n\n\n\n\nflashPageErase\n#\n\n\n\n\nvoid\n \nflashPageErase\n( \nuint32_t *\n page_address)\n#\n\n\nDescription\n#\n\n\nMethod for erasing a page in flash.  \n\n\npage_address \n\n\nAddress of the first word in the page to be erased.   \n\n\nParameters\n#\n\n\n\n\nuint32_t *\n page_address - Address of the first word in the page to be erased. \n\n\n\n\nflashWordWrite\n#\n\n\n\n\nvoid\n \nflashWordWrite\n( \nuint32_t *\n address,  \nuint32_t\n value)\n#\n\n\nDescription\n#\n\n\nMethod for writing a word of data in flash with a value.  \n\n\naddress \n\n\nAddress of the word to change.  \n\n\nvalue \n\n\nValue to be written to flash.   \n\n\nParameters\n#\n\n\n\n\nuint32_t *\n address - Address of the word to change.\n\n\nuint32_t\n value - Value to be written to flash. \n\n\n\n\nput\n#\n\n\n\n\nint\n \nput\n( \nconst char *\n key,  \nuint8_t *\n data,  \nint\n dataSize)\n#\n\n\nDescription\n#\n\n\nPlaces a given key, and it\u2019s corresponding value into flash at the earliest available point.  \n\n\nParameters\n#\n\n\n\n\nconst char *\n key - the unique name that should be used as an identifier for the given data. The key is presumed to be null terminated.\n\n\nuint8_t *\n data - a pointer to the beginning of the data to be persisted.\n\n\nint\n dataSize - the size of the data to be persisted\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if the key or size is too large, MICROBIT_NO_RESOURCES if the storage page is full \n\n\n\nint\n \nput\n( \nManagedString\n key,  \nuint8_t *\n data,  \nint\n dataSize)\n#\n\n\nDescription\n#\n\n\nPlaces a given key, and it\u2019s corresponding value into flash at the earliest available point.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n key - the unique name that should be used as an identifier for the given data.\n\n\nuint8_t *\n data - a pointer to the beginning of the data to be persisted.\n\n\nint\n dataSize - the size of the data to be persisted\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if the key or size is too large, MICROBIT_NO_RESOURCES if the storage page is full \n\n\nget\n#\n\n\n\n\nKeyValuePair\n \nget\n( \nconst char *\n key)\n#\n\n\nDescription\n#\n\n\nRetreives a  KeyValuePair  identified by a given key.  \n\n\nParameters\n#\n\n\n\n\nconst char *\n key - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n#\n\n\na pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.\n\n\n\n\nNote\n\n\nit is up to the user to free memory after use. \n\n\n\n\n\n\nKeyValuePair\n \nget\n( \nManagedString\n key)\n#\n\n\nDescription\n#\n\n\nRetreives a  KeyValuePair  identified by a given key.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n key - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n#\n\n\na pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.\n\n\n\n\nNote\n\n\nit is up to the user to free memory after use. \n\n\n\n\nremove\n#\n\n\n\n\nint\n \nremove\n( \nconst char *\n key)\n#\n\n\nDescription\n#\n\n\nRemoves a  KeyValuePair  identified by a given key.  \n\n\nParameters\n#\n\n\n\n\nconst char *\n key - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash. \n\n\n\nint\n \nremove\n( \nManagedString\n key)\n#\n\n\nDescription\n#\n\n\nRemoves a  KeyValuePair  identified by a given key.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n key - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash. \n\n\nsize\n#\n\n\n\n\nint\n \nsize\n()\n#\n\n\nDescription\n#\n\n\nThe size of the flash based  KeyValueStore .  \n\n\nReturns\n#\n\n\nthe number of entries in the key value store",
            "title": "storage"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#ubitstorage",
            "text": "",
            "title": "uBit.storage"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#overview",
            "text": "MicroBitStorage  provides a simple way to store data on the micro:bit that persists\nthrough power cycles. It currently takes the form of a key value store which contains\na number of key value pairs.  If a user wanted to determine if a micro:bit has just been flashed over USB they\ncould simply write the following:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n\n    KeyValuePair* firstTime = uBit.storage.get(\"boot\");\n\n    int stored;\n\n    if(firstTime == NULL)\n    {\n        //this is the first boot after a flash. Store a value!\n        stored = 1;\n        uBit.storage.put(\"boot\", (uint8_t *)&stored, sizeof(int));\n        uBit.display.scroll(\"Stored!\");\n    }\n    else\n    {\n        //this is not the first boot, scroll our stored value.\n        memcpy(&stored, firstTime->value, sizeof(int));\n        delete firstTime;\n        uBit.display.scroll(stored);\n    }\n}",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#what-is-flash-memory",
            "text": "The micro:bit has 256 kB flash memory and 16 kB random access memory (RAM). Flash memory\nis  non-volatile , which essentially means that data is not forgotten when the device\nis powered off, this is the technology that many USB sticks use.  The alternative, Random Access Memory (also known as  volatile  memory), cannot be persisted through power cycling the device as its\noperation relies upon maintaining a constant supply of power.  Therefore,  MicroBitStorage  utilises the  non-volatile  nature of flash memory, to\nstore its data. This class is utilised by the  compass ,  accelerometer \nand  bleManager  to improve the user experience by persisting calibration\nand bonding data.",
            "title": "What is flash memory?"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#operations",
            "text": "You can  put() ,  get()  and  remove()  key value pairs from the store.  Key Value pairs have a fixed length key of  16 bytes , and a fixed length value of 32 bytes . This class only populates a single block ( 1024 bytes ) in its current state,\nwhich means that  21  Key Value pairs can be stored.",
            "title": "Operations"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#message-bus-id",
            "text": "None.",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#message-bus-events",
            "text": "None.",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#microbitstorage",
            "text": "",
            "title": "MicroBitStorage()"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description",
            "text": "Default constructor.    Creates an instance of  MicroBitStorage  which acts like a  KeyValueStore  that allows the retrieval, addition and deletion of KeyValuePairs.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#writebytes",
            "text": "",
            "title": "writeBytes"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-writebytes-uint8_t-42-buffer-uint32_t-address-int-length",
            "text": "",
            "title": "int writeBytes( uint8_t * buffer,  uint32_t address,  int length)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_1",
            "text": "Writes the given number of bytes to the address specified.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters",
            "text": "uint8_t *  buffer - the data to write.  uint32_t  address - the location in memory to write to.  int  length - the number of bytes to write.    Note  currently not implemented.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#flashpageerase",
            "text": "",
            "title": "flashPageErase"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#void-flashpageerase-uint32_t-42-page_address",
            "text": "",
            "title": "void flashPageErase( uint32_t * page_address)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_2",
            "text": "Method for erasing a page in flash.    page_address   Address of the first word in the page to be erased.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_1",
            "text": "uint32_t *  page_address - Address of the first word in the page to be erased.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#flashwordwrite",
            "text": "",
            "title": "flashWordWrite"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#void-flashwordwrite-uint32_t-42-address-uint32_t-value",
            "text": "",
            "title": "void flashWordWrite( uint32_t * address,  uint32_t value)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_3",
            "text": "Method for writing a word of data in flash with a value.    address   Address of the word to change.    value   Value to be written to flash.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_2",
            "text": "uint32_t *  address - Address of the word to change.  uint32_t  value - Value to be written to flash.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#put",
            "text": "",
            "title": "put"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-put-const-char-42-key-uint8_t-42-data-int-datasize",
            "text": "",
            "title": "int put( const char * key,  uint8_t * data,  int dataSize)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_4",
            "text": "Places a given key, and it\u2019s corresponding value into flash at the earliest available point.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_3",
            "text": "const char *  key - the unique name that should be used as an identifier for the given data. The key is presumed to be null terminated.  uint8_t *  data - a pointer to the beginning of the data to be persisted.  int  dataSize - the size of the data to be persisted",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if the key or size is too large, MICROBIT_NO_RESOURCES if the storage page is full",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-put-managedstring-key-uint8_t-42-data-int-datasize",
            "text": "",
            "title": "int put( ManagedString key,  uint8_t * data,  int dataSize)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_5",
            "text": "Places a given key, and it\u2019s corresponding value into flash at the earliest available point.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_4",
            "text": "ManagedString  key - the unique name that should be used as an identifier for the given data.  uint8_t *  data - a pointer to the beginning of the data to be persisted.  int  dataSize - the size of the data to be persisted",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_1",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if the key or size is too large, MICROBIT_NO_RESOURCES if the storage page is full",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#get",
            "text": "",
            "title": "get"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#keyvaluepair-get-const-char-42-key",
            "text": "",
            "title": "KeyValuePair get( const char * key)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_6",
            "text": "Retreives a  KeyValuePair  identified by a given key.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_5",
            "text": "const char *  key - the unique name used to identify a  KeyValuePair  in flash.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_2",
            "text": "a pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.   Note  it is up to the user to free memory after use.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#keyvaluepair-get-managedstring-key",
            "text": "",
            "title": "KeyValuePair get( ManagedString key)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_7",
            "text": "Retreives a  KeyValuePair  identified by a given key.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_6",
            "text": "ManagedString  key - the unique name used to identify a  KeyValuePair  in flash.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_3",
            "text": "a pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.   Note  it is up to the user to free memory after use.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#remove",
            "text": "",
            "title": "remove"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-remove-const-char-42-key",
            "text": "",
            "title": "int remove( const char * key)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_8",
            "text": "Removes a  KeyValuePair  identified by a given key.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_7",
            "text": "const char *  key - the unique name used to identify a  KeyValuePair  in flash.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_4",
            "text": "MICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-remove-managedstring-key",
            "text": "",
            "title": "int remove( ManagedString key)"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_9",
            "text": "Removes a  KeyValuePair  identified by a given key.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#parameters_8",
            "text": "ManagedString  key - the unique name used to identify a  KeyValuePair  in flash.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_5",
            "text": "MICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#size",
            "text": "",
            "title": "size"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#int-size",
            "text": "",
            "title": "int size()"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#description_10",
            "text": "The size of the flash based  KeyValueStore .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/storage/#returns_6",
            "text": "the number of entries in the key value store",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/",
            "text": "uBit.serial\n#\n\n\nOverview\n#\n\n\nSerial communication provides a simple way to exchange a series of bytes between one computer and another.  The runtime\u2019s implementation of serial is general purpose and supports a number of different modes. It has a circular buffer for both the reception and transmission of data, and provides notifications to the user through the MessageBus.\n\n\nBy default, the baud rate for MicroBitSerial is \n115200\n and has very little overhead up until\nit is used to \nsend()\n or \nread()\n, at which point buffers are allocated in order\nto accommodate incoming or outgoing data.\n\n\nMicroBitSerial inherits from mbeds\u2019 \nRawSerial\n\nclass, which exposes a lightweight version of \nprintf()\n and incurs minimal overhead\nas MicroBitSerial\u2019s buffers will not be allocated.\n\n\nThe MicroBitSerial class supports multithreaded operation, ensuring that only\none fiber can access the Serial port at a time.\n\n\nThe USB interface on the micro:bit is the \nKL26Z\n.\n\n\n\n\nNote\n\n\nOn Mac OSX and Linux Serial communication works out of the box, however on Windows an additional\n\ndriver\n is required.\n\n\n\n\n\n\nWarning\n\n\nThe baud rate is shared across all instances of MicroBitSerial (this is enforced in hardware).\n\n\n\n\nSerial modes\n#\n\n\nThere are three modes of operation for all \nsend()\n or \nread()\n calls:\n\n\n\n\nASYNC\n - Returns immediately after fetching any available data for a given call\n\n\nSYNC_SPINWAIT\n - Synchronously access the serial port until the selected operation is complete.\n                    This mode will lock up the processor, and isn\u2019t recommended if multiple fibers are in use.\n\n\nSYNC_SLEEP\n - Blocks the current fiber until the selected operation is complete. This mode cooperates with the\n                 Fiber scheduler, and should be used in a multi-fiber program.\n\n\n\n\nSerial debug\n#\n\n\nIn MicroBitConfig.h, the configuration option \nMICROBIT_DEBUG\n can be used to activate serial debugging\nfor many of the components in the runtime.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_SERIAL\n\n\n32\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_DELIM_MATCH\n\n\n1\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_HEAD_MATCH\n\n\n2\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_RX_FULL\n\n\n3\n\n\n\n\n\n\n\n\nNotify Events\n#\n\n\nThese events use the notification channel \nMICROBIT_ID_NOTIFY\n, which provides\ngeneral purpose synchronisation.\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_TX_EMPTY\n\n\n2\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx)\n#\n\n\nDescription\n#\n\n\nConstructor. Create an instance of  MicroBitSerial   \n\n\nParameters\n#\n\n\n\n\nPinName\n tx - the Pin to be used for transmission\n\n\nPinName\n rx - the Pin to be used for receiving data\n\n\n\n\nExample\n#\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx,  \nuint8_t\n rxBufferSize)\n#\n\n\nDescription\n#\n\n\nConstructor. Create an instance of  MicroBitSerial   \n\n\nParameters\n#\n\n\n\n\nPinName\n tx - the Pin to be used for transmission\n\n\nPinName\n rx - the Pin to be used for receiving data\n\n\nuint8_t\n rxBufferSize - the size of the buffer to be used for receiving bytes\n\n\n\n\nExample\n#\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx,  \nuint8_t\n rxBufferSize,  \nuint8_t\n txBufferSize)\n#\n\n\nDescription\n#\n\n\nConstructor. Create an instance of  MicroBitSerial   \n\n\nParameters\n#\n\n\n\n\nPinName\n tx - the Pin to be used for transmission\n\n\nPinName\n rx - the Pin to be used for receiving data\n\n\nuint8_t\n rxBufferSize - the size of the buffer to be used for receiving bytes\n\n\nuint8_t\n txBufferSize - the size of the buffer to be used for transmitting bytes\n\n\n\n\nExample\n#\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\nsendChar\n#\n\n\n\n\nint\n \nsendChar\n( \nchar\n c)\n#\n\n\nDescription\n#\n\n\nSends a single character over the serial line.  \n\n\nc \n\n\nthe character to send  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.\n\n\nSYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - the character to send\n\n\n\n\nReturns\n#\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\n\nint\n \nsendChar\n( \nchar\n c,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nSends a single character over the serial line.  \n\n\nc \n\n\nthe character to send  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.\n\n\nSYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - the character to send\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.\n\n\nSYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n#\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\nsend\n#\n\n\n\n\nint\n \nsend\n( \nManagedString\n s)\n#\n\n\nDescription\n#\n\n\nSends a  ManagedString  over the serial line.  \n\n\ns \n\n\nthe string to send  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - the string to send\n\n\n\n\nReturns\n#\n\n\nthe number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0. \n\n\n\nint\n \nsend\n( \nManagedString\n s,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nSends a  ManagedString  over the serial line.  \n\n\ns \n\n\nthe string to send  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - the string to send\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n#\n\n\nthe number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0. \n\n\n\nint\n \nsend\n( \nuint8_t *\n buffer,  \nint\n bufferLen)\n#\n\n\nDescription\n#\n\n\nSends a buffer of known length over the serial line.  \n\n\nbuffer \n\n\na pointer to the first character of the buffer  \n\n\nlen \n\n\nthe number of bytes that are safely available to read.  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - a pointer to the first character of the buffer\n\n\nint\n bufferLen - a pointer to the first character of the buffer\n\n\n\n\nReturns\n#\n\n\nthe number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0. \n\n\n\nint\n \nsend\n( \nuint8_t *\n buffer,  \nint\n bufferLen,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nSends a buffer of known length over the serial line.  \n\n\nbuffer \n\n\na pointer to the first character of the buffer  \n\n\nlen \n\n\nthe number of bytes that are safely available to read.  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - a pointer to the first character of the buffer\n\n\nint\n bufferLen - a pointer to the first character of the buffer\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n#\n\n\nthe number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0. \n\n\nread\n#\n\n\n\n\nint\n \nread\n()\n#\n\n\nDescription\n#\n\n\nReads a single character from the rxBuff  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.\n\n\nSYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.\n\n\nSYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nReturns\n#\n\n\na character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC. \n\n\n\nint\n \nread\n( \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nReads a single character from the rxBuff  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.\n\n\nSYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.\n\n\nSYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.\n\n\n\n\nSYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.\n\n\nSYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.\n\n\nReturns\n#\n\n\na character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC. \n\n\n\nManagedString\n \nread\n( \nint\n size)\n#\n\n\nDescription\n#\n\n\nReads multiple characters from the rxBuff and returns them as a  ManagedString   \n\n\nsize \n\n\nthe number of characters to read.  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nint\n size - the number of characters to read.\n\n\n\n\nReturns\n#\n\n\nA  ManagedString , or an empty  ManagedString  if an error was encountered during the read. \n\n\n\nManagedString\n \nread\n( \nint\n size,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nReads multiple characters from the rxBuff and returns them as a  ManagedString   \n\n\nsize \n\n\nthe number of characters to read.  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nint\n size - the number of characters to read.\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.\n\n\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nReturns\n#\n\n\nA  ManagedString , or an empty  ManagedString  if an error was encountered during the read. \n\n\n\nint\n \nread\n( \nuint8_t *\n buffer,  \nint\n bufferLen)\n#\n\n\nDescription\n#\n\n\nReads multiple characters from the rxBuff and fills a user buffer.  \n\n\nbuffer \n\n\na pointer to a user allocated buffer.  \n\n\nbufferLen \n\n\nthe amount of data that can be safely stored  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - a pointer to a user allocated buffer.\n\n\nint\n bufferLen - the amount of data that can be safely stored\n\n\n\n\nReturns\n#\n\n\nthe number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving. \n\n\n\nint\n \nread\n( \nuint8_t *\n buffer,  \nint\n bufferLen,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nReads multiple characters from the rxBuff and fills a user buffer.  \n\n\nbuffer \n\n\na pointer to a user allocated buffer.  \n\n\nbufferLen \n\n\nthe amount of data that can be safely stored  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - a pointer to a user allocated buffer.\n\n\nint\n bufferLen - the amount of data that can be safely stored\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.\n\n\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nReturns\n#\n\n\nthe number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving. \n\n\nreadUntil\n#\n\n\n\n\nManagedString\n \nreadUntil\n( \nManagedString\n delimeters)\n#\n\n\nDescription\n#\n\n\nReads until one of the delimeters matches a character in the rxBuff  \n\n\ndelimeters \n\n\na  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.\n\n\nSYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.\n\n\nSYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n delimeters - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)\n\n\n\n\nReturns\n#\n\n\nA  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\n\n\nManagedString\n \nreadUntil\n( \nManagedString\n delimeters,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nReads until one of the delimeters matches a character in the rxBuff  \n\n\ndelimeters \n\n\na  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)  \n\n\nmode \n\n\nthe selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.\n\n\nSYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.\n\n\nSYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.\n\n\nDefaults to SYNC_SLEEP.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n delimeters - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.\n\n\n\n\nSYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.\n\n\nSYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.\n\n\nReturns\n#\n\n\nA  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\nbaud\n#\n\n\n\n\nvoid\n \nbaud\n( \nint\n baudrate)\n#\n\n\nDescription\n#\n\n\nA wrapper around the inherited method \u201cbaud\u201d so we can trap the baud rate as it changes and restore it if  redirect()  is called.  \n\n\nParameters\n#\n\n\n\n\nint\n baudrate - the new baudrate. See: \n https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c  for permitted baud rates. \n\n\n\n\nReturns\n#\n\n\nMICROBIT_INVALID_PARAMETER if baud rate is less than 0, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\nthe underlying implementation chooses the first allowable rate at or above that requested. \n\n\n\n\nredirect\n#\n\n\n\n\nint\n \nredirect\n( \nPinName\n tx,  \nPinName\n rx)\n#\n\n\nDescription\n#\n\n\nA way of dynamically configuring the serial instance to use pins other than USBTX and USBRX.  \n\n\nParameters\n#\n\n\n\n\nPinName\n tx - the new transmission pin.\n\n\nPinName\n rx - the new reception pin.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently transmitting or receiving, otherwise MICROBIT_OK. \n\n\neventAfter\n#\n\n\n\n\nint\n \neventAfter\n( \nint\n len)\n#\n\n\nDescription\n#\n\n\nConfigures an event to be fired after \u201clen\u201d characters.  \n\n\nWill generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_HEAD_MATCH.  \n\n\nParameters\n#\n\n\n\n\nint\n len - the number of characters to wait before triggering the event.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK. \n\n\n\nint\n \neventAfter\n( \nint\n len,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nConfigures an event to be fired after \u201clen\u201d characters.  \n\n\nWill generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_HEAD_MATCH.  \n\n\nParameters\n#\n\n\n\n\nint\n len - the number of characters to wait before triggering the event.\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.\n\n\n\n\nSYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER\n\n\nSYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.\n\n\nReturns\n#\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK. \n\n\neventOn\n#\n\n\n\n\nint\n \neventOn\n( \nManagedString\n delimeters)\n#\n\n\nDescription\n#\n\n\nConfigures an event to be fired on a match with one of the delimeters.  \n\n\nWill generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_DELIM_MATCH.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n delimeters - the characters to match received characters against e.g.  ManagedString (\u201c\\n\u201d)\n\n\n\n\nReturns\n#\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\n\n\nint\n \neventOn\n( \nManagedString\n delimeters,  \nMicroBitSerialMode\n mode)\n#\n\n\nDescription\n#\n\n\nConfigures an event to be fired on a match with one of the delimeters.  \n\n\nWill generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_DELIM_MATCH.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n delimeters - the characters to match received characters against e.g.  ManagedString (\u201c\\n\u201d)\n\n\nMicroBitSerialMode\n mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.\n\n\n\n\nSYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER\n\n\nSYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.\n\n\nReturns\n#\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\nisReadable\n#\n\n\n\n\nint\n \nisReadable\n()\n#\n\n\nDescription\n#\n\n\nDetermines whether there is any data waiting in our Rx buffer.  \n\n\nReturns\n#\n\n\n1 if we have space, 0 if we do not.\n\n\n\n\nNote\n\n\nWe do not wrap the super\u2019s readable() method as we don\u2019t want to interfere with communities that use manual calls to serial.readable(). \n\n\n\n\nisWriteable\n#\n\n\n\n\nint\n \nisWriteable\n()\n#\n\n\nDescription\n#\n\n\nDetermines if we have space in our txBuff.  \n\n\nReturns\n#\n\n\n1 if we have space, 0 if we do not.\n\n\n\n\nNote\n\n\nWe do not wrap the super\u2019s writeable() method as we don\u2019t want to interfere with communities that use manual calls to serial.writeable(). \n\n\n\n\nsetRxBufferSize\n#\n\n\n\n\nint\n \nsetRxBufferSize\n( \nuint8_t\n size)\n#\n\n\nDescription\n#\n\n\nReconfigures the size of our rxBuff  \n\n\nParameters\n#\n\n\n\n\nuint8_t\n size - the new size for our rxBuff\n\n\n\n\nReturns\n#\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK. \n\n\nsetTxBufferSize\n#\n\n\n\n\nint\n \nsetTxBufferSize\n( \nuint8_t\n size)\n#\n\n\nDescription\n#\n\n\nReconfigures the size of our txBuff  \n\n\nParameters\n#\n\n\n\n\nuint8_t\n size - the new size for our txBuff\n\n\n\n\nReturns\n#\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK. \n\n\ngetRxBufferSize\n#\n\n\n\n\nint\n \ngetRxBufferSize\n()\n#\n\n\nDescription\n#\n\n\nThe size of our rx buffer in bytes.  \n\n\nReturns\n#\n\n\nthe current size of rxBuff in bytes \n\n\ngetTxBufferSize\n#\n\n\n\n\nint\n \ngetTxBufferSize\n()\n#\n\n\nDescription\n#\n\n\nThe size of our tx buffer in bytes.  \n\n\nReturns\n#\n\n\nthe current size of txBuff in bytes \n\n\nclearRxBuffer\n#\n\n\n\n\nint\n \nclearRxBuffer\n()\n#\n\n\nDescription\n#\n\n\nSets the tail to match the head of our circular buffer for reception, effectively clearing the reception buffer.  \n\n\nReturns\n#\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK. \n\n\nclearTxBuffer\n#\n\n\n\n\nint\n \nclearTxBuffer\n()\n#\n\n\nDescription\n#\n\n\nSets the tail to match the head of our circular buffer for transmission, effectively clearing the transmission buffer.  \n\n\nReturns\n#\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK. \n\n\nrxBufferedSize\n#\n\n\n\n\nint\n \nrxBufferedSize\n()\n#\n\n\nDescription\n#\n\n\nThe number of bytes currently stored in our rx buffer waiting to be digested, by the user.  \n\n\nReturns\n#\n\n\nThe currently buffered number of bytes in our rxBuff. \n\n\ntxBufferedSize\n#\n\n\n\n\nint\n \ntxBufferedSize\n()\n#\n\n\nDescription\n#\n\n\nThe number of bytes currently stored in our tx buffer waiting to be transmitted by the hardware.  \n\n\nReturns\n#\n\n\nThe currently buffered number of bytes in our txBuff. \n\n\nrxInUse\n#\n\n\n\n\nint\n \nrxInUse\n()\n#\n\n\nDescription\n#\n\n\nDetermines if the serial bus is currently in use by another fiber for reception.  \n\n\nReturns\n#\n\n\nThe state of our mutex lock for reception.\n\n\n\n\nNote\n\n\nOnly one fiber can call read at a time \n\n\n\n\ntxInUse\n#\n\n\n\n\nint\n \ntxInUse\n()\n#\n\n\nDescription\n#\n\n\nDetermines if the serial bus is currently in use by another fiber for transmission.  \n\n\nReturns\n#\n\n\nThe state of our mutex lock for transmition.\n\n\n\n\nNote\n\n\nOnly one fiber can call send at a time \n\n\n\n\ndetach\n#\n\n\n\n\nvoid\n \ndetach\n( \nSerial::IrqType\n interuptType)\n#\n\n\nDescription\n#\n\n\nDetaches a previously configured interrupt  \n\n\ninterruptType \n\n\none of Serial::RxIrq or Serial::TxIrq   \n\n\nParameters\n#\n\n\n\n\nSerial::IrqType\n interuptType",
            "title": "serial"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#ubitserial",
            "text": "",
            "title": "uBit.serial"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#overview",
            "text": "Serial communication provides a simple way to exchange a series of bytes between one computer and another.  The runtime\u2019s implementation of serial is general purpose and supports a number of different modes. It has a circular buffer for both the reception and transmission of data, and provides notifications to the user through the MessageBus.  By default, the baud rate for MicroBitSerial is  115200  and has very little overhead up until\nit is used to  send()  or  read() , at which point buffers are allocated in order\nto accommodate incoming or outgoing data.  MicroBitSerial inherits from mbeds\u2019  RawSerial \nclass, which exposes a lightweight version of  printf()  and incurs minimal overhead\nas MicroBitSerial\u2019s buffers will not be allocated.  The MicroBitSerial class supports multithreaded operation, ensuring that only\none fiber can access the Serial port at a time.  The USB interface on the micro:bit is the  KL26Z .   Note  On Mac OSX and Linux Serial communication works out of the box, however on Windows an additional driver  is required.    Warning  The baud rate is shared across all instances of MicroBitSerial (this is enforced in hardware).",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#serial-modes",
            "text": "There are three modes of operation for all  send()  or  read()  calls:   ASYNC  - Returns immediately after fetching any available data for a given call  SYNC_SPINWAIT  - Synchronously access the serial port until the selected operation is complete.\n                    This mode will lock up the processor, and isn\u2019t recommended if multiple fibers are in use.  SYNC_SLEEP  - Blocks the current fiber until the selected operation is complete. This mode cooperates with the\n                 Fiber scheduler, and should be used in a multi-fiber program.",
            "title": "Serial modes"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#serial-debug",
            "text": "In MicroBitConfig.h, the configuration option  MICROBIT_DEBUG  can be used to activate serial debugging\nfor many of the components in the runtime.",
            "title": "Serial debug"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_SERIAL  32",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#message-bus-events",
            "text": "Constant  Value      MICROBIT_SERIAL_EVT_DELIM_MATCH  1    MICROBIT_SERIAL_EVT_HEAD_MATCH  2    MICROBIT_SERIAL_EVT_RX_FULL  3",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#notify-events",
            "text": "These events use the notification channel  MICROBIT_ID_NOTIFY , which provides\ngeneral purpose synchronisation.     Constant  Value      MICROBIT_SERIAL_EVT_TX_EMPTY  2",
            "title": "Notify Events"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#microbitserial-pinname-tx-pinname-rx",
            "text": "",
            "title": "MicroBitSerial( PinName tx,  PinName rx)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description",
            "text": "Constructor. Create an instance of  MicroBitSerial",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters",
            "text": "PinName  tx - the Pin to be used for transmission  PinName  rx - the Pin to be used for receiving data",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#example",
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#microbitserial-pinname-tx-pinname-rx-uint8_t-rxbuffersize",
            "text": "",
            "title": "MicroBitSerial( PinName tx,  PinName rx,  uint8_t rxBufferSize)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_1",
            "text": "Constructor. Create an instance of  MicroBitSerial",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_1",
            "text": "PinName  tx - the Pin to be used for transmission  PinName  rx - the Pin to be used for receiving data  uint8_t  rxBufferSize - the size of the buffer to be used for receiving bytes",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#example_1",
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#microbitserial-pinname-tx-pinname-rx-uint8_t-rxbuffersize-uint8_t-txbuffersize",
            "text": "",
            "title": "MicroBitSerial( PinName tx,  PinName rx,  uint8_t rxBufferSize,  uint8_t txBufferSize)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_2",
            "text": "Constructor. Create an instance of  MicroBitSerial",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_2",
            "text": "PinName  tx - the Pin to be used for transmission  PinName  rx - the Pin to be used for receiving data  uint8_t  rxBufferSize - the size of the buffer to be used for receiving bytes  uint8_t  txBufferSize - the size of the buffer to be used for transmitting bytes",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#example_2",
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#sendchar",
            "text": "",
            "title": "sendChar"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-sendchar-char-c",
            "text": "",
            "title": "int sendChar( char c)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_3",
            "text": "Sends a single character over the serial line.    c   the character to send    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.  SYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.  SYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_3",
            "text": "char  c - the character to send",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns",
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-sendchar-char-c-microbitserialmode-mode",
            "text": "",
            "title": "int sendChar( char c,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_4",
            "text": "Sends a single character over the serial line.    c   the character to send    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.  SYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.  SYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_4",
            "text": "char  c - the character to send  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.   SYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.  SYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_1",
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#send",
            "text": "",
            "title": "send"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-send-managedstring-s",
            "text": "",
            "title": "int send( ManagedString s)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_5",
            "text": "Sends a  ManagedString  over the serial line.    s   the string to send    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.  SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_5",
            "text": "ManagedString  s - the string to send",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_2",
            "text": "the number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-send-managedstring-s-microbitserialmode-mode",
            "text": "",
            "title": "int send( ManagedString s,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_6",
            "text": "Sends a  ManagedString  over the serial line.    s   the string to send    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.  SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_6",
            "text": "ManagedString  s - the string to send  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.   SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_3",
            "text": "the number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-send-uint8_t-42-buffer-int-bufferlen",
            "text": "",
            "title": "int send( uint8_t * buffer,  int bufferLen)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_7",
            "text": "Sends a buffer of known length over the serial line.    buffer   a pointer to the first character of the buffer    len   the number of bytes that are safely available to read.    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.  SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_7",
            "text": "uint8_t *  buffer - a pointer to the first character of the buffer  int  bufferLen - a pointer to the first character of the buffer",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_4",
            "text": "the number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-send-uint8_t-42-buffer-int-bufferlen-microbitserialmode-mode",
            "text": "",
            "title": "int send( uint8_t * buffer,  int bufferLen,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_8",
            "text": "Sends a buffer of known length over the serial line.    buffer   a pointer to the first character of the buffer    len   the number of bytes that are safely available to read.    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.  SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_8",
            "text": "uint8_t *  buffer - a pointer to the first character of the buffer  int  bufferLen - a pointer to the first character of the buffer  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.   SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_5",
            "text": "the number of bytes written, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission, MICROBIT_INVALID_PARAMETER if buffer is invalid, or the given bufferLen is <= 0.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#read",
            "text": "",
            "title": "read"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-read",
            "text": "",
            "title": "int read()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_9",
            "text": "Reads a single character from the rxBuff    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.  SYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.  SYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_6",
            "text": "a character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-read-microbitserialmode-mode",
            "text": "",
            "title": "int read( MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_10",
            "text": "Reads a single character from the rxBuff    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.  SYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.  SYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_9",
            "text": "MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.   SYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.  SYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_7",
            "text": "a character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#managedstring-read-int-size",
            "text": "",
            "title": "ManagedString read( int size)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_11",
            "text": "Reads multiple characters from the rxBuff and returns them as a  ManagedString     size   the number of characters to read.    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.  SYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_10",
            "text": "int  size - the number of characters to read.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_8",
            "text": "A  ManagedString , or an empty  ManagedString  if an error was encountered during the read.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#managedstring-read-int-size-microbitserialmode-mode",
            "text": "",
            "title": "ManagedString read( int size,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_12",
            "text": "Reads multiple characters from the rxBuff and returns them as a  ManagedString     size   the number of characters to read.    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.  SYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_11",
            "text": "int  size - the number of characters to read.  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.   SYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_9",
            "text": "A  ManagedString , or an empty  ManagedString  if an error was encountered during the read.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-read-uint8_t-42-buffer-int-bufferlen",
            "text": "",
            "title": "int read( uint8_t * buffer,  int bufferLen)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_13",
            "text": "Reads multiple characters from the rxBuff and fills a user buffer.    buffer   a pointer to a user allocated buffer.    bufferLen   the amount of data that can be safely stored    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.  SYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_12",
            "text": "uint8_t *  buffer - a pointer to a user allocated buffer.  int  bufferLen - the amount of data that can be safely stored",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_10",
            "text": "the number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-read-uint8_t-42-buffer-int-bufferlen-microbitserialmode-mode",
            "text": "",
            "title": "int read( uint8_t * buffer,  int bufferLen,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_14",
            "text": "Reads multiple characters from the rxBuff and fills a user buffer.    buffer   a pointer to a user allocated buffer.    bufferLen   the amount of data that can be safely stored    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.  SYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_13",
            "text": "uint8_t *  buffer - a pointer to a user allocated buffer.  int  bufferLen - the amount of data that can be safely stored  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.   SYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_11",
            "text": "the number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#readuntil",
            "text": "",
            "title": "readUntil"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#managedstring-readuntil-managedstring-delimeters",
            "text": "",
            "title": "ManagedString readUntil( ManagedString delimeters)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_15",
            "text": "Reads until one of the delimeters matches a character in the rxBuff    delimeters   a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.  SYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.  SYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_14",
            "text": "ManagedString  delimeters - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_12",
            "text": "A  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.   Note  delimeters are matched on a per byte basis.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#managedstring-readuntil-managedstring-delimeters-microbitserialmode-mode",
            "text": "",
            "title": "ManagedString readUntil( ManagedString delimeters,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_16",
            "text": "Reads until one of the delimeters matches a character in the rxBuff    delimeters   a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)    mode   the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.  SYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.  SYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.  Defaults to SYNC_SLEEP.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_15",
            "text": "ManagedString  delimeters - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\u201c\\r\\n\u201d)  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.   SYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.  SYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_13",
            "text": "A  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.   Note  delimeters are matched on a per byte basis.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#baud",
            "text": "",
            "title": "baud"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#void-baud-int-baudrate",
            "text": "",
            "title": "void baud( int baudrate)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_17",
            "text": "A wrapper around the inherited method \u201cbaud\u201d so we can trap the baud rate as it changes and restore it if  redirect()  is called.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_16",
            "text": "int  baudrate - the new baudrate. See: \n https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c  for permitted baud rates.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_14",
            "text": "MICROBIT_INVALID_PARAMETER if baud rate is less than 0, otherwise MICROBIT_OK.   Note  the underlying implementation chooses the first allowable rate at or above that requested.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#redirect",
            "text": "",
            "title": "redirect"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-redirect-pinname-tx-pinname-rx",
            "text": "",
            "title": "int redirect( PinName tx,  PinName rx)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_18",
            "text": "A way of dynamically configuring the serial instance to use pins other than USBTX and USBRX.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_17",
            "text": "PinName  tx - the new transmission pin.  PinName  rx - the new reception pin.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_15",
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently transmitting or receiving, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#eventafter",
            "text": "",
            "title": "eventAfter"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-eventafter-int-len",
            "text": "",
            "title": "int eventAfter( int len)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_19",
            "text": "Configures an event to be fired after \u201clen\u201d characters.    Will generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_HEAD_MATCH.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_18",
            "text": "int  len - the number of characters to wait before triggering the event.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_16",
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-eventafter-int-len-microbitserialmode-mode",
            "text": "",
            "title": "int eventAfter( int len,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_20",
            "text": "Configures an event to be fired after \u201clen\u201d characters.    Will generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_HEAD_MATCH.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_19",
            "text": "int  len - the number of characters to wait before triggering the event.  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.   SYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER  SYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_17",
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#eventon",
            "text": "",
            "title": "eventOn"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-eventon-managedstring-delimeters",
            "text": "",
            "title": "int eventOn( ManagedString delimeters)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_21",
            "text": "Configures an event to be fired on a match with one of the delimeters.    Will generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_DELIM_MATCH.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_20",
            "text": "ManagedString  delimeters - the characters to match received characters against e.g.  ManagedString (\u201c\\n\u201d)",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_18",
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.   Note  delimeters are matched on a per byte basis.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-eventon-managedstring-delimeters-microbitserialmode-mode",
            "text": "",
            "title": "int eventOn( ManagedString delimeters,  MicroBitSerialMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_22",
            "text": "Configures an event to be fired on a match with one of the delimeters.    Will generate an event with the ID: MICROBIT_ID_SERIAL and the value MICROBIT_SERIAL_EVT_DELIM_MATCH.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_21",
            "text": "ManagedString  delimeters - the characters to match received characters against e.g.  ManagedString (\u201c\\n\u201d)  MicroBitSerialMode  mode - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.   SYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER  SYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_19",
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.   Note  delimeters are matched on a per byte basis.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#isreadable",
            "text": "",
            "title": "isReadable"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-isreadable",
            "text": "",
            "title": "int isReadable()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_23",
            "text": "Determines whether there is any data waiting in our Rx buffer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_20",
            "text": "1 if we have space, 0 if we do not.   Note  We do not wrap the super\u2019s readable() method as we don\u2019t want to interfere with communities that use manual calls to serial.readable().",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#iswriteable",
            "text": "",
            "title": "isWriteable"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-iswriteable",
            "text": "",
            "title": "int isWriteable()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_24",
            "text": "Determines if we have space in our txBuff.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_21",
            "text": "1 if we have space, 0 if we do not.   Note  We do not wrap the super\u2019s writeable() method as we don\u2019t want to interfere with communities that use manual calls to serial.writeable().",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#setrxbuffersize",
            "text": "",
            "title": "setRxBufferSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-setrxbuffersize-uint8_t-size",
            "text": "",
            "title": "int setRxBufferSize( uint8_t size)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_25",
            "text": "Reconfigures the size of our rxBuff",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_22",
            "text": "uint8_t  size - the new size for our rxBuff",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_22",
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#settxbuffersize",
            "text": "",
            "title": "setTxBufferSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-settxbuffersize-uint8_t-size",
            "text": "",
            "title": "int setTxBufferSize( uint8_t size)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_26",
            "text": "Reconfigures the size of our txBuff",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_23",
            "text": "uint8_t  size - the new size for our txBuff",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_23",
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#getrxbuffersize",
            "text": "",
            "title": "getRxBufferSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-getrxbuffersize",
            "text": "",
            "title": "int getRxBufferSize()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_27",
            "text": "The size of our rx buffer in bytes.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_24",
            "text": "the current size of rxBuff in bytes",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#gettxbuffersize",
            "text": "",
            "title": "getTxBufferSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-gettxbuffersize",
            "text": "",
            "title": "int getTxBufferSize()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_28",
            "text": "The size of our tx buffer in bytes.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_25",
            "text": "the current size of txBuff in bytes",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#clearrxbuffer",
            "text": "",
            "title": "clearRxBuffer"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-clearrxbuffer",
            "text": "",
            "title": "int clearRxBuffer()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_29",
            "text": "Sets the tail to match the head of our circular buffer for reception, effectively clearing the reception buffer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_26",
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#cleartxbuffer",
            "text": "",
            "title": "clearTxBuffer"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-cleartxbuffer",
            "text": "",
            "title": "int clearTxBuffer()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_30",
            "text": "Sets the tail to match the head of our circular buffer for transmission, effectively clearing the transmission buffer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_27",
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#rxbufferedsize",
            "text": "",
            "title": "rxBufferedSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-rxbufferedsize",
            "text": "",
            "title": "int rxBufferedSize()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_31",
            "text": "The number of bytes currently stored in our rx buffer waiting to be digested, by the user.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_28",
            "text": "The currently buffered number of bytes in our rxBuff.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#txbufferedsize",
            "text": "",
            "title": "txBufferedSize"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-txbufferedsize",
            "text": "",
            "title": "int txBufferedSize()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_32",
            "text": "The number of bytes currently stored in our tx buffer waiting to be transmitted by the hardware.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_29",
            "text": "The currently buffered number of bytes in our txBuff.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#rxinuse",
            "text": "",
            "title": "rxInUse"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-rxinuse",
            "text": "",
            "title": "int rxInUse()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_33",
            "text": "Determines if the serial bus is currently in use by another fiber for reception.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_30",
            "text": "The state of our mutex lock for reception.   Note  Only one fiber can call read at a time",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#txinuse",
            "text": "",
            "title": "txInUse"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#int-txinuse",
            "text": "",
            "title": "int txInUse()"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_34",
            "text": "Determines if the serial bus is currently in use by another fiber for transmission.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#returns_31",
            "text": "The state of our mutex lock for transmition.   Note  Only one fiber can call send at a time",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#detach",
            "text": "",
            "title": "detach"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#void-detach-serialirqtype-interupttype",
            "text": "",
            "title": "void detach( Serial::IrqType interuptType)"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#description_35",
            "text": "Detaches a previously configured interrupt    interruptType   one of Serial::RxIrq or Serial::TxIrq",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/serial/#parameters_24",
            "text": "Serial::IrqType  interuptType",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/",
            "text": "uBit.messageBus\n#\n\n\nOverview\n#\n\n\nThe micro:bit has an eventing model that can notify user code when specific things happen on the micro:bit.\n\n\nFor example, the \nMicroBitAccelerometer\n will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. \nMicroBitButton\n will send events on a range of button up, down, click and hold events.\n\n\nProgrammers are also free (in fact, encouraged!) to send their own events whenever they feel it would be useful.\n\n\nRegistering an event handler\n#\n\n\nThe \nMicroBitMessageBus\n records which events your program is interested in, and delivers those \nMicroBitEvent\ns to your program as they occur\nthrough a defined \nevent handler\n.  \n\n\nThis is achieved through the \nMicroBitMessageBus\n \nlisten\n function. This lets you attach a callback\nto a function when a specified event (or events) occur.\n\n\nYou can also control the queuing and threading model used for your callback function on a per event handler basis.\n\n\nThis may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onButtonA(MicroBitEvent)\n{\n    uBit.display.print(\"A\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}\n\n\n\n\nNow, whenever the \nMICROBIT_BUTTON_EVT_CLICK\n event is raise by \nMICROBIT_ID_BUTTON_A\n, your code inside function \nonButtonA\n will be automatically run.\n\n\nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program.\n\n\nWildcard Events\n#\n\n\nSometimes though, you want to capture all events generated by some component. For example, you might want to know when any changes in a button has happened.\n\n\nIn this case, there is a special event value called \nMICROBIT_EVT_ANY\n. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\n\n\nYou can find out which ones by looking at the \nMicroBitEvent\n delivered to your function - it contains the source and value variable of the event.\n\n\nFor example, you could write a program like this:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\"CLICK\");\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\"DOWN\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}\n\n\n\n\nIf you \nREALLY\n want even more events, there is also a \nMICROBIT_ID_ANY\n source, that allows you to attach a function to event generated from any component.\n\n\nUse this sparingly though, as this could be quite a lot of events!\n\n\nThe following code would attach the \nonEvent\n function to receive all the events from the whole runtime:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onEvent(MicroBitEvent)\n{\n    uBit.display.scroll(\"SOMETHING HAPPENED!\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}\n\n\n\n\nDefining a Threading Mode\n#\n\n\nWhenever you register a listener, you may choose the threading mode used with that handler. Every event handler can have its own threading mode, that defines when your handler\nwill be executed, and how it will react to receiving multiple events.\n\n\nThere are four permissible modes for event handlers. These are:\n\n\n\n\n\n\n\n\nThreading mode\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_IMMEDIATE\n\n\nHandler is called directly from the code raising the event. Event handler is \nnot\n permitted to block.\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_DROP_IF_BUSY\n\n\nHandler is executed through its own fiber. If another event arrives whilst the previous event is still being processed, the new event will be silently dropped.\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_QUEUE_IF_BUSY\n\n\nHandler is executed though its own fiber. If another event arrives, it is queued, and the event handler will immediately be called again once processing is complete. (default)\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_REENTRANT\n\n\nEvery event is executed in its own fiber. if another event arrives, it is handled concurrently in its own fiber.\n\n\n\n\n\n\n\n\nThese various modes provide great flexibility in how the runtime can be used to support higher level languages and applications. For example, \nMESSAGE_BUS_LISTENER_IMMEDIATE\n is ideal for very simple, lightweight handlers, as this will provide very timely response to events with a low processing overhead. However, it is easy to cause side effects on other parts of the code if it does not return promptly.\n\nMESSAGE_BUS_LISTENER_DROP_IF_BUSY\n provide semantics identical to the Scratch programming language, and can be used to build easy to understand, asynchronous environments.\n\n\nMESSAGE_BUS_LISTENER_QUEUE_IF_BUSY\n provides similar semantics, but with tolerance to avoiding loss of high frequency events.\n\n\nMESSAGE_BUS_LISTENER_REENTRANT\n provides guaranteed causal ordering and improved concurrency, but at the cost of additional complexity and RAM.\n\n\nYou can define the threading mode you want to use on a per event handler basis as an optional final parameter to the listen function:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nbool pressed = false;\n\nvoid onButtonA(MicroBitEvent)\n{\n    pressed = true;\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA, MESSAGE_BUS_LISTENER_IMMEDIATE);\n\n    // We don't want to drop out of main!\n    while(1)\n    {\n        if(pressed)\n            uBit.display.scroll(\"Pressed!\");\n        uBit.sleep(100);\n    }\n}\n\n\n\n\nC++ Event Handlers\n#\n\n\nIt is also possible to write event handlers as C++ member functions. If you don\u2019t know what this means, then don\u2019t worry, as that also means you won\u2019t need it. :-)\n\n\nFor those programmers who do like to write C++, you can use a variation of the \nlisten\n function to register your member function event handler.\n\n\nThis takes the same form as the examples above, but with an additional parameter to specify the object to call the method on. You are also required to specify your event handler using legal C++ syntax.\n\n\nFor example, you can write code like this to register an event handler in your own class:\n\n\nMyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed);\n}\n\n\n\n\nAgain, it is also possible to a threading mode as an optional final parameter:\n\n\nMyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}\n\n\n\n\nRemoving Event Handlers\n#\n\n\nEvent handlers can be dynamically removed from the message bus as well as added. To do this, use the \nignore\n function. This takes precisely the same parameters as the\nlisten function, except that the threading mode argument is never used.\n\n\nFor example, to remove the event handlers shown above:\n\n\nuBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\nuBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed);\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_MESSAGE_BUS_LISTENER\n\n\n1021\n\n\n\n\n\n\n\n\nThe message bus will send a \nMICROBIT_ID_MESSAGE_BUS_LISTENER\n event whenever a new listener is added to the message bus.\n\n\nThis event allows other parts of the system to detect when interactions are taking place with a component. This is primarily used as a power management mechanism - allowing on demand activation of hardware when necessary.\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMessage Bus ID of listener\n\n\n1-65535\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitMessageBus()\n#\n\n\nDescription\n#\n\n\nDefault constructor.  \n\n\nAdds itself as a fiber component, and also configures itself to be the default  EventModel  if defaultEventBus is NULL.           \n\n\nsend\n#\n\n\n\n\nint\n \nsend\n( \nMicroBitEvent\n evt)\n#\n\n\nDescription\n#\n\n\nQueues the given event to be sent to all registered recipients.  \n\n\nParameters\n#\n\n\n\n\nMicroBitEvent\n evt - The event to send.\n\n\n\n\nExample\n#\n\n\n MicroBitMessageBus bus; \n\n // Creates and sends the MicroBitEvent using bus. \n MicrobitEvent evt(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK); \n\n // Creates the MicrobitEvent, but delays the sending of that event. \n MicrobitEvent evt1(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, CREATE_ONLY); \n\n bus.send(evt1); \n\n // This has the same effect! \n evt1.fire() \n\n\n\n\nprocess\n#\n\n\n\n\nint\n \nprocess\n( \nMicroBitEvent  &\n evt)\n#\n\n\nDescription\n#\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.  \n\n\nParameters\n#\n\n\n\n\nMicroBitEvent  &\n evt - The event to send.\n\n\n\n\nReturns\n#\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\n\n\nNote\n\n\nIt is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent. \n\n\n\n\n\n\nint\n \nprocess\n( \nMicroBitEvent  &\n evt,  \nbool\n urgent)\n#\n\n\nDescription\n#\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.  \n\n\nParameters\n#\n\n\n\n\nMicroBitEvent  &\n evt - The event to send.\n\n\nbool\n urgent - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed. Defaults to false.\n\n\n\n\nReturns\n#\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\n\n\nNote\n\n\nIt is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent. \n\n\n\n\nelementAt\n#\n\n\n\n\nMicroBitListener\n \nelementAt\n( \nint\n n)\n#\n\n\nDescription\n#\n\n\nReturns the microBitListener with the given position in our list.  \n\n\nParameters\n#\n\n\n\n\nint\n n - The position in the list to return.\n\n\n\n\nReturns\n#\n\n\nthe  MicroBitListener  at postion n in the list, or NULL if the position is invalid. \n\n\nadd\n#\n\n\n\n\nint\n \nadd\n( \nMicroBitListener  *\n newListener)\n#\n\n\nDescription\n#\n\n\nAdd the given  MicroBitListener  to the list of event handlers, unconditionally.  \n\n\nParameters\n#\n\n\n\n\nMicroBitListener  *\n newListener\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise. \n\n\nremove\n#\n\n\n\n\nint\n \nremove\n( \nMicroBitListener  *\n newListener)\n#\n\n\nDescription\n#\n\n\nRemove the given  MicroBitListener  from the list of event handlers.  \n\n\nParameters\n#\n\n\n\n\nMicroBitListener  *\n newListener\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.",
            "title": "messageBus"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#ubitmessagebus",
            "text": "",
            "title": "uBit.messageBus"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#overview",
            "text": "The micro:bit has an eventing model that can notify user code when specific things happen on the micro:bit.  For example, the  MicroBitAccelerometer  will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall.  MicroBitButton  will send events on a range of button up, down, click and hold events.  Programmers are also free (in fact, encouraged!) to send their own events whenever they feel it would be useful.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#registering-an-event-handler",
            "text": "The  MicroBitMessageBus  records which events your program is interested in, and delivers those  MicroBitEvent s to your program as they occur\nthrough a defined  event handler .    This is achieved through the  MicroBitMessageBus   listen  function. This lets you attach a callback\nto a function when a specified event (or events) occur.  You can also control the queuing and threading model used for your callback function on a per event handler basis.  This may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onButtonA(MicroBitEvent)\n{\n    uBit.display.print(\"A\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}  Now, whenever the  MICROBIT_BUTTON_EVT_CLICK  event is raise by  MICROBIT_ID_BUTTON_A , your code inside function  onButtonA  will be automatically run.  You can call listen as many times as you want to attached functions to each of the events that are useful for your program.",
            "title": "Registering an event handler"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#wildcard-events",
            "text": "Sometimes though, you want to capture all events generated by some component. For example, you might want to know when any changes in a button has happened.  In this case, there is a special event value called  MICROBIT_EVT_ANY . If you call listen with this value, then ALL events from the given source component will be delivered to your function.  You can find out which ones by looking at the  MicroBitEvent  delivered to your function - it contains the source and value variable of the event.  For example, you could write a program like this:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\"CLICK\");\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\"DOWN\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}  If you  REALLY  want even more events, there is also a  MICROBIT_ID_ANY  source, that allows you to attach a function to event generated from any component.  Use this sparingly though, as this could be quite a lot of events!  The following code would attach the  onEvent  function to receive all the events from the whole runtime:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onEvent(MicroBitEvent)\n{\n    uBit.display.scroll(\"SOMETHING HAPPENED!\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n\n    // We don't want to drop out of main!\n    while(1)\n        uBit.sleep(100);\n}",
            "title": "Wildcard Events"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#defining-a-threading-mode",
            "text": "Whenever you register a listener, you may choose the threading mode used with that handler. Every event handler can have its own threading mode, that defines when your handler\nwill be executed, and how it will react to receiving multiple events.  There are four permissible modes for event handlers. These are:     Threading mode  Brief Description      MESSAGE_BUS_LISTENER_IMMEDIATE  Handler is called directly from the code raising the event. Event handler is  not  permitted to block.    MESSAGE_BUS_LISTENER_DROP_IF_BUSY  Handler is executed through its own fiber. If another event arrives whilst the previous event is still being processed, the new event will be silently dropped.    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY  Handler is executed though its own fiber. If another event arrives, it is queued, and the event handler will immediately be called again once processing is complete. (default)    MESSAGE_BUS_LISTENER_REENTRANT  Every event is executed in its own fiber. if another event arrives, it is handled concurrently in its own fiber.     These various modes provide great flexibility in how the runtime can be used to support higher level languages and applications. For example,  MESSAGE_BUS_LISTENER_IMMEDIATE  is ideal for very simple, lightweight handlers, as this will provide very timely response to events with a low processing overhead. However, it is easy to cause side effects on other parts of the code if it does not return promptly. MESSAGE_BUS_LISTENER_DROP_IF_BUSY  provide semantics identical to the Scratch programming language, and can be used to build easy to understand, asynchronous environments.  MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY  provides similar semantics, but with tolerance to avoiding loss of high frequency events.  MESSAGE_BUS_LISTENER_REENTRANT  provides guaranteed causal ordering and improved concurrency, but at the cost of additional complexity and RAM.  You can define the threading mode you want to use on a per event handler basis as an optional final parameter to the listen function:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nbool pressed = false;\n\nvoid onButtonA(MicroBitEvent)\n{\n    pressed = true;\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA, MESSAGE_BUS_LISTENER_IMMEDIATE);\n\n    // We don't want to drop out of main!\n    while(1)\n    {\n        if(pressed)\n            uBit.display.scroll(\"Pressed!\");\n        uBit.sleep(100);\n    }\n}",
            "title": "Defining a Threading Mode"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#c-event-handlers",
            "text": "It is also possible to write event handlers as C++ member functions. If you don\u2019t know what this means, then don\u2019t worry, as that also means you won\u2019t need it. :-)  For those programmers who do like to write C++, you can use a variation of the  listen  function to register your member function event handler.  This takes the same form as the examples above, but with an additional parameter to specify the object to call the method on. You are also required to specify your event handler using legal C++ syntax.  For example, you can write code like this to register an event handler in your own class:  MyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed);\n}  Again, it is also possible to a threading mode as an optional final parameter:  MyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\"A\");\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}",
            "title": "C++ Event Handlers"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#removing-event-handlers",
            "text": "Event handlers can be dynamically removed from the message bus as well as added. To do this, use the  ignore  function. This takes precisely the same parameters as the\nlisten function, except that the threading mode argument is never used.  For example, to remove the event handlers shown above:  uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\nuBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, &MyCoolObject::onButtonPressed);",
            "title": "Removing Event Handlers"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_MESSAGE_BUS_LISTENER  1021     The message bus will send a  MICROBIT_ID_MESSAGE_BUS_LISTENER  event whenever a new listener is added to the message bus.  This event allows other parts of the system to detect when interactions are taking place with a component. This is primarily used as a power management mechanism - allowing on demand activation of hardware when necessary.",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#message-bus-events",
            "text": "Constant  Value      Message Bus ID of listener  1-65535",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#microbitmessagebus",
            "text": "",
            "title": "MicroBitMessageBus()"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description",
            "text": "Default constructor.    Adds itself as a fiber component, and also configures itself to be the default  EventModel  if defaultEventBus is NULL.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#send",
            "text": "",
            "title": "send"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#int-send-microbitevent-evt",
            "text": "",
            "title": "int send( MicroBitEvent evt)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_1",
            "text": "Queues the given event to be sent to all registered recipients.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters",
            "text": "MicroBitEvent  evt - The event to send.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#example",
            "text": "MicroBitMessageBus bus; \n\n // Creates and sends the MicroBitEvent using bus. \n MicrobitEvent evt(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK); \n\n // Creates the MicrobitEvent, but delays the sending of that event. \n MicrobitEvent evt1(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, CREATE_ONLY); \n\n bus.send(evt1); \n\n // This has the same effect! \n evt1.fire()",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#process",
            "text": "",
            "title": "process"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#int-process-microbitevent-evt",
            "text": "",
            "title": "int process( MicroBitEvent  &amp; evt)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_2",
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters_1",
            "text": "MicroBitEvent  &  evt - The event to send.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#returns",
            "text": "1 if all matching listeners were processed, 0 if further processing is required.   Note  It is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#int-process-microbitevent-evt-bool-urgent",
            "text": "",
            "title": "int process( MicroBitEvent  &amp; evt,  bool urgent)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_3",
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters_2",
            "text": "MicroBitEvent  &  evt - The event to send.  bool  urgent - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed. Defaults to false.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#returns_1",
            "text": "1 if all matching listeners were processed, 0 if further processing is required.   Note  It is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#elementat",
            "text": "",
            "title": "elementAt"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#microbitlistener-elementat-int-n",
            "text": "",
            "title": "MicroBitListener elementAt( int n)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_4",
            "text": "Returns the microBitListener with the given position in our list.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters_3",
            "text": "int  n - The position in the list to return.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#returns_2",
            "text": "the  MicroBitListener  at postion n in the list, or NULL if the position is invalid.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#add",
            "text": "",
            "title": "add"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#int-add-microbitlistener-42-newlistener",
            "text": "",
            "title": "int add( MicroBitListener  * newListener)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_5",
            "text": "Add the given  MicroBitListener  to the list of event handlers, unconditionally.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters_4",
            "text": "MicroBitListener  *  newListener",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#returns_3",
            "text": "MICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#remove",
            "text": "",
            "title": "remove"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#int-remove-microbitlistener-42-newlistener",
            "text": "",
            "title": "int remove( MicroBitListener  * newListener)"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#description_6",
            "text": "Remove the given  MicroBitListener  from the list of event handlers.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#parameters_5",
            "text": "MicroBitListener  *  newListener",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/messageBus/#returns_4",
            "text": "MICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/button/",
            "text": "Buttons\n#\n\n\nOverview\n#\n\n\nThe micro:bit has two forward facing buttons either side of the display, \nbuttonA\n\nand \nbuttonB\n. These are intuitively exposed on the \nMicroBit\n object as \nuBit.buttonA\n\nand \nuBit.buttonB\n. A third button, \nuBit.buttonAB\n is used to detect the combined\ninput of \nbuttonA\n and \nbuttonB\n, and is an instance of the class \nMicroBitMultiButton\n.\n\n\nHardware buttons are notoriously renowned for generating multiple open/close transitions\nfor what a user perceives as a single press, which can make depending on the raw input\nof a button unreliable. To combat this, a technique called \u2018debouncing\u2019 is used, which\nperiodically polls the state of the button, when a transition from open to close\n(and vice versa) is detected. Through periodically polling the button, we get a\nmore accurate representation of the state of a button.\n\n\nMicroBitButton\ns and \nMicroBitMultiButton\ns are debounced in\nsoftware and provide a number of events that can be used to detect different\nvariations of presses.\n\n\nThe \nMicroBitButton\n debouncing mechanism is used to provide resistive touch sensing on \nMicroBitPin\ns\nand could also be used on external \u2018button-like\u2019 input if required.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_A\n\n\n1\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_B\n\n\n2\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation of a button.  \n\n\nParameters\n#\n\n\n\n\nPinName\n name - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n id - the ID of the new  MicroBitButton  object.\n\n\n\n\nExample\n#\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id,  \nMicroBitButtonEventConfiguration\n eventConfiguration)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation of a button.  \n\n\nParameters\n#\n\n\n\n\nPinName\n name - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n id - the ID of the new  MicroBitButton  object.\n\n\nMicroBitButtonEventConfiguration\n eventConfiguration - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.\n\n\n\n\nExample\n#\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id,  \nMicroBitButtonEventConfiguration\n eventConfiguration,  \nPinMode\n mode)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation of a button.  \n\n\nParameters\n#\n\n\n\n\nPinName\n name - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n id - the ID of the new  MicroBitButton  object.\n\n\nMicroBitButtonEventConfiguration\n eventConfiguration - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.\n\n\nPinMode\n mode - the configuration of internal pullups/pulldowns, as defined in the mbed PinMode class. PullNone by default.\n\n\n\n\nExample\n#\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\nisPressed\n#\n\n\n\n\nint\n \nisPressed\n()\n#\n\n\nDescription\n#\n\n\nTests if this Button is currently pressed.  \n\n\nReturns\n#\n\n\n1 if this button is pressed, 0 otherwise. \n\n\nExample\n#\n\n\n if(buttonA.isPressed()) \n display.scroll(\"Pressed!\"); \n\n\n\n\nsetEventConfiguration\n#\n\n\n\n\nvoid\n \nsetEventConfiguration\n( \nMicroBitButtonEventConfiguration\n config)\n#\n\n\nDescription\n#\n\n\nChanges the event configuration used by this button to the given MicroBitButtonEventConfiguration.  \n\n\nAll subsequent events generated by this button will then be informed by this configuraiton.  \n\n\nParameters\n#\n\n\n\n\nMicroBitButtonEventConfiguration\n config - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.\n\n\n\n\nExample\n#\n\n\n // Configure a button to generate all possible events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);",
            "title": "buttons"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#buttons",
            "text": "",
            "title": "Buttons"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#overview",
            "text": "The micro:bit has two forward facing buttons either side of the display,  buttonA \nand  buttonB . These are intuitively exposed on the  MicroBit  object as  uBit.buttonA \nand  uBit.buttonB . A third button,  uBit.buttonAB  is used to detect the combined\ninput of  buttonA  and  buttonB , and is an instance of the class  MicroBitMultiButton .  Hardware buttons are notoriously renowned for generating multiple open/close transitions\nfor what a user perceives as a single press, which can make depending on the raw input\nof a button unreliable. To combat this, a technique called \u2018debouncing\u2019 is used, which\nperiodically polls the state of the button, when a transition from open to close\n(and vice versa) is detected. Through periodically polling the button, we get a\nmore accurate representation of the state of a button.  MicroBitButton s and  MicroBitMultiButton s are debounced in\nsoftware and provide a number of events that can be used to detect different\nvariations of presses.  The  MicroBitButton  debouncing mechanism is used to provide resistive touch sensing on  MicroBitPin s\nand could also be used on external \u2018button-like\u2019 input if required.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_BUTTON_A  1    MICROBIT_ID_BUTTON_B  2",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#message-bus-events",
            "text": "Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#microbitbutton-pinname-name-uint16_t-id",
            "text": "",
            "title": "MicroBitButton( PinName name,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#description",
            "text": "Constructor.    Create a software representation of a button.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#parameters",
            "text": "PinName  name - the physical pin on the processor that should be used as input.  uint16_t  id - the ID of the new  MicroBitButton  object.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#example",
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#microbitbutton-pinname-name-uint16_t-id-microbitbuttoneventconfiguration-eventconfiguration",
            "text": "",
            "title": "MicroBitButton( PinName name,  uint16_t id,  MicroBitButtonEventConfiguration eventConfiguration)"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#description_1",
            "text": "Constructor.    Create a software representation of a button.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#parameters_1",
            "text": "PinName  name - the physical pin on the processor that should be used as input.  uint16_t  id - the ID of the new  MicroBitButton  object.  MicroBitButtonEventConfiguration  eventConfiguration - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#example_1",
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#microbitbutton-pinname-name-uint16_t-id-microbitbuttoneventconfiguration-eventconfiguration-pinmode-mode",
            "text": "",
            "title": "MicroBitButton( PinName name,  uint16_t id,  MicroBitButtonEventConfiguration eventConfiguration,  PinMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#description_2",
            "text": "Constructor.    Create a software representation of a button.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#parameters_2",
            "text": "PinName  name - the physical pin on the processor that should be used as input.  uint16_t  id - the ID of the new  MicroBitButton  object.  MicroBitButtonEventConfiguration  eventConfiguration - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.  PinMode  mode - the configuration of internal pullups/pulldowns, as defined in the mbed PinMode class. PullNone by default.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#example_2",
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#ispressed",
            "text": "",
            "title": "isPressed"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#int-ispressed",
            "text": "",
            "title": "int isPressed()"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#description_3",
            "text": "Tests if this Button is currently pressed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#returns",
            "text": "1 if this button is pressed, 0 otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#example_3",
            "text": "if(buttonA.isPressed()) \n display.scroll(\"Pressed!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#seteventconfiguration",
            "text": "",
            "title": "setEventConfiguration"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#void-seteventconfiguration-microbitbuttoneventconfiguration-config",
            "text": "",
            "title": "void setEventConfiguration( MicroBitButtonEventConfiguration config)"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#description_4",
            "text": "Changes the event configuration used by this button to the given MicroBitButtonEventConfiguration.    All subsequent events generated by this button will then be informed by this configuraiton.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#parameters_3",
            "text": "MicroBitButtonEventConfiguration  config - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/button/#example_4",
            "text": "// Configure a button to generate all possible events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/",
            "text": "uBit.display\n#\n\n\nOverview\n#\n\n\nThe MicroBitDisplay class is a general purpose device driver for controlling LED matrix displays.\nLED matrix displays are simple, inexpensive devices that use a single LED as a display pixel. They therefore\ntend to be of relatively low resolution, but often provide visually attractive displays due to the high coherence and brightness\nof the LEDs.\n\n\nLEDs in matrix displays are connected to general purpose I/O (GPIO) pins on CPU. Although they \ncould\n be connected such that each\nLED has its own GPIO pin, this is not usually the case, as the scarce resource of GPIO pins would soon be used up.  For example,\non the micro:bit, the LED matrix has 25 LEDs. If this required 25 GPIO pins, then there would be none left for anything else!\n\n\nInstead, these LEDs are controlled by 12 GPIO pins. Three of those pins provide power to LEDs, the other\nnine provide a route to ground. The pins that source power are called \nrows\n. The pins that sink power are called \ncolumns\n.\nThe following diagram shows how the 5x5 grid is connected into 3 logical \u2018rows\u2019 and 9 \u2018columns\u2019:\n\n\n\n\nWhere the format is: \nROW\n.\nCOLUMN\n\n\nSo, if we wanted to light up the middle LED, we would need to put a HIGH voltage (logic 1) on row 2, and a LOW voltage (logic 0) on column 3. Notice that when row 2 is\nHIGH, we the value we write to the 9 column pins affect all of the LEDs 2.1 to 2.7, without affecting any of the LEDS on row 1 or row 3. Sharing GPIO pins in this way is known as multiplexing.\nMoreover, if we scan through the different rows fast enough - faster than the eye can see - then we can provide the illusion of all the LEDS being on at the same time! This is a technique\nknown as \npersistence of vision\n\u2026 and was also the same basis of the very first TV sets (although that did not use LEDs!).\n\n\nCapabilities\n#\n\n\nThe MicroBitDisplay class provides a driver for a general purpose matrix display, and also several high level features that make creating animations and visual effects on the\nmicro:bit LED display easy and fun! This class lets you:\n\n\n\n\nControl the LED matrix on the micro:bit.\n\n\nUse an optimised typeface (font) so you can show upper and lower case letters, numbers of symbols on the display.\n\n\nSet Display wide or \nper-pixel\n brightness control up to 256 levels per pixel.\n\n\nCreate, move, paste and animate images.\n\n\nScroll and print images and text.\n\n\nAccess the screen buffer directly, so you can manipulate individual pixels.\n\n\n\n\nUsing the Display\n#\n\n\nWhen using the uBit object, the display is automatically set up, and ready for you to use. Use any or all of the functions listed in the API section below to create effects on the\nLED display. Here are a few examples to get you started though!\n\n\nScrolling Text\n#\n\n\nSimply use the scroll function to specify the message you want to scroll, and sit back and watch the result. The message you provide will be scrolled, pixel by pixel across the display from right to left.\nIf you take a look at the documentation for the scroll function in the API below, you will notice that you can also specify the speed of the scroll as an optional final parameter. The lower the delay, the\nfaster your text will scroll across the screen.\n\n\nuBit.display.scroll(\"HELLO!\");\nuBit.display.scroll(\"HELLO!\", 100);\n\n\n\n\nNotice that you can also scroll numbers (either constants of variables):\n\n\nint c = 42;\nuBit.display.scroll(c);\n\n\n\n\nPrinting Text\n#\n\n\nSometimes it is better to show the letters/numbers in turn on the screen rather than scrolling them. If you want to do this, the \u2018print\u2019 function has exactly the same parameters as \u2018scroll\u2019, but\nwith this behaviour.  e.g.\n\n\nuBit.display.print(\"HELLO!\");\nuBit.display.print(\"HELLO!\", 100);\nuBit.display.print(42);\n\n\n\n\nDo notice that print behaves slightly differently if you provide a single character or numeric digit though. if you do this, the value you provide will stay on the screen until you explicitly\nchange the screen. If you ask the runtime to print a string with two or more characters, then each will appear in turn, then disappear. e.g. try this and you will find it stays on the screen:\n\n\nuBit.display.print(7);\n\n\n\n\nShowing Images\n#\n\n\nIt is also possible to print and scroll bitmap images on the display. Images are represented in the runtime by using a \nMicroBitImage\n. These can easily be created, just as\nyou create any variable. Once created, you can then provide them as a parameter to the scroll and print functions. Unlike the text based animation functions, you can also specify exactly\nwhere in the screen you would like the image to appear - and you can even treat pixel values of zero as transparent if you like!\nSee the \nMicroBitImage page\n for more details on images, but here are a few simple examples:\n\n\n// show your smiley on the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.print(smiley);\n\n\n\n\n// make your smiley peep up from the bottom of the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nfor (int y=4; y >= 0; y--)\n{\n    uBit.display.image.paste(smiley,0,y);\n    uBit.sleep(500);\n}\n\n\n\n\n// scroll your smiley across the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.scroll(smiley);\n\n\n\n\nRunning in the Background\u2026\n#\n\n\nBy now you have probably noticed that the scroll, print and animate functions all wait for the effect requested to finishes before returning. This is by design, to allow you to easily synchronise your programs.\nHowever, sometimes you want to launch an effect, and let it run in the background while your program does something else. For this, you can use the \nAsync\n variations of the scroll, print and animate functions.\nThese all have identical parameters and capabilities, but will return immediately. Try some of the examples above with their Async equivalents to understand this different behaviour.  For example:\n\n\n// scroll your smiley across the screen, without waiting for it to finish...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.scrollAsync(smiley);\n\n\n\n\nChanging Display Mode\n#\n\n\nThe MicroBitDisplay class supports either on/off LED display, or displays where each pixel has an individual brightness value between 0 and 255. The former costs much less processor time and battery power to\noperate, so it is the default. The latter does provide more useful effects though, so you can change between these modes by using the  \u2018setDiplayMode\u2019 function. Valid values are:\n\n\n\n\n\n\n\n\nDisplay mode\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nDISPLAY_MODE_BLACK_AND_WHITE\n\n\nEach pixel can be just on or off. The brightness of all pixels is controlled by the setBrightness function.\n\n\n\n\n\n\nDISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n\n\nEach pixel can be just on or off, and the display driver will also sense the ambient brightness from the LEDs.\n\n\n\n\n\n\nDISPLAY_MODE_GREYSCALE\n\n\nEach pixel can independently have 256 levels of brightness.\n\n\n\n\n\n\n\n\nfor example:\n\n\n// show a smiley with bright eyes!\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n32,0,0,0,32\\n0,32,32,32,0\\n\");\nuBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE);\nuBit.display.print(smiley);\n\n\n\n\nAccessing the Display Buffer\n#\n\n\nThe memory buffer that is used to drive the LEDs is itself a \nMicroBitImage\n. This means that you can also access and call any of the functions listed in the \nMicroBitImage API documentation\n\ndirectly on the display buffer. Examples here include setPixelValue, as illustrated below, but read the above documentation link for full details.\n\n\n// set a single pixel by co-ordinate\nuBit.display.image.setPixelValue(2,2,255);\n\n\n\n\nOther Useful Functions\n#\n\n\n\n\n\u2018clear\u2019 will clear the screen immediately.\n\n\n\u2018stopAnimation\u2019 will terminate any on-going print, scroll or animate functions.\n\n\n\u2018setBrightness\u2019 lets you set the overall maximum brightness of the display, as a value between 1 and 255.\n\n\n\u2018enable\u2019 and \u2018disable\u2019 turn on and off the display. When disabled, you can reuse many if the GPIO pins. See the \nMicroBitIO\n class for more information.\n\n\n\u2018rotateTo\u2019 even lets you specify the orientation of the display - in case you need to use your micro:bit the wrong way up. :-)\n\n\n\u2018readLightLevel\u2019 runs the LEDs backwards as photodiodes and tells you how bright your room is\u2026 see \nLight Sensing\n for more info!\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_DISPLAY\n\n\n6\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_ANIMATION_COMPLETE\n\n\n1\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n\n\n2\n\n\n\n\n\n\n\n\nNotify Events\n#\n\n\nThese events use the notification channel \nMICROBIT_ID_NOTIFY\n, which provides\ngeneral purpose synchronisation.\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_FREE\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitDisplay()\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.  \n\n\nExample\n#\n\n\n MicroBitDisplay display; \n\n\n\n\n\n\nMicroBitDisplay( \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.\n\n\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n\n\n\n\n\n\nMicroBitDisplay( \nuint16_t\n id,  \nconst  MatrixMap  &\n map)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.\n\n\nconst  MatrixMap  &\n map - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .\n\n\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n\n\n\n\nstopAnimation\n#\n\n\n\n\nvoid\n \nstopAnimation\n()\n#\n\n\nDescription\n#\n\n\nStops any currently running animation, and any that are waiting to be displayed.           \n\n\nprintCharAsync\n#\n\n\n\n\nint\n \nprintCharAsync\n( \nchar\n c)\n#\n\n\nDescription\n#\n\n\nPrints the given character to the display, if it is not in use.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\n\n\nint\n \nprintCharAsync\n( \nchar\n c,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given character to the display, if it is not in use.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\nint\n delay - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\nprintAsync\n#\n\n\n\n\nint\n \nprintAsync\n( \nManagedString\n s)\n#\n\n\nDescription\n#\n\n\nPrints the given  ManagedString  to the display, one character at a time. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync(\"abc123\",400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nManagedString\n s,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given  ManagedString  to the display, one character at a time. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\nint\n delay - The time to delay between characters, in milliseconds. Must be > 0. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync(\"abc123\",400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nMicroBitImage\n i)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nMicroBitImage\n i,  \nint\n x)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.\n\n\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprintAsync\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.\n\n\nint\n delay - The time to delay between characters, in milliseconds. Defaults to 0.\n\n\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\nprintChar\n#\n\n\n\n\nint\n \nprintChar\n( \nchar\n c)\n#\n\n\nDescription\n#\n\n\nPrints the given character to the display.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\n\n\nint\n \nprintChar\n( \nchar\n c,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given character to the display.  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\nint\n delay - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\nprint\n#\n\n\n\n\nint\n \nprint\n( \nManagedString\n s)\n#\n\n\nDescription\n#\n\n\nPrints the given string to the display, one character at a time.  \n\n\nBlocks the calling thread until all the text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.print(\"abc123\",400); \n\n\n\n\n\n\nint\n \nprint\n( \nManagedString\n s,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given string to the display, one character at a time.  \n\n\nBlocks the calling thread until all the text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\nint\n delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.print(\"abc123\",400); \n\n\n\n\n\n\nint\n \nprint\n( \nMicroBitImage\n i)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprint\n( \nMicroBitImage\n i,  \nint\n x)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprint\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprint\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\n\n\nint\n \nprint\n( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n i - The image to display.\n\n\nint\n x - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n y - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.\n\n\nint\n delay - The time to display the image for, or zero to show the image forever. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400); \n\n\n\n\nscrollAsync\n#\n\n\n\n\nint\n \nscrollAsync\n( \nManagedString\n s)\n#\n\n\nDescription\n#\n\n\nScrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.scrollAsync(\"abc123\",100); \n\n\n\n\n\n\nint\n \nscrollAsync\n( \nManagedString\n s,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nScrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\nint\n delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.scrollAsync(\"abc123\",100); \n\n\n\n\n\n\nint\n \nscrollAsync\n( \nMicroBitImage\n image)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1); \n\n\n\n\n\n\nint\n \nscrollAsync\n( \nMicroBitImage\n image,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1); \n\n\n\n\n\n\nint\n \nscrollAsync\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\nint\n stride - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1); \n\n\n\n\nscroll\n#\n\n\n\n\nint\n \nscroll\n( \nManagedString\n s)\n#\n\n\nDescription\n#\n\n\nScrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.scroll(\"abc123\",100); \n\n\n\n\n\n\nint\n \nscroll\n( \nManagedString\n s,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nScrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n s - The string to display.\n\n\nint\n delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n display.scroll(\"abc123\",100); \n\n\n\n\n\n\nint\n \nscroll\n( \nMicroBitImage\n image)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1); \n\n\n\n\n\n\nint\n \nscroll\n( \nMicroBitImage\n image,  \nint\n delay)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1); \n\n\n\n\n\n\nint\n \nscroll\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n#\n\n\nDescription\n#\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\nint\n stride - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1); \n\n\n\n\nanimateAsync\n#\n\n\n\n\nint\n \nanimateAsync\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5); \n\n\n\n\n\n\nint\n \nanimateAsync\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\nint\n startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5); \n\n\n\n\n\n\nint\n \nanimateAsync\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition,  \nint\n autoClear)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image - The image to display.\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\nint\n startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\nint\n autoClear - defines whether or not the display is automatically cleared once the animation is complete. By default, the display is cleared. Set this parameter to zero to disable the autoClear operation.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5); \n\n\n\n\nanimate\n#\n\n\n\n\nint\n \nanimate\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5); \n\n\n\n\n\n\nint\n \nanimate\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\nint\n startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5); \n\n\n\n\n\n\nint\n \nanimate\n( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition,  \nint\n autoClear)\n#\n\n\nDescription\n#\n\n\n\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.  \n\n\nParameters\n#\n\n\n\n\nMicroBitImage\n image\n\n\nint\n delay - The time to delay between each update of the display, in milliseconds.\n\n\nint\n stride - The number of pixels to shift by in each update.\n\n\nint\n startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\nint\n autoClear - defines whether or not the display is automatically cleared once the animation is complete. By default, the display is cleared. Set this parameter to zero to disable the autoClear operation.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5); \n\n\n\n\nsetBrightness\n#\n\n\n\n\nint\n \nsetBrightness\n( \nint\n b)\n#\n\n\nDescription\n#\n\n\nConfigures the brightness of the display.  \n\n\nParameters\n#\n\n\n\n\nint\n b - The brightness to set the brightness to, in the range 0 - 255.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER\n\n\nExample\n#\n\n\n display.setBrightness(255); //max brightness \n\n\n\n\nsetDisplayMode\n#\n\n\n\n\nvoid\n \nsetDisplayMode\n( \nDisplayMode\n mode)\n#\n\n\nDescription\n#\n\n\nConfigures the mode of the display.  \n\n\nParameters\n#\n\n\n\n\nDisplayMode\n mode - The mode to swap the display into. One of: DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n\n\n\n\nExample\n#\n\n\n display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness \n\n\n\n\ngetDisplayMode\n#\n\n\n\n\nint\n \ngetDisplayMode\n()\n#\n\n\nDescription\n#\n\n\nRetrieves the mode of the display.  \n\n\nReturns\n#\n\n\nthe current mode of the display \n\n\ngetBrightness\n#\n\n\n\n\nint\n \ngetBrightness\n()\n#\n\n\nDescription\n#\n\n\nFetches the current brightness of this display.  \n\n\nReturns\n#\n\n\nthe brightness of this display, in the range 0..255.\n\n\nExample\n#\n\n\n display.getBrightness(); //the current brightness \n\n\n\n\nrotateTo\n#\n\n\n\n\nvoid\n \nrotateTo\n( \nDisplayRotation\n position)\n#\n\n\nDescription\n#\n\n\nRotates the display to the given position.  \n\n\nAxis aligned values only.  \n\n\nParameters\n#\n\n\n\n\nDisplayRotation\n position\n\n\n\n\nExample\n#\n\n\n display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation \n\n\n\n\nenable\n#\n\n\n\n\nvoid\n \nenable\n()\n#\n\n\nDescription\n#\n\n\nEnables the display, should only be called if the display is disabled.  \n\n\nExample\n#\n\n\n display.enable(); //Enables the display mechanics \n\n\n\n\n\n\nNote\n\n\nOnly enables the display if the display is currently disabled. \n\n\n\n\ndisable\n#\n\n\n\n\nvoid\n \ndisable\n()\n#\n\n\nDescription\n#\n\n\nDisables the display, which releases control of the GPIO pins used by the display, which are exposed on the edge connector.  \n\n\nExample\n#\n\n\n display.disable(); //disables the display \n\n\n\n\n\n\nNote\n\n\nOnly disables the display if the display is currently enabled. \n\n\n\n\nclear\n#\n\n\n\n\nvoid\n \nclear\n()\n#\n\n\nDescription\n#\n\n\nClears the display of any remaining pixels.  \n\n\ndisplay.image.clear()  can also be used!  \n\n\nExample\n#\n\n\n display.clear(); //clears the display \n\n\n\n\nsetFont\n#\n\n\n\n\nvoid\n \nsetFont\n( \nMicroBitFont\n font)\n#\n\n\nDescription\n#\n\n\nUpdates the font that will be used for display operations.  \n\n\nParameters\n#\n\n\n\n\nMicroBitFont\n font - the new font that will be used to render characters.\n\n\n\n\n\n\nNote\n\n\nDEPRECATED! Please use  MicroBitFont::setSystemFont()  instead. \n\n\n\n\ngetFont\n#\n\n\n\n\nMicroBitFont\n \ngetFont\n()\n#\n\n\nDescription\n#\n\n\nRetrieves the font object used for rendering characters on the display.  \n\n\n\n\nNote\n\n\nDEPRECATED! Please use  MicroBitFont::getSystemFont()  instead. \n\n\n\n\nscreenShot\n#\n\n\n\n\nMicroBitImage\n \nscreenShot\n()\n#\n\n\nDescription\n#\n\n\nCaptures the bitmap currently being rendered on the display.  \n\n\nReturns\n#\n\n\na  MicroBitImage  containing the captured data. \n\n\nreadLightLevel\n#\n\n\n\n\nint\n \nreadLightLevel\n()\n#\n\n\nDescription\n#\n\n\nGives a representative figure of the light level in the current environment where are micro:bit is situated.  \n\n\nInternally, it constructs an instance of a  MicroBitLightSensor  if not already configured and sets the display mode to DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE.  \n\n\nThis also changes the tickPeriod to MICROBIT_LIGHT_SENSOR_TICK_SPEED so that the display does not suffer from artifacts.  \n\n\nReturns\n#\n\n\nan indicative light level in the range 0 - 255.\n\n\n\n\nNote\n\n\nthis will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time.",
            "title": "display"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#ubitdisplay",
            "text": "",
            "title": "uBit.display"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#overview",
            "text": "The MicroBitDisplay class is a general purpose device driver for controlling LED matrix displays.\nLED matrix displays are simple, inexpensive devices that use a single LED as a display pixel. They therefore\ntend to be of relatively low resolution, but often provide visually attractive displays due to the high coherence and brightness\nof the LEDs.  LEDs in matrix displays are connected to general purpose I/O (GPIO) pins on CPU. Although they  could  be connected such that each\nLED has its own GPIO pin, this is not usually the case, as the scarce resource of GPIO pins would soon be used up.  For example,\non the micro:bit, the LED matrix has 25 LEDs. If this required 25 GPIO pins, then there would be none left for anything else!  Instead, these LEDs are controlled by 12 GPIO pins. Three of those pins provide power to LEDs, the other\nnine provide a route to ground. The pins that source power are called  rows . The pins that sink power are called  columns .\nThe following diagram shows how the 5x5 grid is connected into 3 logical \u2018rows\u2019 and 9 \u2018columns\u2019:   Where the format is:  ROW . COLUMN  So, if we wanted to light up the middle LED, we would need to put a HIGH voltage (logic 1) on row 2, and a LOW voltage (logic 0) on column 3. Notice that when row 2 is\nHIGH, we the value we write to the 9 column pins affect all of the LEDs 2.1 to 2.7, without affecting any of the LEDS on row 1 or row 3. Sharing GPIO pins in this way is known as multiplexing.\nMoreover, if we scan through the different rows fast enough - faster than the eye can see - then we can provide the illusion of all the LEDS being on at the same time! This is a technique\nknown as  persistence of vision \u2026 and was also the same basis of the very first TV sets (although that did not use LEDs!).",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#capabilities",
            "text": "The MicroBitDisplay class provides a driver for a general purpose matrix display, and also several high level features that make creating animations and visual effects on the\nmicro:bit LED display easy and fun! This class lets you:   Control the LED matrix on the micro:bit.  Use an optimised typeface (font) so you can show upper and lower case letters, numbers of symbols on the display.  Set Display wide or  per-pixel  brightness control up to 256 levels per pixel.  Create, move, paste and animate images.  Scroll and print images and text.  Access the screen buffer directly, so you can manipulate individual pixels.",
            "title": "Capabilities"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#using-the-display",
            "text": "When using the uBit object, the display is automatically set up, and ready for you to use. Use any or all of the functions listed in the API section below to create effects on the\nLED display. Here are a few examples to get you started though!",
            "title": "Using the Display"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#scrolling-text",
            "text": "Simply use the scroll function to specify the message you want to scroll, and sit back and watch the result. The message you provide will be scrolled, pixel by pixel across the display from right to left.\nIf you take a look at the documentation for the scroll function in the API below, you will notice that you can also specify the speed of the scroll as an optional final parameter. The lower the delay, the\nfaster your text will scroll across the screen.  uBit.display.scroll(\"HELLO!\");\nuBit.display.scroll(\"HELLO!\", 100);  Notice that you can also scroll numbers (either constants of variables):  int c = 42;\nuBit.display.scroll(c);",
            "title": "Scrolling Text"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#printing-text",
            "text": "Sometimes it is better to show the letters/numbers in turn on the screen rather than scrolling them. If you want to do this, the \u2018print\u2019 function has exactly the same parameters as \u2018scroll\u2019, but\nwith this behaviour.  e.g.  uBit.display.print(\"HELLO!\");\nuBit.display.print(\"HELLO!\", 100);\nuBit.display.print(42);  Do notice that print behaves slightly differently if you provide a single character or numeric digit though. if you do this, the value you provide will stay on the screen until you explicitly\nchange the screen. If you ask the runtime to print a string with two or more characters, then each will appear in turn, then disappear. e.g. try this and you will find it stays on the screen:  uBit.display.print(7);",
            "title": "Printing Text"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#showing-images",
            "text": "It is also possible to print and scroll bitmap images on the display. Images are represented in the runtime by using a  MicroBitImage . These can easily be created, just as\nyou create any variable. Once created, you can then provide them as a parameter to the scroll and print functions. Unlike the text based animation functions, you can also specify exactly\nwhere in the screen you would like the image to appear - and you can even treat pixel values of zero as transparent if you like!\nSee the  MicroBitImage page  for more details on images, but here are a few simple examples:  // show your smiley on the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.print(smiley);  // make your smiley peep up from the bottom of the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nfor (int y=4; y >= 0; y--)\n{\n    uBit.display.image.paste(smiley,0,y);\n    uBit.sleep(500);\n}  // scroll your smiley across the screen...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.scroll(smiley);",
            "title": "Showing Images"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#running-in-the-background",
            "text": "By now you have probably noticed that the scroll, print and animate functions all wait for the effect requested to finishes before returning. This is by design, to allow you to easily synchronise your programs.\nHowever, sometimes you want to launch an effect, and let it run in the background while your program does something else. For this, you can use the  Async  variations of the scroll, print and animate functions.\nThese all have identical parameters and capabilities, but will return immediately. Try some of the examples above with their Async equivalents to understand this different behaviour.  For example:  // scroll your smiley across the screen, without waiting for it to finish...\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\");\nuBit.display.scrollAsync(smiley);",
            "title": "Running in the Background..."
        },
        {
            "location": "/lancaster-mbed/ubit/display/#changing-display-mode",
            "text": "The MicroBitDisplay class supports either on/off LED display, or displays where each pixel has an individual brightness value between 0 and 255. The former costs much less processor time and battery power to\noperate, so it is the default. The latter does provide more useful effects though, so you can change between these modes by using the  \u2018setDiplayMode\u2019 function. Valid values are:     Display mode  Brief Description      DISPLAY_MODE_BLACK_AND_WHITE  Each pixel can be just on or off. The brightness of all pixels is controlled by the setBrightness function.    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE  Each pixel can be just on or off, and the display driver will also sense the ambient brightness from the LEDs.    DISPLAY_MODE_GREYSCALE  Each pixel can independently have 256 levels of brightness.     for example:  // show a smiley with bright eyes!\nMicroBitImage smiley(\"0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n32,0,0,0,32\\n0,32,32,32,0\\n\");\nuBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE);\nuBit.display.print(smiley);",
            "title": "Changing Display Mode"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#accessing-the-display-buffer",
            "text": "The memory buffer that is used to drive the LEDs is itself a  MicroBitImage . This means that you can also access and call any of the functions listed in the  MicroBitImage API documentation \ndirectly on the display buffer. Examples here include setPixelValue, as illustrated below, but read the above documentation link for full details.  // set a single pixel by co-ordinate\nuBit.display.image.setPixelValue(2,2,255);",
            "title": "Accessing the Display Buffer"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#other-useful-functions",
            "text": "\u2018clear\u2019 will clear the screen immediately.  \u2018stopAnimation\u2019 will terminate any on-going print, scroll or animate functions.  \u2018setBrightness\u2019 lets you set the overall maximum brightness of the display, as a value between 1 and 255.  \u2018enable\u2019 and \u2018disable\u2019 turn on and off the display. When disabled, you can reuse many if the GPIO pins. See the  MicroBitIO  class for more information.  \u2018rotateTo\u2019 even lets you specify the orientation of the display - in case you need to use your micro:bit the wrong way up. :-)  \u2018readLightLevel\u2019 runs the LEDs backwards as photodiodes and tells you how bright your room is\u2026 see  Light Sensing  for more info!",
            "title": "Other Useful Functions"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_DISPLAY  6",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#message-bus-events",
            "text": "Constant  Value      MICROBIT_DISPLAY_EVT_ANIMATION_COMPLETE  1    MICROBIT_DISPLAY_EVT_LIGHT_SENSE  2",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#notify-events",
            "text": "These events use the notification channel  MICROBIT_ID_NOTIFY , which provides\ngeneral purpose synchronisation.     Constant  Value      MICROBIT_DISPLAY_EVT_FREE  1",
            "title": "Notify Events"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#microbitdisplay",
            "text": "",
            "title": "MicroBitDisplay()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description",
            "text": "Constructor.    Create a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example",
            "text": "MicroBitDisplay display;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#microbitdisplay-uint16_t-id",
            "text": "",
            "title": "MicroBitDisplay( uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_1",
            "text": "Constructor.    Create a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters",
            "text": "uint16_t  id - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_1",
            "text": "MicroBitDisplay display;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#microbitdisplay-uint16_t-id-const-matrixmap-map",
            "text": "",
            "title": "MicroBitDisplay( uint16_t id,  const  MatrixMap  &amp; map)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_2",
            "text": "Constructor.    Create a software representation the micro:bit\u2019s 5x5 LED matrix. The display is initially blank.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_1",
            "text": "uint16_t  id - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.  const  MatrixMap  &  map - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_2",
            "text": "MicroBitDisplay display;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#stopanimation",
            "text": "",
            "title": "stopAnimation"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-stopanimation",
            "text": "",
            "title": "void stopAnimation()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_3",
            "text": "Stops any currently running animation, and any that are waiting to be displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#printcharasync",
            "text": "",
            "title": "printCharAsync"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printcharasync-char-c",
            "text": "",
            "title": "int printCharAsync( char c)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_4",
            "text": "Prints the given character to the display, if it is not in use.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_2",
            "text": "char  c - The character to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns",
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_3",
            "text": "display.printAsync('p'); \n display.printAsync('p',100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printcharasync-char-c-int-delay",
            "text": "",
            "title": "int printCharAsync( char c,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_5",
            "text": "Prints the given character to the display, if it is not in use.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_3",
            "text": "char  c - The character to display.  int  delay - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_1",
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_4",
            "text": "display.printAsync('p'); \n display.printAsync('p',100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#printasync",
            "text": "",
            "title": "printAsync"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-managedstring-s",
            "text": "",
            "title": "int printAsync( ManagedString s)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_6",
            "text": "Prints the given  ManagedString  to the display, one character at a time. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_4",
            "text": "ManagedString  s - The string to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_2",
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_5",
            "text": "display.printAsync(\"abc123\",400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-managedstring-s-int-delay",
            "text": "",
            "title": "int printAsync( ManagedString s,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_7",
            "text": "Prints the given  ManagedString  to the display, one character at a time. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_5",
            "text": "ManagedString  s - The string to display.  int  delay - The time to delay between characters, in milliseconds. Must be > 0. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_3",
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_6",
            "text": "display.printAsync(\"abc123\",400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-microbitimage-i",
            "text": "",
            "title": "int printAsync( MicroBitImage i)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_8",
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_6",
            "text": "MicroBitImage  i - The image to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_7",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-microbitimage-i-int-x",
            "text": "",
            "title": "int printAsync( MicroBitImage i,  int x)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_9",
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_7",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_8",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-microbitimage-i-int-x-int-y",
            "text": "",
            "title": "int printAsync( MicroBitImage i,  int x,  int y)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_10",
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_8",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_9",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha",
            "text": "",
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_11",
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_9",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.  int  alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_10",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha-int-delay",
            "text": "",
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_12",
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_10",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.  int  alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.  int  delay - The time to delay between characters, in milliseconds. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_11",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#printchar",
            "text": "",
            "title": "printChar"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printchar-char-c",
            "text": "",
            "title": "int printChar( char c)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_13",
            "text": "Prints the given character to the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_11",
            "text": "char  c - The character to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_4",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_12",
            "text": "display.printAsync('p'); \n display.printAsync('p',100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-printchar-char-c-int-delay",
            "text": "",
            "title": "int printChar( char c,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_14",
            "text": "Prints the given character to the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_12",
            "text": "char  c - The character to display.  int  delay - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_5",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_13",
            "text": "display.printAsync('p'); \n display.printAsync('p',100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#print",
            "text": "",
            "title": "print"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-managedstring-s",
            "text": "",
            "title": "int print( ManagedString s)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_15",
            "text": "Prints the given string to the display, one character at a time.    Blocks the calling thread until all the text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_13",
            "text": "ManagedString  s - The string to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_6",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_14",
            "text": "display.print(\"abc123\",400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-managedstring-s-int-delay",
            "text": "",
            "title": "int print( ManagedString s,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_16",
            "text": "Prints the given string to the display, one character at a time.    Blocks the calling thread until all the text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_14",
            "text": "ManagedString  s - The string to display.  int  delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_7",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_15",
            "text": "display.print(\"abc123\",400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-microbitimage-i",
            "text": "",
            "title": "int print( MicroBitImage i)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_17",
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_15",
            "text": "MicroBitImage  i - The image to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_8",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_16",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-microbitimage-i-int-x",
            "text": "",
            "title": "int print( MicroBitImage i,  int x)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_18",
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_16",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_9",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_17",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-microbitimage-i-int-x-int-y",
            "text": "",
            "title": "int print( MicroBitImage i,  int x,  int y)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_19",
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_17",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_10",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_18",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha",
            "text": "",
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_20",
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_18",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.  int  alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_11",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_19",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha-int-delay",
            "text": "",
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_21",
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_19",
            "text": "MicroBitImage  i - The image to display.  int  x - The horizontal position on the screen to display the image. Defaults to 0.  int  y - The vertical position on the screen to display the image. Defaults to 0.  int  alpha - Treats the brightness level \u20180\u2019 as transparent. Defaults to 0.  int  delay - The time to display the image for, or zero to show the image forever. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_12",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_20",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.print(i,400);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#scrollasync",
            "text": "",
            "title": "scrollAsync"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scrollasync-managedstring-s",
            "text": "",
            "title": "int scrollAsync( ManagedString s)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_22",
            "text": "Scrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_20",
            "text": "ManagedString  s - The string to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_13",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_21",
            "text": "display.scrollAsync(\"abc123\",100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scrollasync-managedstring-s-int-delay",
            "text": "",
            "title": "int scrollAsync( ManagedString s,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_23",
            "text": "Scrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_21",
            "text": "ManagedString  s - The string to display.  int  delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_14",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_22",
            "text": "display.scrollAsync(\"abc123\",100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scrollasync-microbitimage-image",
            "text": "",
            "title": "int scrollAsync( MicroBitImage image)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_24",
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_22",
            "text": "MicroBitImage  image - The image to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_15",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_23",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scrollasync-microbitimage-image-int-delay",
            "text": "",
            "title": "int scrollAsync( MicroBitImage image,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_25",
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_23",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_16",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_24",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scrollasync-microbitimage-image-int-delay-int-stride",
            "text": "",
            "title": "int scrollAsync( MicroBitImage image,  int delay,  int stride)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_26",
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_24",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.  int  stride - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_17",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_25",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scrollAsync(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#scroll",
            "text": "",
            "title": "scroll"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scroll-managedstring-s",
            "text": "",
            "title": "int scroll( ManagedString s)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_27",
            "text": "Scrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_25",
            "text": "ManagedString  s - The string to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_18",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_26",
            "text": "display.scroll(\"abc123\",100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scroll-managedstring-s-int-delay",
            "text": "",
            "title": "int scroll( ManagedString s,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_28",
            "text": "Scrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_26",
            "text": "ManagedString  s - The string to display.  int  delay - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_19",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_27",
            "text": "display.scroll(\"abc123\",100);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scroll-microbitimage-image",
            "text": "",
            "title": "int scroll( MicroBitImage image)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_29",
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_27",
            "text": "MicroBitImage  image - The image to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_20",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_28",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scroll-microbitimage-image-int-delay",
            "text": "",
            "title": "int scroll( MicroBitImage image,  int delay)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_30",
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_28",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_21",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_29",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-scroll-microbitimage-image-int-delay-int-stride",
            "text": "",
            "title": "int scroll( MicroBitImage image,  int delay,  int stride)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_31",
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_29",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.  int  stride - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_22",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_30",
            "text": "MicrobitImage i(\"1,1,1,1,1\\n1,1,1,1,1\\n\"); \n display.scroll(i,100,1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#animateasync",
            "text": "",
            "title": "animateAsync"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride",
            "text": "",
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_32",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_30",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_23",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_31",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride-int-startingposition",
            "text": "",
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_33",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_31",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.  int  startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_24",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_32",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride-int-startingposition-int-autoclear",
            "text": "",
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride,  int startingPosition,  int autoClear)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_34",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_32",
            "text": "MicroBitImage  image - The image to display.  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.  int  startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.  int  autoClear - defines whether or not the display is automatically cleared once the animation is complete. By default, the display is cleared. Set this parameter to zero to disable the autoClear operation.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_25",
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_33",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#animate",
            "text": "",
            "title": "animate"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride",
            "text": "",
            "title": "int animate( MicroBitImage image,  int delay,  int stride)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_35",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_33",
            "text": "MicroBitImage  image  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_26",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_34",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride-int-startingposition",
            "text": "",
            "title": "int animate( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_36",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_34",
            "text": "MicroBitImage  image  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.  int  startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_27",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_35",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride-int-startingposition-int-autoclear",
            "text": "",
            "title": "int animate( MicroBitImage image,  int delay,  int stride,  int startingPosition,  int autoClear)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_37",
            "text": "\u201cAnimates\u201d the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_35",
            "text": "MicroBitImage  image  int  delay - The time to delay between each update of the display, in milliseconds.  int  stride - The number of pixels to shift by in each update.  int  startingPosition - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.  int  autoClear - defines whether or not the display is automatically cleared once the animation is complete. By default, the display is cleared. Set this parameter to zero to disable the autoClear operation.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_28",
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_36",
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#setbrightness",
            "text": "",
            "title": "setBrightness"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-setbrightness-int-b",
            "text": "",
            "title": "int setBrightness( int b)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_38",
            "text": "Configures the brightness of the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_36",
            "text": "int  b - The brightness to set the brightness to, in the range 0 - 255.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_29",
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_37",
            "text": "display.setBrightness(255); //max brightness",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#setdisplaymode",
            "text": "",
            "title": "setDisplayMode"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-setdisplaymode-displaymode-mode",
            "text": "",
            "title": "void setDisplayMode( DisplayMode mode)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_39",
            "text": "Configures the mode of the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_37",
            "text": "DisplayMode  mode - The mode to swap the display into. One of: DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_38",
            "text": "display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#getdisplaymode",
            "text": "",
            "title": "getDisplayMode"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-getdisplaymode",
            "text": "",
            "title": "int getDisplayMode()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_40",
            "text": "Retrieves the mode of the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_30",
            "text": "the current mode of the display",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#getbrightness",
            "text": "",
            "title": "getBrightness"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-getbrightness",
            "text": "",
            "title": "int getBrightness()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_41",
            "text": "Fetches the current brightness of this display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_31",
            "text": "the brightness of this display, in the range 0..255.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_39",
            "text": "display.getBrightness(); //the current brightness",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#rotateto",
            "text": "",
            "title": "rotateTo"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-rotateto-displayrotation-position",
            "text": "",
            "title": "void rotateTo( DisplayRotation position)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_42",
            "text": "Rotates the display to the given position.    Axis aligned values only.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_38",
            "text": "DisplayRotation  position",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_40",
            "text": "display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#enable",
            "text": "",
            "title": "enable"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-enable",
            "text": "",
            "title": "void enable()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_43",
            "text": "Enables the display, should only be called if the display is disabled.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_41",
            "text": "display.enable(); //Enables the display mechanics    Note  Only enables the display if the display is currently disabled.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#disable",
            "text": "",
            "title": "disable"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-disable",
            "text": "",
            "title": "void disable()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_44",
            "text": "Disables the display, which releases control of the GPIO pins used by the display, which are exposed on the edge connector.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_42",
            "text": "display.disable(); //disables the display    Note  Only disables the display if the display is currently enabled.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#clear",
            "text": "",
            "title": "clear"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-clear",
            "text": "",
            "title": "void clear()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_45",
            "text": "Clears the display of any remaining pixels.    display.image.clear()  can also be used!",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#example_43",
            "text": "display.clear(); //clears the display",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#setfont",
            "text": "",
            "title": "setFont"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#void-setfont-microbitfont-font",
            "text": "",
            "title": "void setFont( MicroBitFont font)"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_46",
            "text": "Updates the font that will be used for display operations.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#parameters_39",
            "text": "MicroBitFont  font - the new font that will be used to render characters.    Note  DEPRECATED! Please use  MicroBitFont::setSystemFont()  instead.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#getfont",
            "text": "",
            "title": "getFont"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#microbitfont-getfont",
            "text": "",
            "title": "MicroBitFont getFont()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_47",
            "text": "Retrieves the font object used for rendering characters on the display.     Note  DEPRECATED! Please use  MicroBitFont::getSystemFont()  instead.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#screenshot",
            "text": "",
            "title": "screenShot"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#microbitimage-screenshot",
            "text": "",
            "title": "MicroBitImage screenShot()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_48",
            "text": "Captures the bitmap currently being rendered on the display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_32",
            "text": "a  MicroBitImage  containing the captured data.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#readlightlevel",
            "text": "",
            "title": "readLightLevel"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#int-readlightlevel",
            "text": "",
            "title": "int readLightLevel()"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#description_49",
            "text": "Gives a representative figure of the light level in the current environment where are micro:bit is situated.    Internally, it constructs an instance of a  MicroBitLightSensor  if not already configured and sets the display mode to DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE.    This also changes the tickPeriod to MICROBIT_LIGHT_SENSOR_TICK_SPEED so that the display does not suffer from artifacts.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/display/#returns_33",
            "text": "an indicative light level in the range 0 - 255.   Note  this will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/",
            "text": "uBit.accelerometer\n#\n\n\nOverview\n#\n\n\nOnboard the micro:bit is an accelerometer, and it is linked to the\n\ni2c\n bus which is used to read data from the accelerometer.\n\n\nThe accelerometer on the micro:bit detects the acceleration (\nin milli-g\n) in 3 planes: x and y\n(\nthe horizontal planes\n), and z (\nthe vertical plane\n).\n\n\nAs well as detecting acceleration, accelerometers can also detect orientation, which\nis used in smart phones and tablets to rotate content as you tilt the device. This means\nthat the micro:bit can infer its own orientation as well!\n\n\nAs well as being used to detect acceleration, accelerometers are also used to detect\nthe rate of deceleration. A great example of an application of accelerometers are\nairbags in modern vehicles, where an accelerometer is used to detect the rapid deceleration\nof a vehicle. If rapid deceleration were to occur, the airbags are deployed.\n\n\nAccelerometers can also be used to detect when an object is in free fall, which is\nwhen only the force gravity is acting upon an object. If you were to throw a ball directly\ninto the air, free fall would begin as soon as the ball begins its decent after the\nacceleration from your throw has subsided.\n\n\nThe micro:bit uses the \nMMA8653\n.\n\n\nReal time updates\n#\n\n\nWhen using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform..\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n\ncalls. Additionally, if you would like to drive accelerometer updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_ACCELEROMETER\n\n\n4\n\n\n\n\n\n\nMICROBIT_ID_GESTURE\n\n\n27\n\n\n\n\n\n\n\n\nMessage Bus Events:\n#\n\n\nMICROBIT_ID_ACCELEROMETER\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_DATA_UPDATE\n\n\n1\n\n\n\n\n\n\n\n\nMICROBIT_ID_GESTURE\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_UP\n\n\n1\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_DOWN\n\n\n2\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_LEFT\n\n\n3\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_RIGHT\n\n\n4\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_UP\n\n\n5\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_DOWN\n\n\n6\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FREEFALL\n\n\n7\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_3G\n\n\n8\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_6G\n\n\n9\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_8G\n\n\n10\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_SHAKE\n\n\n11\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  &\n _i2c)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software abstraction of an accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  &\n _i2c,  \nuint16_t\n address)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software abstraction of an accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\nuint16_t\n address - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  &\n _i2c,  \nuint16_t\n address,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software abstraction of an accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\nuint16_t\n address - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.\n\n\nuint16_t\n id - the unique  EventModel  id of this component. Defaults to: MICROBIT_ID_ACCELEROMETER\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\nconfigure\n#\n\n\n\n\nint\n \nconfigure\n()\n#\n\n\nDescription\n#\n\n\nConfigures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured. \n\n\nupdateSample\n#\n\n\n\n\nint\n \nupdateSample\n()\n#\n\n\nDescription\n#\n\n\nReads the acceleration data from the accelerometer, and stores it in our buffer. This only happens if the accelerometer indicates that it has new data via int1.  \n\n\nOn first use, this member function will attempt to add this component to the list of fiber components in order to constantly update the values stored by this object.  \n\n\nThis technique is called lazy instantiation, and it means that we do not obtain the overhead from non-chalantly adding this component to fiber components.  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if the read request fails. \n\n\nsetPeriod\n#\n\n\n\n\nint\n \nsetPeriod\n( \nint\n period)\n#\n\n\nDescription\n#\n\n\nAttempts to set the sample rate of the accelerometer to the specified value (in ms).  \n\n\nParameters\n#\n\n\n\n\nint\n period - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\nExample\n#\n\n\n // sample rate is now 20 ms. \n accelerometer.setPeriod(20); \n\n\n\n\n\n\nNote\n\n\nThe requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen. \n\n\n\n\ngetPeriod\n#\n\n\n\n\nint\n \ngetPeriod\n()\n#\n\n\nDescription\n#\n\n\nReads the currently configured sample rate of the accelerometer.  \n\n\nReturns\n#\n\n\nThe time between samples, in milliseconds. \n\n\nsetRange\n#\n\n\n\n\nint\n \nsetRange\n( \nint\n range)\n#\n\n\nDescription\n#\n\n\nAttempts to set the sample range of the accelerometer to the specified value (in g).  \n\n\nParameters\n#\n\n\n\n\nint\n range - The requested sample range of samples, in g.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\nExample\n#\n\n\n // the sample range of the accelerometer is now 8G. \n accelerometer.setRange(8); \n\n\n\n\n\n\nNote\n\n\nThe requested range may not be possible on the hardware. In this case, the nearest lower range is chosen. \n\n\n\n\ngetRange\n#\n\n\n\n\nint\n \ngetRange\n()\n#\n\n\nDescription\n#\n\n\nReads the currently configured sample range of the accelerometer.  \n\n\nReturns\n#\n\n\nThe sample range, in g. \n\n\nwhoAmI\n#\n\n\n\n\nint\n \nwhoAmI\n()\n#\n\n\nDescription\n#\n\n\nAttempts to read the 8 bit ID from the accelerometer, this can be used for validation purposes.  \n\n\nReturns\n#\n\n\nthe 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.\n\n\nExample\n#\n\n\n accelerometer.whoAmI(); \n\n\n\n\ngetX\n#\n\n\n\n\nint\n \ngetX\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the X axis from the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getX(); \n\n\n\n\n\n\nint\n \ngetX\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the X axis from the latest update retrieved from the accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n#\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getX(); \n\n\n\n\ngetY\n#\n\n\n\n\nint\n \ngetY\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the Y axis from the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getY(); \n\n\n\n\n\n\nint\n \ngetY\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the Y axis from the latest update retrieved from the accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system\n\n\n\n\nReturns\n#\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getY(); \n\n\n\n\ngetZ\n#\n\n\n\n\nint\n \ngetZ\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the Z axis from the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getZ(); \n\n\n\n\n\n\nint\n \ngetZ\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the Z axis from the latest update retrieved from the accelerometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system\n\n\n\n\nReturns\n#\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n#\n\n\n accelerometer.getZ(); \n\n\n\n\ngetPitch\n#\n\n\n\n\nint\n \ngetPitch\n()\n#\n\n\nDescription\n#\n\n\nProvides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe pitch of the device, in degrees.\n\n\nExample\n#\n\n\n accelerometer.getPitch(); \n\n\n\n\ngetPitchRadians\n#\n\n\n\n\nfloat\n \ngetPitchRadians\n()\n#\n\n\nDescription\n#\n\n\nProvides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe pitch of the device, in radians.\n\n\nExample\n#\n\n\n accelerometer.getPitchRadians(); \n\n\n\n\ngetRoll\n#\n\n\n\n\nint\n \ngetRoll\n()\n#\n\n\nDescription\n#\n\n\nProvides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe roll of the device, in degrees.\n\n\nExample\n#\n\n\n accelerometer.getRoll(); \n\n\n\n\ngetRollRadians\n#\n\n\n\n\nfloat\n \ngetRollRadians\n()\n#\n\n\nDescription\n#\n\n\nProvides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.  \n\n\nReturns\n#\n\n\nThe roll of the device, in radians.\n\n\nExample\n#\n\n\n accelerometer.getRollRadians(); \n\n\n\n\ngetGesture\n#\n\n\n\n\nuint16_t\n \ngetGesture\n()\n#\n\n\nDescription\n#\n\n\nRetrieves the last recorded gesture.  \n\n\nReturns\n#\n\n\nThe last gesture that was detected.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n\n if (accelerometer.getGesture() == SHAKE) \n display.scroll(\"SHAKE!\");",
            "title": "accelerometer"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#ubitaccelerometer",
            "text": "",
            "title": "uBit.accelerometer"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#overview",
            "text": "Onboard the micro:bit is an accelerometer, and it is linked to the i2c  bus which is used to read data from the accelerometer.  The accelerometer on the micro:bit detects the acceleration ( in milli-g ) in 3 planes: x and y\n( the horizontal planes ), and z ( the vertical plane ).  As well as detecting acceleration, accelerometers can also detect orientation, which\nis used in smart phones and tablets to rotate content as you tilt the device. This means\nthat the micro:bit can infer its own orientation as well!  As well as being used to detect acceleration, accelerometers are also used to detect\nthe rate of deceleration. A great example of an application of accelerometers are\nairbags in modern vehicles, where an accelerometer is used to detect the rapid deceleration\nof a vehicle. If rapid deceleration were to occur, the airbags are deployed.  Accelerometers can also be used to detect when an object is in free fall, which is\nwhen only the force gravity is acting upon an object. If you were to throw a ball directly\ninto the air, free fall would begin as soon as the ball begins its decent after the\nacceleration from your throw has subsided.  The micro:bit uses the  MMA8653 .",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#real-time-updates",
            "text": "When using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform..  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]() \ncalls. Additionally, if you would like to drive accelerometer updates manually  updateSample() \ncan be used.",
            "title": "Real time updates"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_ACCELEROMETER  4    MICROBIT_ID_GESTURE  27",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#message-bus-events",
            "text": "",
            "title": "Message Bus Events:"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#microbit_id_accelerometer",
            "text": "Constant  Value      MICROBIT_ACCELEROMETER_EVT_DATA_UPDATE  1",
            "title": "MICROBIT_ID_ACCELEROMETER"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#microbit_id_gesture",
            "text": "Constant  Value      MICROBIT_ACCELEROMETER_EVT_TILT_UP  1    MICROBIT_ACCELEROMETER_EVT_TILT_DOWN  2    MICROBIT_ACCELEROMETER_EVT_TILT_LEFT  3    MICROBIT_ACCELEROMETER_EVT_TILT_RIGHT  4    MICROBIT_ACCELEROMETER_EVT_FACE_UP  5    MICROBIT_ACCELEROMETER_EVT_FACE_DOWN  6    MICROBIT_ACCELEROMETER_EVT_FREEFALL  7    MICROBIT_ACCELEROMETER_EVT_3G  8    MICROBIT_ACCELEROMETER_EVT_6G  9    MICROBIT_ACCELEROMETER_EVT_8G  10    MICROBIT_ACCELEROMETER_EVT_SHAKE  11",
            "title": "MICROBIT_ID_GESTURE"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c",
            "text": "",
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description",
            "text": "Constructor. Create a software abstraction of an accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters",
            "text": "MicroBitI2C  &  _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example",
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c-uint16_t-address",
            "text": "",
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c,  uint16_t address)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_1",
            "text": "Constructor. Create a software abstraction of an accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_1",
            "text": "MicroBitI2C  &  _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.  uint16_t  address - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_1",
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c-uint16_t-address-uint16_t-id",
            "text": "",
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c,  uint16_t address,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_2",
            "text": "Constructor. Create a software abstraction of an accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_2",
            "text": "MicroBitI2C  &  _i2c - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.  uint16_t  address - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.  uint16_t  id - the unique  EventModel  id of this component. Defaults to: MICROBIT_ID_ACCELEROMETER",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_2",
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#configure",
            "text": "",
            "title": "configure"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-configure",
            "text": "",
            "title": "int configure()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_3",
            "text": "Configures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#updatesample",
            "text": "",
            "title": "updateSample"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-updatesample",
            "text": "",
            "title": "int updateSample()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_4",
            "text": "Reads the acceleration data from the accelerometer, and stores it in our buffer. This only happens if the accelerometer indicates that it has new data via int1.    On first use, this member function will attempt to add this component to the list of fiber components in order to constantly update the values stored by this object.    This technique is called lazy instantiation, and it means that we do not obtain the overhead from non-chalantly adding this component to fiber components.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_1",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if the read request fails.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#setperiod",
            "text": "",
            "title": "setPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-setperiod-int-period",
            "text": "",
            "title": "int setPeriod( int period)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_5",
            "text": "Attempts to set the sample rate of the accelerometer to the specified value (in ms).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_3",
            "text": "int  period - the requested time between samples, in milliseconds.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_2",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_3",
            "text": "// sample rate is now 20 ms. \n accelerometer.setPeriod(20);    Note  The requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getperiod",
            "text": "",
            "title": "getPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getperiod",
            "text": "",
            "title": "int getPeriod()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_6",
            "text": "Reads the currently configured sample rate of the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_3",
            "text": "The time between samples, in milliseconds.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#setrange",
            "text": "",
            "title": "setRange"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-setrange-int-range",
            "text": "",
            "title": "int setRange( int range)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_7",
            "text": "Attempts to set the sample range of the accelerometer to the specified value (in g).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_4",
            "text": "int  range - The requested sample range of samples, in g.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_4",
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_4",
            "text": "// the sample range of the accelerometer is now 8G. \n accelerometer.setRange(8);    Note  The requested range may not be possible on the hardware. In this case, the nearest lower range is chosen.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getrange",
            "text": "",
            "title": "getRange"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getrange",
            "text": "",
            "title": "int getRange()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_8",
            "text": "Reads the currently configured sample range of the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_5",
            "text": "The sample range, in g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#whoami",
            "text": "",
            "title": "whoAmI"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-whoami",
            "text": "",
            "title": "int whoAmI()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_9",
            "text": "Attempts to read the 8 bit ID from the accelerometer, this can be used for validation purposes.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_6",
            "text": "the 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_5",
            "text": "accelerometer.whoAmI();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getx",
            "text": "",
            "title": "getX"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getx",
            "text": "",
            "title": "int getX()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_10",
            "text": "Reads the value of the X axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_7",
            "text": "The force measured in the X axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_6",
            "text": "accelerometer.getX();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getx-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getX( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_11",
            "text": "Reads the value of the X axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_5",
            "text": "MicroBitCoordinateSystem  system - The coordinate system to use. By default, a simple cartesian system is provided.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_8",
            "text": "The force measured in the X axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_7",
            "text": "accelerometer.getX();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#gety",
            "text": "",
            "title": "getY"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-gety",
            "text": "",
            "title": "int getY()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_12",
            "text": "Reads the value of the Y axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_9",
            "text": "The force measured in the Y axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_8",
            "text": "accelerometer.getY();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-gety-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getY( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_13",
            "text": "Reads the value of the Y axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_6",
            "text": "MicroBitCoordinateSystem  system",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_10",
            "text": "The force measured in the Y axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_9",
            "text": "accelerometer.getY();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getz",
            "text": "",
            "title": "getZ"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getz",
            "text": "",
            "title": "int getZ()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_14",
            "text": "Reads the value of the Z axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_11",
            "text": "The force measured in the Z axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_10",
            "text": "accelerometer.getZ();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getz-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getZ( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_15",
            "text": "Reads the value of the Z axis from the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#parameters_7",
            "text": "MicroBitCoordinateSystem  system",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_12",
            "text": "The force measured in the Z axis, in milli-g.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_11",
            "text": "accelerometer.getZ();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getpitch",
            "text": "",
            "title": "getPitch"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getpitch",
            "text": "",
            "title": "int getPitch()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_16",
            "text": "Provides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_13",
            "text": "The pitch of the device, in degrees.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_12",
            "text": "accelerometer.getPitch();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getpitchradians",
            "text": "",
            "title": "getPitchRadians"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#float-getpitchradians",
            "text": "",
            "title": "float getPitchRadians()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_17",
            "text": "Provides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_14",
            "text": "The pitch of the device, in radians.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_13",
            "text": "accelerometer.getPitchRadians();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getroll",
            "text": "",
            "title": "getRoll"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#int-getroll",
            "text": "",
            "title": "int getRoll()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_18",
            "text": "Provides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_15",
            "text": "The roll of the device, in degrees.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_14",
            "text": "accelerometer.getRoll();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getrollradians",
            "text": "",
            "title": "getRollRadians"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#float-getrollradians",
            "text": "",
            "title": "float getRollRadians()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_19",
            "text": "Provides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_16",
            "text": "The roll of the device, in radians.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_15",
            "text": "accelerometer.getRollRadians();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#getgesture",
            "text": "",
            "title": "getGesture"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#uint16_t-getgesture",
            "text": "",
            "title": "uint16_t getGesture()"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#description_20",
            "text": "Retrieves the last recorded gesture.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#returns_17",
            "text": "The last gesture that was detected.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/accelerometer/#example_16",
            "text": "MicroBitDisplay display; \n\n if (accelerometer.getGesture() == SHAKE) \n display.scroll(\"SHAKE!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/",
            "text": "uBit.compass\n#\n\n\nOverview\n#\n\n\nOnboard the micro:bit is an electronic magnetometer. Like the \naccelerometer\n, the\n\nmagnetometer is linked to the \ni2c\n bus, which is used to access data\non the magnetometer.\n\n\nThe magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.\n\n\nRaw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the \naccelerometer\n is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.\n\n\nThe magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.\n\n\nAfter calibration has been performed, the end product is an e-compass!\n\n\nThe micro:bit uses the NXP \nMAG3110\n.\n\n\nReal time updates\n#\n\n\nWhen using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n and \nheading()\n\ncalls. Additionally, if you would like to drive compass updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_COMPASS\n\n\n5\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_REQUIRED\n\n\n1 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_START\n\n\n2 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_END\n\n\n3 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_DATA_UPDATE\n\n\n4\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CONFIG_NEEDED\n\n\n5\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CALIBRATE\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer,  \nMicroBitStorage  &\n _storage)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer,  \nMicroBitStorage  &\n _storage,  \nuint16_t\n address)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer,  \nMicroBitStorage  &\n _storage,  \nuint16_t\n address,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer,  \nuint16_t\n address)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitAccelerometer  &\n _accelerometer,  \nuint16_t\n address,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  &\n _accelerometer - an instance of the accelerometer, used for tilt compensation.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitStorage  &\n _storage)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitStorage  &\n _storage,  \nuint16_t\n address)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nMicroBitStorage  &\n _storage,  \nuint16_t\n address,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nuint16_t\n address)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  &\n _i2c,  \nuint16_t\n address,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a software representation of an e-compass.  \n\n\nParameters\n#\n\n\n\n\nMicroBitI2C  &\n _i2c - an instance of i2c, which the compass is accessible from.\n\n\nuint16_t\n address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n#\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\nconfigure\n#\n\n\n\n\nint\n \nconfigure\n()\n#\n\n\nDescription\n#\n\n\nConfigures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.  \n\n\nReturns\n#\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured. \n\n\nsetPeriod\n#\n\n\n\n\nint\n \nsetPeriod\n( \nint\n period)\n#\n\n\nDescription\n#\n\n\nAttempts to set the sample rate of the compass to the specified value (in ms).  \n\n\nParameters\n#\n\n\n\n\nint\n period - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.\n\n\nExample\n#\n\n\n // sample rate is now 20 ms. \n compass.setPeriod(20); \n\n\n\n\n\n\nNote\n\n\nThe requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen. \n\n\n\n\ngetPeriod\n#\n\n\n\n\nint\n \ngetPeriod\n()\n#\n\n\nDescription\n#\n\n\nReads the currently configured sample rate of the compass.  \n\n\nReturns\n#\n\n\nThe time between samples, in milliseconds. \n\n\nheading\n#\n\n\n\n\nint\n \nheading\n()\n#\n\n\nDescription\n#\n\n\nGets the current heading of the device, relative to magnetic north.  \n\n\nIf the compass is not calibrated, it will raise the MICROBIT_COMPASS_EVT_CALIBRATE event.  \n\n\nUsers wishing to implement their own calibration algorithms should listen for this event, using MESSAGE_BUS_LISTENER_IMMEDIATE model. This ensures that calibration is complete before the user program continues.  \n\n\nReturns\n#\n\n\nthe current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.\n\n\nExample\n#\n\n\n compass.heading(); \n\n\n\n\nwhoAmI\n#\n\n\n\n\nint\n \nwhoAmI\n()\n#\n\n\nDescription\n#\n\n\nAttempts to read the 8 bit ID from the magnetometer, this can be used for validation purposes.  \n\n\nReturns\n#\n\n\nthe 8 bit ID returned by the magnetometer, or MICROBIT_I2C_ERROR if the request fails.\n\n\nExample\n#\n\n\n compass.whoAmI(); \n\n\n\n\ngetX\n#\n\n\n\n\nint\n \ngetX\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the X axis from the latest update retrieved from the magnetometer.  \n\n\nReturns\n#\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getX(); \n\n\n\n\n\n\nint\n \ngetX\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the X axis from the latest update retrieved from the magnetometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n#\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getX(); \n\n\n\n\ngetY\n#\n\n\n\n\nint\n \ngetY\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the Y axis from the latest update retrieved from the magnetometer.  \n\n\nReturns\n#\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getY(); \n\n\n\n\n\n\nint\n \ngetY\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the Y axis from the latest update retrieved from the magnetometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n#\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getY(); \n\n\n\n\ngetZ\n#\n\n\n\n\nint\n \ngetZ\n()\n#\n\n\nDescription\n#\n\n\nReads the value of the Z axis from the latest update retrieved from the magnetometer.  \n\n\nReturns\n#\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getZ(); \n\n\n\n\n\n\nint\n \ngetZ\n( \nMicroBitCoordinateSystem\n system)\n#\n\n\nDescription\n#\n\n\nReads the value of the Z axis from the latest update retrieved from the magnetometer.  \n\n\nParameters\n#\n\n\n\n\nMicroBitCoordinateSystem\n system - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n#\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getZ(); \n\n\n\n\ngetFieldStrength\n#\n\n\n\n\nint\n \ngetFieldStrength\n()\n#\n\n\nDescription\n#\n\n\nDetermines the overall magnetic field strength based on the latest update from the magnetometer.  \n\n\nReturns\n#\n\n\nThe magnetic force measured across all axis, in nano teslas.\n\n\nExample\n#\n\n\n compass.getFieldStrength(); \n\n\n\n\nreadTemperature\n#\n\n\n\n\nint\n \nreadTemperature\n()\n#\n\n\nDescription\n#\n\n\nReads the current die temperature of the compass.  \n\n\nReturns\n#\n\n\nthe temperature in degrees celsius, or MICROBIT_I2C_ERROR if the temperature reading could not be retreived from the accelerometer. \n\n\ncalibrate\n#\n\n\n\n\nint\n \ncalibrate\n()\n#\n\n\nDescription\n#\n\n\nPerform a calibration of the compass.  \n\n\nThis method will be called automatically if a user attempts to read a compass value when the compass is uncalibrated. It can also be called at any time by the user.  \n\n\nThe method will only return once the compass has been calibrated.  \n\n\nReturns\n#\n\n\nMICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete successfully.\n\n\n\n\nNote\n\n\nTHIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS \n\n\n\n\nsetCalibration\n#\n\n\n\n\nvoid\n \nsetCalibration\n( \nCompassSample\n calibration)\n#\n\n\nDescription\n#\n\n\nConfigure the compass to use the calibration data that is supplied to this call.  \n\n\nCalibration data is comprised of the perceived zero offset of each axis of the compass.  \n\n\nAfter calibration this should now take into account trimming errors in the magnetometer, and any \u201chard iron\u201d offsets on the device.  \n\n\ncalibration \n\n\nA  CompassSample  containing the offsets for the x, y and z axis.   \n\n\nParameters\n#\n\n\n\n\nCompassSample\n calibration - A  CompassSample  containing the offsets for the x, y and z axis. \n\n\n\n\ngetCalibration\n#\n\n\n\n\nCompassSample\n \ngetCalibration\n()\n#\n\n\nDescription\n#\n\n\nProvides the calibration data currently in use by the compass.  \n\n\nMore specifically, the x, y and z zero offsets of the compass.  \n\n\nReturns\n#\n\n\ncalibration A  CompassSample  containing the offsets for the x, y and z axis. \n\n\nupdateSample\n#\n\n\n\n\nint\n \nupdateSample\n()\n#\n\n\nDescription\n#\n\n\nUpdates the local sample, only if the compass indicates that data is stale.  \n\n\n\n\nNote\n\n\nCan be used to trigger manual updates, if the device is running without a scheduler. Also called internally by all get\nX,Y,Z\n member functions. \n\n\n\n\nisCalibrated\n#\n\n\n\n\nint\n \nisCalibrated\n()\n#\n\n\nDescription\n#\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration.           \n\n\nisCalibrating\n#\n\n\n\n\nint\n \nisCalibrating\n()\n#\n\n\nDescription\n#\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating.           \n\n\nclearCalibration\n#\n\n\n\n\nvoid\n \nclearCalibration\n()\n#\n\n\nDescription\n#\n\n\nClears the calibration held in persistent storage, and sets the calibrated flag to zero.",
            "title": "compass"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#ubitcompass",
            "text": "",
            "title": "uBit.compass"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#overview",
            "text": "Onboard the micro:bit is an electronic magnetometer. Like the  accelerometer , the \nmagnetometer is linked to the  i2c  bus, which is used to access data\non the magnetometer.  The magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.  Raw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the  accelerometer  is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.  The magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.  After calibration has been performed, the end product is an e-compass!  The micro:bit uses the NXP  MAG3110 .",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#real-time-updates",
            "text": "When using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]()  and  heading() \ncalls. Additionally, if you would like to drive compass updates manually  updateSample() \ncan be used.",
            "title": "Real time updates"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_COMPASS  5",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#message-bus-events",
            "text": "Constant  Value      MICROBIT_COMPASS_EVT_CAL_REQUIRED  1  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_START  2  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_END  3  (DEPRECATED)    MICROBIT_COMPASS_EVT_DATA_UPDATE  4    MICROBIT_COMPASS_EVT_CONFIG_NEEDED  5    MICROBIT_COMPASS_EVT_CALIBRATE  6",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage-uint16_t-address",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage,  uint16_t address)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_1",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_1",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_1",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage-uint16_t-address-uint16_t-id",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage,  uint16_t address,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_2",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_2",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t  id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_2",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_3",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_3",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_3",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-uint16_t-address",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  uint16_t address)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_4",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_4",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_4",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-uint16_t-address-uint16_t-id",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  uint16_t address,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_5",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_5",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer  &  _accelerometer - an instance of the accelerometer, used for tilt compensation.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t  id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_5",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_6",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_6",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_6",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage-uint16_t-address",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage,  uint16_t address)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_7",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_7",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_7",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage-uint16_t-address-uint16_t-id",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage,  uint16_t address,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_8",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_8",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  MicroBitStorage  &  _storage - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t  id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_8",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_9",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_9",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_9",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-uint16_t-address",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  uint16_t address)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_10",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_10",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_10",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#microbitcompass-microbiti2c-_i2c-uint16_t-address-uint16_t-id",
            "text": "",
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  uint16_t address,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_11",
            "text": "Constructor. Create a software representation of an e-compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_11",
            "text": "MicroBitI2C  &  _i2c - an instance of i2c, which the compass is accessible from.  uint16_t  address - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t  id - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_11",
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#configure",
            "text": "",
            "title": "configure"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-configure",
            "text": "",
            "title": "int configure()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_12",
            "text": "Configures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns",
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#setperiod",
            "text": "",
            "title": "setPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-setperiod-int-period",
            "text": "",
            "title": "int setPeriod( int period)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_13",
            "text": "Attempts to set the sample rate of the compass to the specified value (in ms).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_12",
            "text": "int  period - the requested time between samples, in milliseconds.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_1",
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_12",
            "text": "// sample rate is now 20 ms. \n compass.setPeriod(20);    Note  The requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#getperiod",
            "text": "",
            "title": "getPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getperiod",
            "text": "",
            "title": "int getPeriod()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_14",
            "text": "Reads the currently configured sample rate of the compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_2",
            "text": "The time between samples, in milliseconds.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#heading",
            "text": "",
            "title": "heading"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-heading",
            "text": "",
            "title": "int heading()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_15",
            "text": "Gets the current heading of the device, relative to magnetic north.    If the compass is not calibrated, it will raise the MICROBIT_COMPASS_EVT_CALIBRATE event.    Users wishing to implement their own calibration algorithms should listen for this event, using MESSAGE_BUS_LISTENER_IMMEDIATE model. This ensures that calibration is complete before the user program continues.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_3",
            "text": "the current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_13",
            "text": "compass.heading();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#whoami",
            "text": "",
            "title": "whoAmI"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-whoami",
            "text": "",
            "title": "int whoAmI()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_16",
            "text": "Attempts to read the 8 bit ID from the magnetometer, this can be used for validation purposes.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_4",
            "text": "the 8 bit ID returned by the magnetometer, or MICROBIT_I2C_ERROR if the request fails.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_14",
            "text": "compass.whoAmI();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#getx",
            "text": "",
            "title": "getX"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getx",
            "text": "",
            "title": "int getX()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_17",
            "text": "Reads the value of the X axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_5",
            "text": "The magnetic force measured in the X axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_15",
            "text": "compass.getX();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getx-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getX( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_18",
            "text": "Reads the value of the X axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_13",
            "text": "MicroBitCoordinateSystem  system - The coordinate system to use. By default, a simple cartesian system is provided.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_6",
            "text": "The magnetic force measured in the X axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_16",
            "text": "compass.getX();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#gety",
            "text": "",
            "title": "getY"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-gety",
            "text": "",
            "title": "int getY()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_19",
            "text": "Reads the value of the Y axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_7",
            "text": "The magnetic force measured in the Y axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_17",
            "text": "compass.getY();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-gety-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getY( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_20",
            "text": "Reads the value of the Y axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_14",
            "text": "MicroBitCoordinateSystem  system - The coordinate system to use. By default, a simple cartesian system is provided.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_8",
            "text": "The magnetic force measured in the Y axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_18",
            "text": "compass.getY();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#getz",
            "text": "",
            "title": "getZ"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getz",
            "text": "",
            "title": "int getZ()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_21",
            "text": "Reads the value of the Z axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_9",
            "text": "The magnetic force measured in the Z axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_19",
            "text": "compass.getZ();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getz-microbitcoordinatesystem-system",
            "text": "",
            "title": "int getZ( MicroBitCoordinateSystem system)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_22",
            "text": "Reads the value of the Z axis from the latest update retrieved from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_15",
            "text": "MicroBitCoordinateSystem  system - The coordinate system to use. By default, a simple cartesian system is provided.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_10",
            "text": "The magnetic force measured in the Z axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_20",
            "text": "compass.getZ();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#getfieldstrength",
            "text": "",
            "title": "getFieldStrength"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-getfieldstrength",
            "text": "",
            "title": "int getFieldStrength()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_23",
            "text": "Determines the overall magnetic field strength based on the latest update from the magnetometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_11",
            "text": "The magnetic force measured across all axis, in nano teslas.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#example_21",
            "text": "compass.getFieldStrength();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#readtemperature",
            "text": "",
            "title": "readTemperature"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-readtemperature",
            "text": "",
            "title": "int readTemperature()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_24",
            "text": "Reads the current die temperature of the compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_12",
            "text": "the temperature in degrees celsius, or MICROBIT_I2C_ERROR if the temperature reading could not be retreived from the accelerometer.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#calibrate",
            "text": "",
            "title": "calibrate"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-calibrate",
            "text": "",
            "title": "int calibrate()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_25",
            "text": "Perform a calibration of the compass.    This method will be called automatically if a user attempts to read a compass value when the compass is uncalibrated. It can also be called at any time by the user.    The method will only return once the compass has been calibrated.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_13",
            "text": "MICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete successfully.   Note  THIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#setcalibration",
            "text": "",
            "title": "setCalibration"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#void-setcalibration-compasssample-calibration",
            "text": "",
            "title": "void setCalibration( CompassSample calibration)"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_26",
            "text": "Configure the compass to use the calibration data that is supplied to this call.    Calibration data is comprised of the perceived zero offset of each axis of the compass.    After calibration this should now take into account trimming errors in the magnetometer, and any \u201chard iron\u201d offsets on the device.    calibration   A  CompassSample  containing the offsets for the x, y and z axis.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#parameters_16",
            "text": "CompassSample  calibration - A  CompassSample  containing the offsets for the x, y and z axis.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#getcalibration",
            "text": "",
            "title": "getCalibration"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#compasssample-getcalibration",
            "text": "",
            "title": "CompassSample getCalibration()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_27",
            "text": "Provides the calibration data currently in use by the compass.    More specifically, the x, y and z zero offsets of the compass.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#returns_14",
            "text": "calibration A  CompassSample  containing the offsets for the x, y and z axis.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#updatesample",
            "text": "",
            "title": "updateSample"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-updatesample",
            "text": "",
            "title": "int updateSample()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_28",
            "text": "Updates the local sample, only if the compass indicates that data is stale.     Note  Can be used to trigger manual updates, if the device is running without a scheduler. Also called internally by all get X,Y,Z  member functions.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#iscalibrated",
            "text": "",
            "title": "isCalibrated"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-iscalibrated",
            "text": "",
            "title": "int isCalibrated()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_29",
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#iscalibrating",
            "text": "",
            "title": "isCalibrating"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#int-iscalibrating",
            "text": "",
            "title": "int isCalibrating()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_30",
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#clearcalibration",
            "text": "",
            "title": "clearCalibration"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#void-clearcalibration",
            "text": "",
            "title": "void clearCalibration()"
        },
        {
            "location": "/lancaster-mbed/ubit/compass/#description_31",
            "text": "Clears the calibration held in persistent storage, and sets the calibrated flag to zero.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/",
            "text": "uBit.thermometer\n#\n\n\nOverview\n#\n\n\nMicroBitThermometer provides access to the surface temperature of the nrf51822.\nThe temperature reading therefore is not representative of the ambient temperature,\nbut rather the temperature relative to the surface temperature of the chip.\n\n\nHowever, we can make it representative of the ambient temperature in software\nthrough \u201ccalibrating\u201d the thermometer.\n\n\nCalibration is very simple, and is calculated by giving the current temperature\nto the \nsetCalibration()\n member function. From the temperature, an offset is\ncalculated, and is subsequently used to offset future temperature readings.\n\n\nReal time updates\n#\n\n\nWhen using the standard uBit presentation, the thermometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.\n\n\nIf there is no scheduler running, the values are synchronously read on \ngetTemperature()\n\ncalls. Additionally, if you would like to drive thermometer updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_THERMOMETER\n\n\n28\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_THERMOMETER_EVT_UPDATE\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitThermometer( \nMicroBitStorage  &\n _storage)\n#\n\n\nDescription\n#\n\n\nConstructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.  \n\n\nParameters\n#\n\n\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage  used to persist temperature offset data\n\n\n\n\nExample\n#\n\n\n MicroBitStorage storage; \n MicroBitThermometer thermometer(storage); \n\n\n\n\n\n\nMicroBitThermometer( \nMicroBitStorage  &\n _storage,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.  \n\n\nParameters\n#\n\n\n\n\nMicroBitStorage  &\n _storage - an instance of  MicroBitStorage  used to persist temperature offset data\n\n\nuint16_t\n id - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.\n\n\n\n\nExample\n#\n\n\n MicroBitStorage storage; \n MicroBitThermometer thermometer(storage); \n\n\n\n\n\n\nMicroBitThermometer()\n#\n\n\nDescription\n#\n\n\nConstructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.  \n\n\nExample\n#\n\n\n MicroBitThermometer thermometer; \n\n\n\n\n\n\nMicroBitThermometer( \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.\n\n\n\n\nExample\n#\n\n\n MicroBitThermometer thermometer; \n\n\n\n\nsetPeriod\n#\n\n\n\n\nvoid\n \nsetPeriod\n( \nint\n period)\n#\n\n\nDescription\n#\n\n\nSet the sample rate at which the temperatureis read (in ms).  \n\n\nThe default sample period is 1 second.  \n\n\nParameters\n#\n\n\n\n\nint\n period - the requested time between samples, in milliseconds.\n\n\n\n\n\n\nNote\n\n\nthe temperature is always read in the background, and is only updated when the processor is idle, or when the temperature is explicitly read. \n\n\n\n\ngetPeriod\n#\n\n\n\n\nint\n \ngetPeriod\n()\n#\n\n\nDescription\n#\n\n\nReads the currently configured sample rate of the thermometer.  \n\n\nReturns\n#\n\n\nThe time between samples, in milliseconds. \n\n\nsetOffset\n#\n\n\n\n\nint\n \nsetOffset\n( \nint\n offset)\n#\n\n\nDescription\n#\n\n\nSet the value that is used to offset the raw silicon temperature.  \n\n\nParameters\n#\n\n\n\n\nint\n offset - the offset for the silicon temperature\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success \n\n\ngetOffset\n#\n\n\n\n\nint\n \ngetOffset\n()\n#\n\n\nDescription\n#\n\n\nRetreive the value that is used to offset the raw silicon temperature.  \n\n\nReturns\n#\n\n\nthe current offset. \n\n\nsetCalibration\n#\n\n\n\n\nint\n \nsetCalibration\n( \nint\n calibrationTemp)\n#\n\n\nDescription\n#\n\n\nThis member function fetches the raw silicon temperature, and calculates the value used to offset the raw silicon temperature based on a given temperature.  \n\n\nParameters\n#\n\n\n\n\nint\n calibrationTemp - the temperature used to calculate the raw silicon temperature offset.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success \n\n\ngetTemperature\n#\n\n\n\n\nint\n \ngetTemperature\n()\n#\n\n\nDescription\n#\n\n\nGets the current temperature of the microbit.  \n\n\nReturns\n#\n\n\nthe current temperature, in degrees celsius.\n\n\nExample\n#\n\n\n thermometer.getTemperature(); \n\n\n\n\nupdateSample\n#\n\n\n\n\nint\n \nupdateSample\n()\n#\n\n\nDescription\n#\n\n\nUpdates the temperature sample of this instance of  MicroBitThermometer  only if  isSampleNeeded()  indicates that an update is required.  \n\n\nThis call also will add the thermometer to fiber components to receive periodic callbacks.  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success.",
            "title": "thermometer"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#ubitthermometer",
            "text": "",
            "title": "uBit.thermometer"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#overview",
            "text": "MicroBitThermometer provides access to the surface temperature of the nrf51822.\nThe temperature reading therefore is not representative of the ambient temperature,\nbut rather the temperature relative to the surface temperature of the chip.  However, we can make it representative of the ambient temperature in software\nthrough \u201ccalibrating\u201d the thermometer.  Calibration is very simple, and is calculated by giving the current temperature\nto the  setCalibration()  member function. From the temperature, an offset is\ncalculated, and is subsequently used to offset future temperature readings.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#real-time-updates",
            "text": "When using the standard uBit presentation, the thermometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.  If there is no scheduler running, the values are synchronously read on  getTemperature() \ncalls. Additionally, if you would like to drive thermometer updates manually  updateSample() \ncan be used.",
            "title": "Real time updates"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_THERMOMETER  28",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#message-bus-events",
            "text": "Constant  Value      MICROBIT_THERMOMETER_EVT_UPDATE  1",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#microbitthermometer-microbitstorage-_storage",
            "text": "",
            "title": "MicroBitThermometer( MicroBitStorage  &amp; _storage)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description",
            "text": "Constructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters",
            "text": "MicroBitStorage  &  _storage - an instance of  MicroBitStorage  used to persist temperature offset data",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#example",
            "text": "MicroBitStorage storage; \n MicroBitThermometer thermometer(storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#microbitthermometer-microbitstorage-_storage-uint16_t-id",
            "text": "",
            "title": "MicroBitThermometer( MicroBitStorage  &amp; _storage,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_1",
            "text": "Constructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters_1",
            "text": "MicroBitStorage  &  _storage - an instance of  MicroBitStorage  used to persist temperature offset data  uint16_t  id - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#example_1",
            "text": "MicroBitStorage storage; \n MicroBitThermometer thermometer(storage);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#microbitthermometer",
            "text": "",
            "title": "MicroBitThermometer()"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_2",
            "text": "Constructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#example_2",
            "text": "MicroBitThermometer thermometer;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#microbitthermometer-uint16_t-id",
            "text": "",
            "title": "MicroBitThermometer( uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_3",
            "text": "Constructor. Create new  MicroBitThermometer  that gives an indication of the current temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters_2",
            "text": "uint16_t  id - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#example_3",
            "text": "MicroBitThermometer thermometer;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#setperiod",
            "text": "",
            "title": "setPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#void-setperiod-int-period",
            "text": "",
            "title": "void setPeriod( int period)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_4",
            "text": "Set the sample rate at which the temperatureis read (in ms).    The default sample period is 1 second.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters_3",
            "text": "int  period - the requested time between samples, in milliseconds.    Note  the temperature is always read in the background, and is only updated when the processor is idle, or when the temperature is explicitly read.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#getperiod",
            "text": "",
            "title": "getPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-getperiod",
            "text": "",
            "title": "int getPeriod()"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_5",
            "text": "Reads the currently configured sample rate of the thermometer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns",
            "text": "The time between samples, in milliseconds.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#setoffset",
            "text": "",
            "title": "setOffset"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-setoffset-int-offset",
            "text": "",
            "title": "int setOffset( int offset)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_6",
            "text": "Set the value that is used to offset the raw silicon temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters_4",
            "text": "int  offset - the offset for the silicon temperature",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns_1",
            "text": "MICROBIT_OK on success",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#getoffset",
            "text": "",
            "title": "getOffset"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-getoffset",
            "text": "",
            "title": "int getOffset()"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_7",
            "text": "Retreive the value that is used to offset the raw silicon temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns_2",
            "text": "the current offset.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#setcalibration",
            "text": "",
            "title": "setCalibration"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-setcalibration-int-calibrationtemp",
            "text": "",
            "title": "int setCalibration( int calibrationTemp)"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_8",
            "text": "This member function fetches the raw silicon temperature, and calculates the value used to offset the raw silicon temperature based on a given temperature.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#parameters_5",
            "text": "int  calibrationTemp - the temperature used to calculate the raw silicon temperature offset.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns_3",
            "text": "MICROBIT_OK on success",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#gettemperature",
            "text": "",
            "title": "getTemperature"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-gettemperature",
            "text": "",
            "title": "int getTemperature()"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_9",
            "text": "Gets the current temperature of the microbit.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns_4",
            "text": "the current temperature, in degrees celsius.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#example_4",
            "text": "thermometer.getTemperature();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#updatesample",
            "text": "",
            "title": "updateSample"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#int-updatesample",
            "text": "",
            "title": "int updateSample()"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#description_10",
            "text": "Updates the temperature sample of this instance of  MicroBitThermometer  only if  isSampleNeeded()  indicates that an update is required.    This call also will add the thermometer to fiber components to receive periodic callbacks.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/thermometer/#returns_5",
            "text": "MICROBIT_OK on success.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/",
            "text": "uBit.io\n#\n\n\nOverview\n#\n\n\nuBit.io\n provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.\n\n\nThere are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.\n\n\nAnalog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of \n3\n concurrent PWM outputs.\n\n\nThere are two ways of accessing pins on the edge connector:\n\n\n\n\nuBit.io.P0.setDigitalValue(1)\n - Would configure P0 as a digital output, and set that pin HI.\n\n\nuBit.io.pin[1].setDigitalValue(1)\n - Would configure P1 as a digital output, and set that pin HI.\n\n\n\n\nBy design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.\n\n\nFor example:\n\n\nwhile(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}\n\n\n\n\nWill transition between Digital and Analog output every second.\n\n\nShared Functionality\n#\n\n\nAs well as being General Purpose Input Output (\nGPIO\n) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.\n\n\nTherefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.\n\n\nThis is illustrated by the diagram below:\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\nCapability\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_IO_P0\n\n\n7\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P1\n\n\n8\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P2\n\n\n9\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P3\n\n\n10\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P4\n\n\n11\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P5\n\n\n12\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P6\n\n\n13\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P7\n\n\n14\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P8\n\n\n15\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P9\n\n\n16\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P10\n\n\n17\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P11\n\n\n18\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P12\n\n\n19\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P13\n\n\n20\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P14\n\n\n21\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P15\n\n\n22\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P16\n\n\n23\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P19\n\n\n24\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P20\n\n\n25\n\n\nDigital only\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\nWhen \nisTouched()\n is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of \nbutton\n will be created. Listeners\ncan therefore be placed using the desired pins\u2019 ID, with the exact same events\nproduced by a standard \nbutton\n.\n\n\nuBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();\n\n\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitPin( \nint\n id,  \nPinName\n name,  \nPinCapability\n capability)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a  MicroBitPin  instance, generally used to represent a pin on the edge connector.  \n\n\nParameters\n#\n\n\n\n\nint\n id - the unique  EventModel  id of this component.\n\n\nPinName\n name - the mbed PinName for this  MicroBitPin  instance.\n\n\nPinCapability\n capability - the capabilities this  MicroBitPin  instance should have. (PIN_CAPABILITY_DIGITAL, PIN_CAPABILITY_ANALOG, PIN_CAPABILITY_AD, PIN_CAPABILITY_ALL)\n\n\n\n\nExample\n#\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n\n\n\n\nsetDigitalValue\n#\n\n\n\n\nint\n \nsetDigitalValue\n( \nint\n value)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as a digital output (if necessary) and sets the pin to \u2018value\u2019.  \n\n\nParameters\n#\n\n\n\n\nint\n value - 0 (LO) or 1 (HI)\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.\n\n\nExample\n#\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.setDigitalValue(1); // P0 is now HI \n\n\n\n\ngetDigitalValue\n#\n\n\n\n\nint\n \ngetDigitalValue\n()\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as a digital input (if necessary) and tests its current value.  \n\n\nReturns\n#\n\n\n1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.\n\n\nExample\n#\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(); // P0 is either 0 or 1; \n\n\n\n\n\n\nint\n \ngetDigitalValue\n( \nPinMode\n pull)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as a digital input with the specified internal pull-up/pull-down configuraiton (if necessary) and tests its current value.  \n\n\nParameters\n#\n\n\n\n\nPinMode\n pull - one of the mbed pull configurations: PullUp, PullDown, PullNone\n\n\n\n\nReturns\n#\n\n\n1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.\n\n\nExample\n#\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(PullUp); // P0 is either 0 or 1; \n\n\n\n\nsetAnalogValue\n#\n\n\n\n\nint\n \nsetAnalogValue\n( \nint\n value)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analog/pwm output, and change the output value to the given level.  \n\n\nParameters\n#\n\n\n\n\nint\n value - the level to set on the output pin, in the range 0 - 1024\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\nsetServoValue\n#\n\n\n\n\nint\n \nsetServoValue\n( \nint\n value)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.  \n\n\nA value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.  \n\n\nThis range can be modified to fine tune, and also tolerate different servos.  \n\n\nParameters\n#\n\n\n\n\nint\n value - the level to set on the output pin, in the range 0 - 180.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\n\nint\n \nsetServoValue\n( \nint\n value,  \nint\n range)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.  \n\n\nA value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.  \n\n\nThis range can be modified to fine tune, and also tolerate different servos.  \n\n\nParameters\n#\n\n\n\n\nint\n value - the level to set on the output pin, in the range 0 - 180.\n\n\nint\n range - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\n\nint\n \nsetServoValue\n( \nint\n value,  \nint\n range,  \nint\n center)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.  \n\n\nA value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.  \n\n\nThis range can be modified to fine tune, and also tolerate different servos.  \n\n\nParameters\n#\n\n\n\n\nint\n value - the level to set on the output pin, in the range 0 - 180.\n\n\nint\n range - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.\n\n\nint\n center - the center point from which to calculate the lower and upper bounds. Defaults to MICROBIT_PIN_DEFAULT_SERVO_CENTER\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\ngetAnalogValue\n#\n\n\n\n\nint\n \ngetAnalogValue\n()\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analogue input (if necessary), and samples the Pin for its analog value.  \n\n\nReturns\n#\n\n\nthe current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nExample\n#\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024 \n\n\n\n\nisInput\n#\n\n\n\n\nint\n \nisInput\n()\n#\n\n\nDescription\n#\n\n\nDetermines if this IO pin is currently configured as an input.  \n\n\nReturns\n#\n\n\n1 if pin is an analog or digital input, 0 otherwise. \n\n\nisOutput\n#\n\n\n\n\nint\n \nisOutput\n()\n#\n\n\nDescription\n#\n\n\nDetermines if this IO pin is currently configured as an output.  \n\n\nReturns\n#\n\n\n1 if pin is an analog or digital output, 0 otherwise. \n\n\nisDigital\n#\n\n\n\n\nint\n \nisDigital\n()\n#\n\n\nDescription\n#\n\n\nDetermines if this IO pin is currently configured for digital use.  \n\n\nReturns\n#\n\n\n1 if pin is digital, 0 otherwise. \n\n\nisAnalog\n#\n\n\n\n\nint\n \nisAnalog\n()\n#\n\n\nDescription\n#\n\n\nDetermines if this IO pin is currently configured for analog use.  \n\n\nReturns\n#\n\n\n1 if pin is analog, 0 otherwise. \n\n\nisTouched\n#\n\n\n\n\nint\n \nisTouched\n()\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as a \u201cmakey makey\u201d style touch sensor (if necessary) and tests its current debounced state.  \n\n\nUsers can also subscribe to  MicroBitButton  events generated from this pin.  \n\n\nReturns\n#\n\n\n1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.\n\n\nExample\n#\n\n\n MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n if(P0.isTouched()) \n { \n //do something! \n } \n\n // subscribe to events generated by this pin! \n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_BUTTON_EVT_CLICK, someFunction); \n\n\n\n\nsetServoPulseUs\n#\n\n\n\n\nint\n \nsetServoPulseUs\n( \nint\n pulseWidth)\n#\n\n\nDescription\n#\n\n\nConfigures this IO pin as an analog/pwm output if it isn\u2019t already, configures the period to be 20ms, and sets the pulse width, based on the value it is given.  \n\n\nParameters\n#\n\n\n\n\nint\n pulseWidth - the desired pulse width in microseconds.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\nsetAnalogPeriod\n#\n\n\n\n\nint\n \nsetAnalogPeriod\n( \nint\n period)\n#\n\n\nDescription\n#\n\n\nConfigures the PWM period of the analog output to the given value.  \n\n\nParameters\n#\n\n\n\n\nint\n period - The new period for the analog output in milliseconds.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\nsetAnalogPeriodUs\n#\n\n\n\n\nint\n \nsetAnalogPeriodUs\n( \nint\n period)\n#\n\n\nDescription\n#\n\n\nConfigures the PWM period of the analog output to the given value.  \n\n\nParameters\n#\n\n\n\n\nint\n period - The new period for the analog output in microseconds.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\ngetAnalogPeriodUs\n#\n\n\n\n\nint\n \ngetAnalogPeriodUs\n()\n#\n\n\nDescription\n#\n\n\nObtains the PWM period of the analog output in microseconds.  \n\n\nReturns\n#\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\ngetAnalogPeriod\n#\n\n\n\n\nint\n \ngetAnalogPeriod\n()\n#\n\n\nDescription\n#\n\n\nObtains the PWM period of the analog output in milliseconds.  \n\n\nReturns\n#\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\nsetPull\n#\n\n\n\n\nint\n \nsetPull\n( \nPinMode\n pull)\n#\n\n\nDescription\n#\n\n\nConfigures the pull of this pin.  \n\n\nParameters\n#\n\n\n\n\nPinMode\n pull - one of the mbed pull configurations: PullUp, PullDown, PullNone\n\n\n\n\nReturns\n#\n\n\nMICROBIT_NOT_SUPPORTED if the current pin configuration is anything other than a digital input, otherwise MICROBIT_OK. \n\n\neventOn\n#\n\n\n\n\nint\n \neventOn\n( \nint\n eventType)\n#\n\n\nDescription\n#\n\n\nConfigures the events generated by this  MicroBitPin  instance.  \n\n\nMICROBIT_PIN_EVENT_ON_EDGE - Configures this pin to a digital input, and generates events whenever a rise/fall is detected on this pin. (MICROBIT_PIN_EVT_RISE, MICROBIT_PIN_EVT_FALL) MICROBIT_PIN_EVENT_ON_PULSE - Configures this pin to a digital input, and generates events where the timestamp is the duration that this pin was either HI or LO. (MICROBIT_PIN_EVT_PULSE_HI, MICROBIT_PIN_EVT_PULSE_LO) MICROBIT_PIN_EVENT_ON_TOUCH - Configures this pin as a makey makey style touch sensor, in the form of a  MicroBitButton . Normal button events will be generated using the ID of this pin. MICROBIT_PIN_EVENT_NONE - Disables events for this pin.  \n\n\nParameters\n#\n\n\n\n\nint\n eventType - One of: MICROBIT_PIN_EVENT_ON_EDGE, MICROBIT_PIN_EVENT_ON_PULSE, MICROBIT_PIN_EVENT_ON_TOUCH, MICROBIT_PIN_EVENT_NONE\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the given eventype does not match\n\n\nExample\n#\n\n\n MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.eventOn(MICROBIT_PIN_EVENT_ON_PULSE); \n\n void onPulse(MicroBitEvent evt) \n { \n int duration = evt.timestamp; \n } \n\n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_PIN_EVT_PULSE_HI, onPulse, MESSAGE_BUS_LISTENER_IMMEDIATE) \n\n\n\n\n\n\nNote\n\n\nIn the MICROBIT_PIN_EVENT_ON_PULSE mode, the smallest pulse that was reliably detected was 85us, around 5khz. If more precision is required, please use the InterruptIn class supplied by ARM mbed.",
            "title": "io"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#ubitio",
            "text": "",
            "title": "uBit.io"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#overview",
            "text": "uBit.io  provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.  There are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.  Analog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of  3  concurrent PWM outputs.  There are two ways of accessing pins on the edge connector:   uBit.io.P0.setDigitalValue(1)  - Would configure P0 as a digital output, and set that pin HI.  uBit.io.pin[1].setDigitalValue(1)  - Would configure P1 as a digital output, and set that pin HI.   By design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.  For example:  while(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}  Will transition between Digital and Analog output every second.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#shared-functionality",
            "text": "As well as being General Purpose Input Output ( GPIO ) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.  Therefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.  This is illustrated by the diagram below:",
            "title": "Shared Functionality"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#message-bus-id",
            "text": "Constant  Value  Capability      MICROBIT_ID_IO_P0  7  Analog, digital and touch    MICROBIT_ID_IO_P1  8  Analog, digital and touch    MICROBIT_ID_IO_P2  9  Analog, digital and touch    MICROBIT_ID_IO_P3  10  Analog and digital    MICROBIT_ID_IO_P4  11  Analog and digital    MICROBIT_ID_IO_P5  12  Digital only    MICROBIT_ID_IO_P6  13  Digital only    MICROBIT_ID_IO_P7  14  Digital only    MICROBIT_ID_IO_P8  15  Digital only    MICROBIT_ID_IO_P9  16  Digital only    MICROBIT_ID_IO_P10  17  Analog and digital    MICROBIT_ID_IO_P11  18  Digital only    MICROBIT_ID_IO_P12  19  Digital only    MICROBIT_ID_IO_P13  20  Digital only    MICROBIT_ID_IO_P14  21  Digital only    MICROBIT_ID_IO_P15  22  Digital only    MICROBIT_ID_IO_P16  23  Digital only    MICROBIT_ID_IO_P19  24  Digital only    MICROBIT_ID_IO_P20  25  Digital only",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#message-bus-events",
            "text": "When  isTouched()  is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of  button  will be created. Listeners\ncan therefore be placed using the desired pins\u2019 ID, with the exact same events\nproduced by a standard  button .  uBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();     Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#microbitpin-int-id-pinname-name-pincapability-capability",
            "text": "",
            "title": "MicroBitPin( int id,  PinName name,  PinCapability capability)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description",
            "text": "Constructor. Create a  MicroBitPin  instance, generally used to represent a pin on the edge connector.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters",
            "text": "int  id - the unique  EventModel  id of this component.  PinName  name - the mbed PinName for this  MicroBitPin  instance.  PinCapability  capability - the capabilities this  MicroBitPin  instance should have. (PIN_CAPABILITY_DIGITAL, PIN_CAPABILITY_ANALOG, PIN_CAPABILITY_AD, PIN_CAPABILITY_ALL)",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example",
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setdigitalvalue",
            "text": "",
            "title": "setDigitalValue"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setdigitalvalue-int-value",
            "text": "",
            "title": "int setDigitalValue( int value)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_1",
            "text": "Configures this IO pin as a digital output (if necessary) and sets the pin to \u2018value\u2019.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_1",
            "text": "int  value - 0 (LO) or 1 (HI)",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_1",
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.setDigitalValue(1); // P0 is now HI",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#getdigitalvalue",
            "text": "",
            "title": "getDigitalValue"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-getdigitalvalue",
            "text": "",
            "title": "int getDigitalValue()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_2",
            "text": "Configures this IO pin as a digital input (if necessary) and tests its current value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_1",
            "text": "1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_2",
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(); // P0 is either 0 or 1;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-getdigitalvalue-pinmode-pull",
            "text": "",
            "title": "int getDigitalValue( PinMode pull)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_3",
            "text": "Configures this IO pin as a digital input with the specified internal pull-up/pull-down configuraiton (if necessary) and tests its current value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_2",
            "text": "PinMode  pull - one of the mbed pull configurations: PullUp, PullDown, PullNone",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_2",
            "text": "1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_3",
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(PullUp); // P0 is either 0 or 1;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setanalogvalue",
            "text": "",
            "title": "setAnalogValue"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setanalogvalue-int-value",
            "text": "",
            "title": "int setAnalogValue( int value)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_4",
            "text": "Configures this IO pin as an analog/pwm output, and change the output value to the given level.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_3",
            "text": "int  value - the level to set on the output pin, in the range 0 - 1024",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_3",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setservovalue",
            "text": "",
            "title": "setServoValue"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setservovalue-int-value",
            "text": "",
            "title": "int setServoValue( int value)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_5",
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.    A value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.    This range can be modified to fine tune, and also tolerate different servos.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_4",
            "text": "int  value - the level to set on the output pin, in the range 0 - 180.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_4",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setservovalue-int-value-int-range",
            "text": "",
            "title": "int setServoValue( int value,  int range)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_6",
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.    A value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.    This range can be modified to fine tune, and also tolerate different servos.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_5",
            "text": "int  value - the level to set on the output pin, in the range 0 - 180.  int  range - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_5",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setservovalue-int-value-int-range-int-center",
            "text": "",
            "title": "int setServoValue( int value,  int range,  int center)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_7",
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.    A value of 180 sets the duty cycle to be 2500us, and a value of 0 sets the duty cycle to be 500us by default.    This range can be modified to fine tune, and also tolerate different servos.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_6",
            "text": "int  value - the level to set on the output pin, in the range 0 - 180.  int  range - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.  int  center - the center point from which to calculate the lower and upper bounds. Defaults to MICROBIT_PIN_DEFAULT_SERVO_CENTER",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_6",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#getanalogvalue",
            "text": "",
            "title": "getAnalogValue"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-getanalogvalue",
            "text": "",
            "title": "int getAnalogValue()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_8",
            "text": "Configures this IO pin as an analogue input (if necessary), and samples the Pin for its analog value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_7",
            "text": "the current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_4",
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#isinput",
            "text": "",
            "title": "isInput"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-isinput",
            "text": "",
            "title": "int isInput()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_9",
            "text": "Determines if this IO pin is currently configured as an input.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_8",
            "text": "1 if pin is an analog or digital input, 0 otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#isoutput",
            "text": "",
            "title": "isOutput"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-isoutput",
            "text": "",
            "title": "int isOutput()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_10",
            "text": "Determines if this IO pin is currently configured as an output.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_9",
            "text": "1 if pin is an analog or digital output, 0 otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#isdigital",
            "text": "",
            "title": "isDigital"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-isdigital",
            "text": "",
            "title": "int isDigital()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_11",
            "text": "Determines if this IO pin is currently configured for digital use.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_10",
            "text": "1 if pin is digital, 0 otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#isanalog",
            "text": "",
            "title": "isAnalog"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-isanalog",
            "text": "",
            "title": "int isAnalog()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_12",
            "text": "Determines if this IO pin is currently configured for analog use.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_11",
            "text": "1 if pin is analog, 0 otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#istouched",
            "text": "",
            "title": "isTouched"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-istouched",
            "text": "",
            "title": "int isTouched()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_13",
            "text": "Configures this IO pin as a \u201cmakey makey\u201d style touch sensor (if necessary) and tests its current debounced state.    Users can also subscribe to  MicroBitButton  events generated from this pin.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_12",
            "text": "1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_5",
            "text": "MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n if(P0.isTouched()) \n { \n //do something! \n } \n\n // subscribe to events generated by this pin! \n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_BUTTON_EVT_CLICK, someFunction);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setservopulseus",
            "text": "",
            "title": "setServoPulseUs"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setservopulseus-int-pulsewidth",
            "text": "",
            "title": "int setServoPulseUs( int pulseWidth)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_14",
            "text": "Configures this IO pin as an analog/pwm output if it isn\u2019t already, configures the period to be 20ms, and sets the pulse width, based on the value it is given.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_7",
            "text": "int  pulseWidth - the desired pulse width in microseconds.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_13",
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setanalogperiod",
            "text": "",
            "title": "setAnalogPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setanalogperiod-int-period",
            "text": "",
            "title": "int setAnalogPeriod( int period)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_15",
            "text": "Configures the PWM period of the analog output to the given value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_8",
            "text": "int  period - The new period for the analog output in milliseconds.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_14",
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setanalogperiodus",
            "text": "",
            "title": "setAnalogPeriodUs"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setanalogperiodus-int-period",
            "text": "",
            "title": "int setAnalogPeriodUs( int period)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_16",
            "text": "Configures the PWM period of the analog output to the given value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_9",
            "text": "int  period - The new period for the analog output in microseconds.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_15",
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#getanalogperiodus",
            "text": "",
            "title": "getAnalogPeriodUs"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-getanalogperiodus",
            "text": "",
            "title": "int getAnalogPeriodUs()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_17",
            "text": "Obtains the PWM period of the analog output in microseconds.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_16",
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#getanalogperiod",
            "text": "",
            "title": "getAnalogPeriod"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-getanalogperiod",
            "text": "",
            "title": "int getAnalogPeriod()"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_18",
            "text": "Obtains the PWM period of the analog output in milliseconds.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_17",
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#setpull",
            "text": "",
            "title": "setPull"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-setpull-pinmode-pull",
            "text": "",
            "title": "int setPull( PinMode pull)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_19",
            "text": "Configures the pull of this pin.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_10",
            "text": "PinMode  pull - one of the mbed pull configurations: PullUp, PullDown, PullNone",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_18",
            "text": "MICROBIT_NOT_SUPPORTED if the current pin configuration is anything other than a digital input, otherwise MICROBIT_OK.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#eventon",
            "text": "",
            "title": "eventOn"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#int-eventon-int-eventtype",
            "text": "",
            "title": "int eventOn( int eventType)"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#description_20",
            "text": "Configures the events generated by this  MicroBitPin  instance.    MICROBIT_PIN_EVENT_ON_EDGE - Configures this pin to a digital input, and generates events whenever a rise/fall is detected on this pin. (MICROBIT_PIN_EVT_RISE, MICROBIT_PIN_EVT_FALL) MICROBIT_PIN_EVENT_ON_PULSE - Configures this pin to a digital input, and generates events where the timestamp is the duration that this pin was either HI or LO. (MICROBIT_PIN_EVT_PULSE_HI, MICROBIT_PIN_EVT_PULSE_LO) MICROBIT_PIN_EVENT_ON_TOUCH - Configures this pin as a makey makey style touch sensor, in the form of a  MicroBitButton . Normal button events will be generated using the ID of this pin. MICROBIT_PIN_EVENT_NONE - Disables events for this pin.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#parameters_11",
            "text": "int  eventType - One of: MICROBIT_PIN_EVENT_ON_EDGE, MICROBIT_PIN_EVENT_ON_PULSE, MICROBIT_PIN_EVENT_ON_TOUCH, MICROBIT_PIN_EVENT_NONE",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#returns_19",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the given eventype does not match",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/io/#example_6",
            "text": "MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.eventOn(MICROBIT_PIN_EVENT_ON_PULSE); \n\n void onPulse(MicroBitEvent evt) \n { \n int duration = evt.timestamp; \n } \n\n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_PIN_EVT_PULSE_HI, onPulse, MESSAGE_BUS_LISTENER_IMMEDIATE)    Note  In the MICROBIT_PIN_EVENT_ON_PULSE mode, the smallest pulse that was reliably detected was 85us, around 5khz. If more precision is required, please use the InterruptIn class supplied by ARM mbed.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/",
            "text": "uBit.radio\n#\n\n\nOverview\n#\n\n\nThe central processor unit (CPU) on the micro:bit is a Nordic Semiconductor \nnRF51822\n. In addition to being a general purpose\ncomputer processor, this chip also contains a built-in 2.4GHz radio module.  This radio can be configured in a number of\nways, and is primarily designed to run the Bluetooth Low Energy (BLE) protocol. However, it can also be placed into a much\nsimpler mode of operation based that allows simple, direct micro:bit to micro:bit communication.\n\n\nThe \nMicroBitRadio\n component is made up of three classes - \nMicroBitRadio\n, \nMicroBitRadioEvent\n and \nMicroBitRadioDatagram\n. Together,\nthese provide the ability to send general purpose data packets from one micro:bit to another, and to extend a message bus to span multiple micro:bits\u2026\nso if you raise an event on one micro:bit, you can receive it on another using the normal \nlisten\n mechanism!\n\n\n\n\nNote\n\n\nIt is not currently possible to run the \nMicroBitRadio\n component and Bluetooth Low Energy (BLE) at the same time. If you want to use the \nMicroBitRadio\n functionality, you need to disable the BLE stack on your micro:bit by compiling the runtime with \n#define MICROBIT_BLE_ENABLED 0\n in your \ninc/MicroBitConfig.h\n file.\n\n\n\n\nCapabilities\n#\n\n\nThis component provides a very easy to use, flexible, broadcast radio channel. Anything you send from one micro:bit, can be received by any other micro:bits nearby.\nIt is designed to provide a powerful but simple introduction to the world of wireless communications, and can let you create a whole range of applications from\nbuilding your own friend detectors to creating remote control cars.\n\n\nA key principle of this component is \nprivacy\n, which is built in from the ground up. So, when you send any data, there is nothing inherent in this protocol\nwhich can be used to identify you or your micro:bit. All devices look identical. Therefore, if you want to be able to identify yourself, you need to add this to your own data.\n\n\n\n\n\n\n\n\n\n\nCapability\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nFrequency\n\n\n1MHz narrowband, typically 2.407 GHz. Use configurable in the 2.400 GHz - 2.499 GHz band.\n\n\n\n\n\n\nChannel Rate\n\n\n1Mbps.\n\n\n\n\n\n\nMaximum Transfer Unit\n\n\nTypically 32 bytes, but reconfigurable in code up to 1024 bytes.\n\n\n\n\n\n\nAddressing\n\n\nAll devices share the same address to guarantee user privacy.\n\n\n\n\n\n\nEncryption\n\n\nNone. User level encryption (or BLE) should be considered if secture channels are required.\n\n\n\n\n\n\nMeshing\n\n\nNone. (yet!)\n\n\n\n\n\n\nError Detection\n\n\n16 bit hardware CRC.\n\n\n\n\n\n\nTransmisson Power\n\n\nEight user configurable settings from 0 (-30dbm) to 7 (+4dbm).\n\n\n\n\n\n\nTransmisson Range\n\n\nApprox. 20m at 0dbm.\n\n\n\n\n\n\n\n\nUsing MicroBitRadio\n#\n\n\nTo write your radio enabled applications, you will likely want to use either the \nMicroBitRadioDatagram\n class, or the \nMicroBitRadioEvent\n class.\n\n\nBoth of these are created for you as part of the standard uBit object, so this is a choice, not a compromise! :-)\n\n\nMicroBitRadioDatagram\n#\n\n\nThis is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time.\nThis data can be provided as array of bytes, a text string, or \nPacketBuffer\n.\n\n\nYou can send a packet at any time using the \nuBit.radio.datagram.send\n function.\n\n\nAny other micro:bits in range will detect the transmitted packet, and make the packet available through the\n\nuBit.radio.datagram.recv\n function.\n\n\nAny micro:bits receiving a datagram packet will also raise a \nMICROBIT_RADIO_EVT_DATAGRAM\n event to indicate\nthat some data is ready to be read.\n\n\nFor example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car.\n\n\nYou might decide that simply sending a \n1\n means turn left, and a \n2\n means turn right, so you may write a program like this for the remote control:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send(\"1\");\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send(\"2\");\n\n        uBit.sleep(100);\n    }\n}\n\n\n\n\n\u2026and one like this for the remote control car:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s == \"1\")\n    {\n        uBit.io.P0.setServoValue(0);\n        uBit.display.print(\"A\");\n    }\n\n    if (s == \"2\")\n    {\n        uBit.io.P0.setServoValue(180);\n        uBit.display.print(\"B\");\n    }\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nUsing PacketBuffers\n#\n\n\nIf you prefer to send a raw series of bytes rather than a text string (which is much more common in communication networks), you can use the \nPacketBuffer\n type.\nThis gives total freedom over the data being shared. Simply create a \nPacketBuffer\n of the size you need, and you can read or write data using standard C\narray syntax.\n\n\nFor example, here is an similar program using a \nPacketBuffer\n:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    // Create a packet containing just a single byte.\n    PacketBuffer b(1);\n\n    while(1)\n    {\n        b[0] = 0;\n        if (uBit.buttonA.isPressed())\n            b[0] = 1;\n\n        else if (uBit.buttonB.isPressed())\n            b[0] = 2;\n\n        uBit.radio.datagram.send(b);\n        uBit.sleep(100);\n    }\n}\n\n\n\n\n\u2026and one like this for the remote control car:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onData(MicroBitEvent e)\n{\n    PacketBuffer p = uBit.radio.datagram.recv();\n\n    if (p[0] == 1)\n    {\n        uBit.io.P0.setServoValue(0);\n        uBit.display.print(\"A\");\n    }\n\n    if (p[0] == 2)\n    {\n        uBit.io.P0.setServoValue(180);\n        uBit.display.print(\"B\");\n    }\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nMicroBitRadioEvent\n#\n\n\nIt is also possible to transparently send and receive events over the \nMicroBitRadio\n channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.\n\n\nTo use this functionality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the \nMicroBitMessageBus\n for details of how to write\nevent handlers.\n\n\nFor example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    // Ensure the radio is listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    // Just for varierty, this time we'll periodically check to see if a button if pressed.\n    // We can, of course, use an event handler for this too.\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(100);\n    }\n}\n\n\n\n\n\u2026and on the micro:bits wanting to receive the event:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync(\"Something!\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nDefining Groups\n#\n\n\nIt is easy to imagine situations where you would like to have different groups of micro:bits communicating independently.\n\n\nFor example, consider a classroom where 8 groups of four children are working on different\nprojects - it would not be very useful if packets sent by one group interfered with the other groups!\n\n\nTo address this, the \nMicroBitRadio\n allows users to define a \ngroup\n to which their micro:bit belongs.\n\n\nmicro:bits can only ever be a member of one group at a time, and any packets sent will only be received by other micro:bits in the same group.\n\n\nGroups are simply numbers, and a micro:bit\u2019s group can be set at anytime by the programmer through the \nsetGroup\n function. If a group is not specified, the default group of 0 will be used.\n\n\nFor example:\n\n\n#include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.setGroup(10);\n}\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_RADIO\n\n\n29\n\n\n\n\n\n\nMICROBIT_ID_RADIO_DATA_READY\n\n\n30\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_RADIO_EVT_DATAGRAM\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitRadio()\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nInitialise the  MicroBitRadio .  \n\n\n\n\nNote\n\n\nThis class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made. \n\n\n\n\n\n\nMicroBitRadio( \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nInitialise the  MicroBitRadio .  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id\n\n\n\n\n\n\nNote\n\n\nThis class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made. \n\n\n\n\nsetTransmitPower\n#\n\n\n\n\nint\n \nsetTransmitPower\n( \nint\n power)\n#\n\n\nDescription\n#\n\n\nChange the output power level of the transmitter to the given value.  \n\n\nParameters\n#\n\n\n\n\nint\n power - a value in the range 0..7, where 0 is the lowest power and 7 is the highest.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range. \n\n\nsetFrequencyBand\n#\n\n\n\n\nint\n \nsetFrequencyBand\n( \nint\n band)\n#\n\n\nDescription\n#\n\n\nChange the transmission and reception band of the radio to the given channel  \n\n\nParameters\n#\n\n\n\n\nint\n band - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ngetRxBuf\n#\n\n\n\n\nFrameBuffer\n \ngetRxBuf\n()\n#\n\n\nDescription\n#\n\n\nRetrieve a pointer to the currently allocated receive buffer. This is the area of memory actively being used by the radio hardware to store incoming data.  \n\n\nReturns\n#\n\n\na pointer to the current receive buffer. \n\n\nqueueRxBuf\n#\n\n\n\n\nint\n \nqueueRxBuf\n()\n#\n\n\nDescription\n#\n\n\nAttempt to queue a buffer received by the radio hardware, if sufficient space is available.  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion). \n\n\nsetRSSI\n#\n\n\n\n\nint\n \nsetRSSI\n( \nuint8_t\n rssi)\n#\n\n\nDescription\n#\n\n\nSets the RSSI for the most recent packet.  \n\n\nParameters\n#\n\n\n\n\nuint8_t\n rssi - the new rssi value.\n\n\n\n\n\n\nNote\n\n\nshould only be called from RADIO_IRQHandler\u2026 \n\n\n\n\ngetRSSI\n#\n\n\n\n\nint\n \ngetRSSI\n()\n#\n\n\nDescription\n#\n\n\nRetrieves the current RSSI for the most recent packet.  \n\n\nReturns\n#\n\n\nthe most recent RSSI value or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\nenable\n#\n\n\n\n\nint\n \nenable\n()\n#\n\n\nDescription\n#\n\n\nInitialises the radio for use as a multipoint sender/receiver  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ndisable\n#\n\n\n\n\nint\n \ndisable\n()\n#\n\n\nDescription\n#\n\n\nDisables the radio for use as a multipoint sender/receiver.  \n\n\nReturns\n#\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\nsetGroup\n#\n\n\n\n\nint\n \nsetGroup\n( \nuint8_t\n group)\n#\n\n\nDescription\n#\n\n\nSets the radio to listen to packets sent with the given group id.  \n\n\nParameters\n#\n\n\n\n\nuint8_t\n group - The group to join. A micro:bit can only listen to one group ID at any time.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ndataReady\n#\n\n\n\n\nint\n \ndataReady\n()\n#\n\n\nDescription\n#\n\n\nDetermines the number of packets ready to be processed.  \n\n\nReturns\n#\n\n\nThe number of packets in the receive buffer. \n\n\nrecv\n#\n\n\n\n\nFrameBuffer\n \nrecv\n()\n#\n\n\nDescription\n#\n\n\nRetrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.  \n\n\nReturns\n#\n\n\nThe buffer containing the the packet. If no data is available, NULL is returned.\n\n\n\n\nNote\n\n\nOnce  recv()  has been called, it is the callers responsibility to delete the buffer when appropriate. \n\n\n\n\nsend\n#\n\n\n\n\nint\n \nsend\n( \nFrameBuffer  *\n buffer)\n#\n\n\nDescription\n#\n\n\nTransmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.  \n\n\nParameters\n#\n\n\n\n\nFrameBuffer  *\n buffer\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "radio"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#ubitradio",
            "text": "",
            "title": "uBit.radio"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#overview",
            "text": "The central processor unit (CPU) on the micro:bit is a Nordic Semiconductor  nRF51822 . In addition to being a general purpose\ncomputer processor, this chip also contains a built-in 2.4GHz radio module.  This radio can be configured in a number of\nways, and is primarily designed to run the Bluetooth Low Energy (BLE) protocol. However, it can also be placed into a much\nsimpler mode of operation based that allows simple, direct micro:bit to micro:bit communication.  The  MicroBitRadio  component is made up of three classes -  MicroBitRadio ,  MicroBitRadioEvent  and  MicroBitRadioDatagram . Together,\nthese provide the ability to send general purpose data packets from one micro:bit to another, and to extend a message bus to span multiple micro:bits\u2026\nso if you raise an event on one micro:bit, you can receive it on another using the normal  listen  mechanism!   Note  It is not currently possible to run the  MicroBitRadio  component and Bluetooth Low Energy (BLE) at the same time. If you want to use the  MicroBitRadio  functionality, you need to disable the BLE stack on your micro:bit by compiling the runtime with  #define MICROBIT_BLE_ENABLED 0  in your  inc/MicroBitConfig.h  file.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#capabilities",
            "text": "This component provides a very easy to use, flexible, broadcast radio channel. Anything you send from one micro:bit, can be received by any other micro:bits nearby.\nIt is designed to provide a powerful but simple introduction to the world of wireless communications, and can let you create a whole range of applications from\nbuilding your own friend detectors to creating remote control cars.  A key principle of this component is  privacy , which is built in from the ground up. So, when you send any data, there is nothing inherent in this protocol\nwhich can be used to identify you or your micro:bit. All devices look identical. Therefore, if you want to be able to identify yourself, you need to add this to your own data.      Capability  Brief Description      Frequency  1MHz narrowband, typically 2.407 GHz. Use configurable in the 2.400 GHz - 2.499 GHz band.    Channel Rate  1Mbps.    Maximum Transfer Unit  Typically 32 bytes, but reconfigurable in code up to 1024 bytes.    Addressing  All devices share the same address to guarantee user privacy.    Encryption  None. User level encryption (or BLE) should be considered if secture channels are required.    Meshing  None. (yet!)    Error Detection  16 bit hardware CRC.    Transmisson Power  Eight user configurable settings from 0 (-30dbm) to 7 (+4dbm).    Transmisson Range  Approx. 20m at 0dbm.",
            "title": "Capabilities"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#using-microbitradio",
            "text": "To write your radio enabled applications, you will likely want to use either the  MicroBitRadioDatagram  class, or the  MicroBitRadioEvent  class.  Both of these are created for you as part of the standard uBit object, so this is a choice, not a compromise! :-)",
            "title": "Using MicroBitRadio"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#microbitradiodatagram",
            "text": "This is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time.\nThis data can be provided as array of bytes, a text string, or  PacketBuffer .  You can send a packet at any time using the  uBit.radio.datagram.send  function.  Any other micro:bits in range will detect the transmitted packet, and make the packet available through the uBit.radio.datagram.recv  function.  Any micro:bits receiving a datagram packet will also raise a  MICROBIT_RADIO_EVT_DATAGRAM  event to indicate\nthat some data is ready to be read.  For example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car.  You might decide that simply sending a  1  means turn left, and a  2  means turn right, so you may write a program like this for the remote control:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send(\"1\");\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send(\"2\");\n\n        uBit.sleep(100);\n    }\n}  \u2026and one like this for the remote control car:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s == \"1\")\n    {\n        uBit.io.P0.setServoValue(0);\n        uBit.display.print(\"A\");\n    }\n\n    if (s == \"2\")\n    {\n        uBit.io.P0.setServoValue(180);\n        uBit.display.print(\"B\");\n    }\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}",
            "title": "MicroBitRadioDatagram"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#using-packetbuffers",
            "text": "If you prefer to send a raw series of bytes rather than a text string (which is much more common in communication networks), you can use the  PacketBuffer  type.\nThis gives total freedom over the data being shared. Simply create a  PacketBuffer  of the size you need, and you can read or write data using standard C\narray syntax.  For example, here is an similar program using a  PacketBuffer :  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    // Create a packet containing just a single byte.\n    PacketBuffer b(1);\n\n    while(1)\n    {\n        b[0] = 0;\n        if (uBit.buttonA.isPressed())\n            b[0] = 1;\n\n        else if (uBit.buttonB.isPressed())\n            b[0] = 2;\n\n        uBit.radio.datagram.send(b);\n        uBit.sleep(100);\n    }\n}  \u2026and one like this for the remote control car:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nvoid onData(MicroBitEvent e)\n{\n    PacketBuffer p = uBit.radio.datagram.recv();\n\n    if (p[0] == 1)\n    {\n        uBit.io.P0.setServoValue(0);\n        uBit.display.print(\"A\");\n    }\n\n    if (p[0] == 2)\n    {\n        uBit.io.P0.setServoValue(180);\n        uBit.display.print(\"B\");\n    }\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}",
            "title": "Using PacketBuffers"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#microbitradioevent",
            "text": "It is also possible to transparently send and receive events over the  MicroBitRadio  channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.  To use this functionality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the  MicroBitMessageBus  for details of how to write\nevent handlers.  For example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.init();\n    uBit.radio.enable();\n\n    // Ensure the radio is listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    // Just for varierty, this time we'll periodically check to see if a button if pressed.\n    // We can, of course, use an event handler for this too.\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(100);\n    }\n}  \u2026and on the micro:bits wanting to receive the event:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync(\"Something!\");\n}\n\nint main()\n{\n    uBit.init();\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}",
            "title": "MicroBitRadioEvent"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#defining-groups",
            "text": "It is easy to imagine situations where you would like to have different groups of micro:bits communicating independently.  For example, consider a classroom where 8 groups of four children are working on different\nprojects - it would not be very useful if packets sent by one group interfered with the other groups!  To address this, the  MicroBitRadio  allows users to define a  group  to which their micro:bit belongs.  micro:bits can only ever be a member of one group at a time, and any packets sent will only be received by other micro:bits in the same group.  Groups are simply numbers, and a micro:bit\u2019s group can be set at anytime by the programmer through the  setGroup  function. If a group is not specified, the default group of 0 will be used.  For example:  #include \"MicroBit.h\"\n\nMicroBit    uBit;\n\nint main()\n{\n    uBit.init();\n    uBit.radio.setGroup(10);\n}",
            "title": "Defining Groups"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_RADIO  29    MICROBIT_ID_RADIO_DATA_READY  30",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#message-bus-events",
            "text": "Constant  Value      MICROBIT_RADIO_EVT_DATAGRAM  1",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#microbitradio",
            "text": "",
            "title": "MicroBitRadio()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description",
            "text": "Constructor.    Initialise the  MicroBitRadio .     Note  This class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#microbitradio-uint16_t-id",
            "text": "",
            "title": "MicroBitRadio( uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_1",
            "text": "Constructor.    Initialise the  MicroBitRadio .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters",
            "text": "uint16_t  id    Note  This class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#settransmitpower",
            "text": "",
            "title": "setTransmitPower"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-settransmitpower-int-power",
            "text": "",
            "title": "int setTransmitPower( int power)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_2",
            "text": "Change the output power level of the transmitter to the given value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters_1",
            "text": "int  power - a value in the range 0..7, where 0 is the lowest power and 7 is the highest.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#setfrequencyband",
            "text": "",
            "title": "setFrequencyBand"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-setfrequencyband-int-band",
            "text": "",
            "title": "int setFrequencyBand( int band)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_3",
            "text": "Change the transmission and reception band of the radio to the given channel",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters_2",
            "text": "int  band - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_1",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#getrxbuf",
            "text": "",
            "title": "getRxBuf"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#framebuffer-getrxbuf",
            "text": "",
            "title": "FrameBuffer getRxBuf()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_4",
            "text": "Retrieve a pointer to the currently allocated receive buffer. This is the area of memory actively being used by the radio hardware to store incoming data.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_2",
            "text": "a pointer to the current receive buffer.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#queuerxbuf",
            "text": "",
            "title": "queueRxBuf"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-queuerxbuf",
            "text": "",
            "title": "int queueRxBuf()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_5",
            "text": "Attempt to queue a buffer received by the radio hardware, if sufficient space is available.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_3",
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion).",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#setrssi",
            "text": "",
            "title": "setRSSI"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-setrssi-uint8_t-rssi",
            "text": "",
            "title": "int setRSSI( uint8_t rssi)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_6",
            "text": "Sets the RSSI for the most recent packet.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters_3",
            "text": "uint8_t  rssi - the new rssi value.    Note  should only be called from RADIO_IRQHandler\u2026",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#getrssi",
            "text": "",
            "title": "getRSSI"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-getrssi",
            "text": "",
            "title": "int getRSSI()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_7",
            "text": "Retrieves the current RSSI for the most recent packet.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_4",
            "text": "the most recent RSSI value or MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#enable",
            "text": "",
            "title": "enable"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-enable",
            "text": "",
            "title": "int enable()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_8",
            "text": "Initialises the radio for use as a multipoint sender/receiver",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_5",
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#disable",
            "text": "",
            "title": "disable"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-disable",
            "text": "",
            "title": "int disable()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_9",
            "text": "Disables the radio for use as a multipoint sender/receiver.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_6",
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#setgroup",
            "text": "",
            "title": "setGroup"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-setgroup-uint8_t-group",
            "text": "",
            "title": "int setGroup( uint8_t group)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_10",
            "text": "Sets the radio to listen to packets sent with the given group id.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters_4",
            "text": "uint8_t  group - The group to join. A micro:bit can only listen to one group ID at any time.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_7",
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#dataready",
            "text": "",
            "title": "dataReady"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-dataready",
            "text": "",
            "title": "int dataReady()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_11",
            "text": "Determines the number of packets ready to be processed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_8",
            "text": "The number of packets in the receive buffer.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#recv",
            "text": "",
            "title": "recv"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#framebuffer-recv",
            "text": "",
            "title": "FrameBuffer recv()"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_12",
            "text": "Retrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_9",
            "text": "The buffer containing the the packet. If no data is available, NULL is returned.   Note  Once  recv()  has been called, it is the callers responsibility to delete the buffer when appropriate.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#send",
            "text": "",
            "title": "send"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#int-send-framebuffer-42-buffer",
            "text": "",
            "title": "int send( FrameBuffer  * buffer)"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#description_13",
            "text": "Transmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#parameters_5",
            "text": "FrameBuffer  *  buffer",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radio/#returns_10",
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/",
            "text": "MicroBitImage\n#\n\n\nOverview\n#\n\n\nMicroBitImage\n represents a bitmap picture.\n\n\nImages can be of any size, and each pixel on the image has an individual brightness value in the range 0 - 255.\n\n\nOnce created, this class also provides functions to undertake graphical operations on that image, including setting pixels, clearing the image, pasting one\nimage onto another at a given position, shifting the content of an image and comparing and copying images.\n\n\nIt is designed to work with the \nMicroBitDisplay\n class to allow the creation of animations and visual effects.\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating Images\n#\n\n\nImages are easy to create - just create them like a variable, but provide the details requested in one of the constructor function shown below. This may sound complex, but is quite simple when you get used to it. For example, to create\na blank, 2x2 image:\n\n\nMicroBitImage image(2,2);\n\n\n\n\nYou can also create one from a text string that represents the pixel values that you want. This is a really easy way to create icons and emojis in your code.\n\n\nThe string constructor for a \nMicroBitImage\n takes the form of a series of comma separate values. Each value is the brightness of a pixel, starting at the top left of your image and working\nto the right. Whenever you put a newline character \n\\n\n in your string, this moves onto a new line of pixels.\n\n\nSo to create a 3x3 image that is a picture of a cross, you might write:\n\n\nMicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\n\n\n\n\nManipulating Images\n#\n\n\nOnce you have created an image, you can use any of the functions listed in the API below to change that image. For example, you can use \nsetPixelValue\n to change an individual pixel.\n\n\nIn the example below, you can see how to change the centre pixel in our cross image\ncreated earlier:\n\n\ncross.setPixelValue(1,1,0);\n\n\n\n\n\n\nNote\n\n\nCo-ordinates are indexed from zero, with the origin (0,0) being at the top left of the image.\n\n\n\n\nYou can print characters onto an image\u2026\n\n\nMicroBitImage image(5,5);\nimage.print('J');\n\n\n\n\nYou can also paste the content of one image onto another - either at the origin, or somewhere else:\n\n\nMicroBitImage image(5,5);\nimage.paste(cross);\n\n\n\n\nMicroBitImage image(5,5);\nimage.paste(cross, 1, 1);\n\n\n\n\nand of course, you can display your image on the LEDs using the \nMicroBitDisplay\n class:\n\n\nMicroBitImage image(5,5);\nimage.paste(cross);\nuBit.display.print(image);\n\n\n\n\nComparing and Assigning Images\n#\n\n\nMicroBitImage is a \nmanaged type\n, so you can pass images as parameters to functions, store then and assign them to other variables without having to worry about memory leaks.\n\n\nThe type will count the number of times it is used, and will delete itself as soon as your image is not used anymore.\n\n\nYou can assign images just like any other variable. So this is perfectly permitted, and memory safe:\n\n\nMicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\nMicroBitImage img;\n\nimg = cross;\nuBit.display.print(img);\n\n\n\n\nAs is this:\n\n\nvoid doSomething(MicroBitImage i)\n{\n    uBit.display.print(img);\n}\n\nint main()\n{\n    MicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\n\n    doSomething(cross);\n}\n\n\n\n\nYou can also compare images:\n\n\nMicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\nMicroBitImage img;\n\nimg = cross;\n\nif (img == cross)\n    uBit.display.scroll(\"SAME!\");\n\n\n\n\nStoring Images in Flash Memory\n#\n\n\nThe micro:bit is a \nvery\n constrained device in terms of Random Access Memory (RAM). Unlike modern PCs that typically have over 4 Gigabytes of RAM (around four thousand million bytes!), the micro:bit has only 16 Kilobytes (16 thousand bytes!), and if you take a look at the memory map, you will see most of this is already committed to running the Bluetooth stack.\n\n\nBy default, any \nMicroBitImage\n you create will be stored in this precious RAM, so that you have the ability to change it. However, it is not uncommon to have read-only images. in this case, we can store the image in FLASH memory (the same place as your program), of which the micro:bit has 256 Kilobytes.  \n\n\nShould you want to create an store a constant image in flash, you can do so using the following constructor, it is a little more complicated, but can save you memory:\n\n\n\n\nThe array of bytes should always start with 0xff, 0xff - which tell the runtime that this image is stored in FLASH memory.\n\n\nThe next number should be the width in pixels, followed by a zero.\n\n\nThe next number should be the height in pixels, followed by a zero.\n\n\nThe following bytes are then individual pixel brightness values, starting at the top left, then working left to right, top to bottom until the bottom right corner is reached.\n\n\n\n\n\n\nNote\n\n\nIf you create an image this way, none of the functions to change the content will work on that image (e.g. \nsetPixelValue\n, \npaste\n, etc).\n\n\n\n\n    const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};\n\n    MicroBitImage i((ImageData*)heart);\n    uBit.display.animate(i,5);\n}\n\n\n\n\nAPI\n#\n\n\nleakData\n#\n\n\n\n\nImageData\n \nleakData\n()\n#\n\n\nDescription\n#\n\n\nGet current ptr, do not decr() it, and set the current instance to empty image.  \n\n\nThis is to be used by specialized runtimes which pass  ImageData  around.           \n\n\ngetBitmap\n#\n\n\n\n\nuint8_t *\n \ngetBitmap\n()\n#\n\n\nDescription\n#\n\n\nReturn a 2D array representing the bitmap image.           \n\n\nConstructor\n#\n\n\n\n\nMicroBitImage( \nImageData  *\n ptr)\n#\n\n\nDescription\n#\n\n\nConstructor. Create an image from a specially prepared constant array, with no copying. Will call ptr->incr().  \n\n\nParameters\n#\n\n\n\n\nImageData  *\n ptr - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n#\n\n\n static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart); \n\n\n\n\n\n\nMicroBitImage()\n#\n\n\nDescription\n#\n\n\nDefault Constructor. Creates a new reference to the empty  MicroBitImage  bitmap  \n\n\nExample\n#\n\n\n MicroBitImage i(); //an empty image instance \n\n\n\n\n\n\nMicroBitImage( \nconst  MicroBitImage  &\n image)\n#\n\n\nDescription\n#\n\n\nCopy Constructor. Add ourselves as a reference to an existing  MicroBitImage .  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n image - The  MicroBitImage  to reference.\n\n\n\n\nExample\n#\n\n\n MicroBitImage i(\"0,1,0,1,0\\n\"); \n MicroBitImage i2(i); //points to i \n\n\n\n\n\n\nMicroBitImage( \nconst char *\n s)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a blank bitmap representation of a given size.  \n\n\nParameters\n#\n\n\n\n\nconst char *\n s - A text based representation of the image given whitespace delimited numeric values.\n\n\n\n\nExample\n#\n\n\n MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a blank bitmap representation of a given size.  \n\n\nx \n\n\nthe width of the image.  \n\n\ny \n\n\nthe height of the image.  \n\n\nBitmap buffer is linear, with 8 bits per pixel, row by row, top to bottom with no word alignment. Stride is therefore the image width in pixels. in where w and h are width and height respectively, the layout is therefore:  \n\n\n|[0,0]\u2026[w,o][1,0]\u2026[w,1] \u2026 [[w,h]  \n\n\nA copy of the image is made in RAM, as images are mutable.           \n\n\nParameters\n#\n\n\n\n\nconst int16_t\n x - the width of the image.\n\n\nconst int16_t\n y - the height of the image.\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y,  \nconst uint8_t *\n bitmap)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a bitmap representation of a given size, based on a given buffer.  \n\n\nParameters\n#\n\n\n\n\nconst int16_t\n x - the width of the image.\n\n\nconst int16_t\n y - the height of the image.\n\n\nconst uint8_t *\n bitmap - a 2D array representing the image.\n\n\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n\n\n\n\noperator=\n#\n\n\n\n\nMicroBitImage\n \noperator=\n( \nconst  MicroBitImage  &\n i)\n#\n\n\nDescription\n#\n\n\nCopy assign operation.  \n\n\nCalled when one  MicroBitImage  is assigned the value of another using the \u2018=\u2019 operator.  \n\n\nDecrement our reference count and free up the buffer as necessary.  \n\n\nThen, update our buffer to refer to that of the supplied  MicroBitImage , and increase its reference count.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n i\n\n\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = i; // i1 now references i \n\n\n\n\noperator==\n#\n\n\n\n\nbool\n \noperator==\n( \nconst  MicroBitImage  &\n i)\n#\n\n\nDescription\n#\n\n\nEquality operation.  \n\n\nCalled when one  MicroBitImage  is tested to be equal to another using the \u2018==\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n i - The  MicroBitImage  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  MicroBitImage  is identical to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n display.scroll(\"true\"); \n\n\n\n\nclear\n#\n\n\n\n\nvoid\n \nclear\n()\n#\n\n\nDescription\n#\n\n\nResets all pixels in this image to 0.  \n\n\nExample\n#\n\n\n MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.clear(); \n\n\n\n\nsetPixelValue\n#\n\n\n\n\nint\n \nsetPixelValue\n( \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n value)\n#\n\n\nDescription\n#\n\n\nSets the pixel at the given co-ordinates to a given value.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n x - The co-ordinate of the pixel to change.\n\n\nint16_t\n y - The co-ordinate of the pixel to change.\n\n\nuint8_t\n value - The new value of the pixel (the brightness level 0-255)\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.setPixelValue(0,0,255); \n\n\n\n\n\n\nNote\n\n\nall coordinates originate from the top left of an image. \n\n\n\n\ngetPixelValue\n#\n\n\n\n\nint\n \ngetPixelValue\n( \nint16_t\n x,  \nint16_t\n y)\n#\n\n\nDescription\n#\n\n\nRetrieves the value of a given pixel.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n x - The x co-ordinate of the pixel to read. Must be within the dimensions of the image.\n\n\nint16_t\n y - The y co-ordinate of the pixel to read. Must be within the dimensions of the image.\n\n\n\n\nReturns\n#\n\n\nThe value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.getPixelValue(0,0); //should be 0; \n\n\n\n\nprintImage\n#\n\n\n\n\nint\n \nprintImage\n( \nint16_t\n x,  \nint16_t\n y,  \nconst uint8_t *\n bitmap)\n#\n\n\nDescription\n#\n\n\nReplaces the content of this image with that of a given 2D array representing the image.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n x - the width of the image. Must be within the dimensions of the image.\n\n\nint16_t\n y - the width of the image. Must be within the dimensions of the image.\n\n\nconst uint8_t *\n bitmap - a 2D array representing the image.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart); \n\n\n\n\n\n\nNote\n\n\nall coordinates originate from the top left of an image. \n\n\n\n\npaste\n#\n\n\n\n\nint\n \npaste\n( \nconst  MicroBitImage  &\n image)\n#\n\n\nDescription\n#\n\n\nPastes a given bitmap at the given co-ordinates.  \n\n\nAny pixels in the relevant area of this image are replaced.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n image - The  MicroBitImage  to paste.\n\n\n\n\nReturns\n#\n\n\nThe number of pixels written.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n \npaste\n( \nconst  MicroBitImage  &\n image,  \nint16_t\n x)\n#\n\n\nDescription\n#\n\n\nPastes a given bitmap at the given co-ordinates.  \n\n\nAny pixels in the relevant area of this image are replaced.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n image - The  MicroBitImage  to paste.\n\n\nint16_t\n x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nThe number of pixels written.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n \npaste\n( \nconst  MicroBitImage  &\n image,  \nint16_t\n x,  \nint16_t\n y)\n#\n\n\nDescription\n#\n\n\nPastes a given bitmap at the given co-ordinates.  \n\n\nAny pixels in the relevant area of this image are replaced.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n image - The  MicroBitImage  to paste.\n\n\nint16_t\n x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nint16_t\n y - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nThe number of pixels written.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n \npaste\n( \nconst  MicroBitImage  &\n image,  \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n alpha)\n#\n\n\nDescription\n#\n\n\nPastes a given bitmap at the given co-ordinates.  \n\n\nAny pixels in the relevant area of this image are replaced.  \n\n\nParameters\n#\n\n\n\n\nconst  MicroBitImage  &\n image - The  MicroBitImage  to paste.\n\n\nint16_t\n x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nint16_t\n y - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nuint8_t\n alpha - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nThe number of pixels written.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\nprint\n#\n\n\n\n\nint\n \nprint\n( \nchar\n c)\n#\n\n\nDescription\n#\n\n\nPrints a character to the display at the given location  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\n\n\nint\n \nprint\n( \nchar\n c,  \nint16_t\n x)\n#\n\n\nDescription\n#\n\n\nPrints a character to the display at the given location  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\nint16_t\n x - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\n\n\nint\n \nprint\n( \nchar\n c,  \nint16_t\n x,  \nint16_t\n y)\n#\n\n\nDescription\n#\n\n\nPrints a character to the display at the given location  \n\n\nParameters\n#\n\n\n\n\nchar\n c - The character to display.\n\n\nint16_t\n x - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\nint16_t\n y - The y co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\nshiftLeft\n#\n\n\n\n\nint\n \nshiftLeft\n( \nint16_t\n n)\n#\n\n\nDescription\n#\n\n\nShifts the pixels in this Image a given number of pixels to the left.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n n - The number of pixels to shift.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n\n\n\n\nshiftRight\n#\n\n\n\n\nint\n \nshiftRight\n( \nint16_t\n n)\n#\n\n\nDescription\n#\n\n\nShifts the pixels in this Image a given number of pixels to the right.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n n - The number of pixels to shift.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n i.shiftRight(5); // a big heart \n\n\n\n\nshiftUp\n#\n\n\n\n\nint\n \nshiftUp\n( \nint16_t\n n)\n#\n\n\nDescription\n#\n\n\nShifts the pixels in this Image a given number of pixels to upward.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n n - The number of pixels to shift.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1); \n\n\n\n\nshiftDown\n#\n\n\n\n\nint\n \nshiftDown\n( \nint16_t\n n)\n#\n\n\nDescription\n#\n\n\nShifts the pixels in this Image a given number of pixels to downward.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n n - The number of pixels to shift.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1); \n\n\n\n\ngetWidth\n#\n\n\n\n\nint\n \ngetWidth\n()\n#\n\n\nDescription\n#\n\n\nGets the width of this image.  \n\n\nReturns\n#\n\n\nThe width of this image.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); // equals 10... \n\n\n\n\ngetHeight\n#\n\n\n\n\nint\n \ngetHeight\n()\n#\n\n\nDescription\n#\n\n\nGets the height of this image.  \n\n\nReturns\n#\n\n\nThe height of this image.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); // equals 5... \n\n\n\n\ngetSize\n#\n\n\n\n\nint\n \ngetSize\n()\n#\n\n\nDescription\n#\n\n\nGets number of bytes in the bitmap, ie., width * height.  \n\n\nReturns\n#\n\n\nThe size of the bitmap.\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); // equals 50... \n\n\n\n\ntoString\n#\n\n\n\n\nManagedString\n \ntoString\n()\n#\n\n\nDescription\n#\n\n\nConverts the bitmap to a csv  ManagedString .  \n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); // \"0,1,0,1,0,0,0,0,0,0\\n...\" \n\n\n\n\ncrop\n#\n\n\n\n\nMicroBitImage\n \ncrop\n( \nint\n startx,  \nint\n starty,  \nint\n finx,  \nint\n finy)\n#\n\n\nDescription\n#\n\n\nCrops the image to the given dimensions.  \n\n\nParameters\n#\n\n\n\n\nint\n startx - the location to start the crop in the x-axis\n\n\nint\n starty - the location to start the crop in the y-axis\n\n\nint\n finx\n\n\nint\n finy\n\n\n\n\nExample\n#\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.crop(0,0,2,2).toString() // \"0,1\\n1,1\\n\" \n\n\n\n\nisReadOnly\n#\n\n\n\n\nbool\n \nisReadOnly\n()\n#\n\n\nDescription\n#\n\n\nCheck if image is read-only (i.e., residing in flash).           \n\n\nclone\n#\n\n\n\n\nMicroBitImage\n \nclone\n()\n#\n\n\nDescription\n#\n\n\nCreate a copy of the image bitmap. Used particularly, when  isReadOnly()  is true.  \n\n\nReturns\n#\n\n\nan instance of  MicroBitImage  which can be modified independently of the current instance",
            "title": "MicroBitImage"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage",
            "text": "",
            "title": "MicroBitImage"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#overview",
            "text": "MicroBitImage  represents a bitmap picture.  Images can be of any size, and each pixel on the image has an individual brightness value in the range 0 - 255.  Once created, this class also provides functions to undertake graphical operations on that image, including setting pixels, clearing the image, pasting one\nimage onto another at a given position, shifting the content of an image and comparing and copying images.  It is designed to work with the  MicroBitDisplay  class to allow the creation of animations and visual effects.   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#creating-images",
            "text": "Images are easy to create - just create them like a variable, but provide the details requested in one of the constructor function shown below. This may sound complex, but is quite simple when you get used to it. For example, to create\na blank, 2x2 image:  MicroBitImage image(2,2);  You can also create one from a text string that represents the pixel values that you want. This is a really easy way to create icons and emojis in your code.  The string constructor for a  MicroBitImage  takes the form of a series of comma separate values. Each value is the brightness of a pixel, starting at the top left of your image and working\nto the right. Whenever you put a newline character  \\n  in your string, this moves onto a new line of pixels.  So to create a 3x3 image that is a picture of a cross, you might write:  MicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");",
            "title": "Creating Images"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#manipulating-images",
            "text": "Once you have created an image, you can use any of the functions listed in the API below to change that image. For example, you can use  setPixelValue  to change an individual pixel.  In the example below, you can see how to change the centre pixel in our cross image\ncreated earlier:  cross.setPixelValue(1,1,0);   Note  Co-ordinates are indexed from zero, with the origin (0,0) being at the top left of the image.   You can print characters onto an image\u2026  MicroBitImage image(5,5);\nimage.print('J');  You can also paste the content of one image onto another - either at the origin, or somewhere else:  MicroBitImage image(5,5);\nimage.paste(cross);  MicroBitImage image(5,5);\nimage.paste(cross, 1, 1);  and of course, you can display your image on the LEDs using the  MicroBitDisplay  class:  MicroBitImage image(5,5);\nimage.paste(cross);\nuBit.display.print(image);",
            "title": "Manipulating Images"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#comparing-and-assigning-images",
            "text": "MicroBitImage is a  managed type , so you can pass images as parameters to functions, store then and assign them to other variables without having to worry about memory leaks.  The type will count the number of times it is used, and will delete itself as soon as your image is not used anymore.  You can assign images just like any other variable. So this is perfectly permitted, and memory safe:  MicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\nMicroBitImage img;\n\nimg = cross;\nuBit.display.print(img);  As is this:  void doSomething(MicroBitImage i)\n{\n    uBit.display.print(img);\n}\n\nint main()\n{\n    MicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\n\n    doSomething(cross);\n}  You can also compare images:  MicroBitImage cross(\"0,255,0\\n255,255,255\\n0,255,0\\n\");\nMicroBitImage img;\n\nimg = cross;\n\nif (img == cross)\n    uBit.display.scroll(\"SAME!\");",
            "title": "Comparing and Assigning Images"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#storing-images-in-flash-memory",
            "text": "The micro:bit is a  very  constrained device in terms of Random Access Memory (RAM). Unlike modern PCs that typically have over 4 Gigabytes of RAM (around four thousand million bytes!), the micro:bit has only 16 Kilobytes (16 thousand bytes!), and if you take a look at the memory map, you will see most of this is already committed to running the Bluetooth stack.  By default, any  MicroBitImage  you create will be stored in this precious RAM, so that you have the ability to change it. However, it is not uncommon to have read-only images. in this case, we can store the image in FLASH memory (the same place as your program), of which the micro:bit has 256 Kilobytes.    Should you want to create an store a constant image in flash, you can do so using the following constructor, it is a little more complicated, but can save you memory:   The array of bytes should always start with 0xff, 0xff - which tell the runtime that this image is stored in FLASH memory.  The next number should be the width in pixels, followed by a zero.  The next number should be the height in pixels, followed by a zero.  The following bytes are then individual pixel brightness values, starting at the top left, then working left to right, top to bottom until the bottom right corner is reached.    Note  If you create an image this way, none of the functions to change the content will work on that image (e.g.  setPixelValue ,  paste , etc).       const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0};\n\n    MicroBitImage i((ImageData*)heart);\n    uBit.display.animate(i,5);\n}",
            "title": "Storing Images in Flash Memory"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#leakdata",
            "text": "",
            "title": "leakData"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#imagedata-leakdata",
            "text": "",
            "title": "ImageData leakData()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description",
            "text": "Get current ptr, do not decr() it, and set the current instance to empty image.    This is to be used by specialized runtimes which pass  ImageData  around.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#getbitmap",
            "text": "",
            "title": "getBitmap"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#uint8_t-42-getbitmap",
            "text": "",
            "title": "uint8_t * getBitmap()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_1",
            "text": "Return a 2D array representing the bitmap image.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-imagedata-42-ptr",
            "text": "",
            "title": "MicroBitImage( ImageData  * ptr)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_2",
            "text": "Constructor. Create an image from a specially prepared constant array, with no copying. Will call ptr->incr().",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters",
            "text": "ImageData  *  ptr - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example",
            "text": "static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage_1",
            "text": "",
            "title": "MicroBitImage()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_3",
            "text": "Default Constructor. Creates a new reference to the empty  MicroBitImage  bitmap",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_1",
            "text": "MicroBitImage i(); //an empty image instance",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-const-microbitimage-image",
            "text": "",
            "title": "MicroBitImage( const  MicroBitImage  &amp; image)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_4",
            "text": "Copy Constructor. Add ourselves as a reference to an existing  MicroBitImage .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_1",
            "text": "const  MicroBitImage  &  image - The  MicroBitImage  to reference.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_2",
            "text": "MicroBitImage i(\"0,1,0,1,0\\n\"); \n MicroBitImage i2(i); //points to i",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-const-char-42-s",
            "text": "",
            "title": "MicroBitImage( const char * s)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_5",
            "text": "Constructor. Create a blank bitmap representation of a given size.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_2",
            "text": "const char *  s - A text based representation of the image given whitespace delimited numeric values.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_3",
            "text": "MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y",
            "text": "",
            "title": "MicroBitImage( const int16_t x,  const int16_t y)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_6",
            "text": "Constructor. Create a blank bitmap representation of a given size.    x   the width of the image.    y   the height of the image.    Bitmap buffer is linear, with 8 bits per pixel, row by row, top to bottom with no word alignment. Stride is therefore the image width in pixels. in where w and h are width and height respectively, the layout is therefore:    |[0,0]\u2026[w,o][1,0]\u2026[w,1] \u2026 [[w,h]    A copy of the image is made in RAM, as images are mutable.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_3",
            "text": "const int16_t  x - the width of the image.  const int16_t  y - the height of the image.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y-const-uint8_t-42-bitmap",
            "text": "",
            "title": "MicroBitImage( const int16_t x,  const int16_t y,  const uint8_t * bitmap)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_7",
            "text": "Constructor. Create a bitmap representation of a given size, based on a given buffer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_4",
            "text": "const int16_t  x - the width of the image.  const int16_t  y - the height of the image.  const uint8_t *  bitmap - a 2D array representing the image.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_4",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#operator",
            "text": "",
            "title": "operator="
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-operator-const-microbitimage-i",
            "text": "",
            "title": "MicroBitImage operator=( const  MicroBitImage  &amp; i)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_8",
            "text": "Copy assign operation.    Called when one  MicroBitImage  is assigned the value of another using the \u2018=\u2019 operator.    Decrement our reference count and free up the buffer as necessary.    Then, update our buffer to refer to that of the supplied  MicroBitImage , and increase its reference count.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_5",
            "text": "const  MicroBitImage  &  i",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_5",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = i; // i1 now references i",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#operator_1",
            "text": "",
            "title": "operator=="
        },
        {
            "location": "/lancaster-mbed/data-types/image/#bool-operator-const-microbitimage-i",
            "text": "",
            "title": "bool operator==( const  MicroBitImage  &amp; i)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_9",
            "text": "Equality operation.    Called when one  MicroBitImage  is tested to be equal to another using the \u2018==\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_6",
            "text": "const  MicroBitImage  &  i - The  MicroBitImage  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns",
            "text": "true if this  MicroBitImage  is identical to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_6",
            "text": "MicroBitDisplay display; \n MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n display.scroll(\"true\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#clear",
            "text": "",
            "title": "clear"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#void-clear",
            "text": "",
            "title": "void clear()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_10",
            "text": "Resets all pixels in this image to 0.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_7",
            "text": "MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.clear();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#setpixelvalue",
            "text": "",
            "title": "setPixelValue"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-setpixelvalue-int16_t-x-int16_t-y-uint8_t-value",
            "text": "",
            "title": "int setPixelValue( int16_t x,  int16_t y,  uint8_t value)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_11",
            "text": "Sets the pixel at the given co-ordinates to a given value.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_7",
            "text": "int16_t  x - The co-ordinate of the pixel to change.  int16_t  y - The co-ordinate of the pixel to change.  uint8_t  value - The new value of the pixel (the brightness level 0-255)",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_1",
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_8",
            "text": "MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.setPixelValue(0,0,255);    Note  all coordinates originate from the top left of an image.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#getpixelvalue",
            "text": "",
            "title": "getPixelValue"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-getpixelvalue-int16_t-x-int16_t-y",
            "text": "",
            "title": "int getPixelValue( int16_t x,  int16_t y)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_12",
            "text": "Retrieves the value of a given pixel.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_8",
            "text": "int16_t  x - The x co-ordinate of the pixel to read. Must be within the dimensions of the image.  int16_t  y - The y co-ordinate of the pixel to read. Must be within the dimensions of the image.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_2",
            "text": "The value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_9",
            "text": "MicroBitImage i(\"0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\"); // 5x5 image \n i.getPixelValue(0,0); //should be 0;",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#printimage",
            "text": "",
            "title": "printImage"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-printimage-int16_t-x-int16_t-y-const-uint8_t-42-bitmap",
            "text": "",
            "title": "int printImage( int16_t x,  int16_t y,  const uint8_t * bitmap)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_13",
            "text": "Replaces the content of this image with that of a given 2D array representing the image.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_9",
            "text": "int16_t  x - the width of the image. Must be within the dimensions of the image.  int16_t  y - the width of the image. Must be within the dimensions of the image.  const uint8_t *  bitmap - a 2D array representing the image.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_3",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_10",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart);    Note  all coordinates originate from the top left of an image.",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#paste",
            "text": "",
            "title": "paste"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-paste-const-microbitimage-image",
            "text": "",
            "title": "int paste( const  MicroBitImage  &amp; image)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_14",
            "text": "Pastes a given bitmap at the given co-ordinates.    Any pixels in the relevant area of this image are replaced.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_10",
            "text": "const  MicroBitImage  &  image - The  MicroBitImage  to paste.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_4",
            "text": "The number of pixels written.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_11",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-paste-const-microbitimage-image-int16_t-x",
            "text": "",
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_15",
            "text": "Pastes a given bitmap at the given co-ordinates.    Any pixels in the relevant area of this image are replaced.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_11",
            "text": "const  MicroBitImage  &  image - The  MicroBitImage  to paste.  int16_t  x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_5",
            "text": "The number of pixels written.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_12",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-paste-const-microbitimage-image-int16_t-x-int16_t-y",
            "text": "",
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x,  int16_t y)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_16",
            "text": "Pastes a given bitmap at the given co-ordinates.    Any pixels in the relevant area of this image are replaced.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_12",
            "text": "const  MicroBitImage  &  image - The  MicroBitImage  to paste.  int16_t  x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.  int16_t  y - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_6",
            "text": "The number of pixels written.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_13",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-paste-const-microbitimage-image-int16_t-x-int16_t-y-uint8_t-alpha",
            "text": "",
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x,  int16_t y,  uint8_t alpha)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_17",
            "text": "Pastes a given bitmap at the given co-ordinates.    Any pixels in the relevant area of this image are replaced.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_13",
            "text": "const  MicroBitImage  &  image - The  MicroBitImage  to paste.  int16_t  x - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.  int16_t  y - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.  uint8_t  alpha - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_7",
            "text": "The number of pixels written.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_14",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#print",
            "text": "",
            "title": "print"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-print-char-c",
            "text": "",
            "title": "int print( char c)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_18",
            "text": "Prints a character to the display at the given location",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_14",
            "text": "char  c - The character to display.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_8",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_15",
            "text": "MicroBitImage i(5,5); \n i.print('a');",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-print-char-c-int16_t-x",
            "text": "",
            "title": "int print( char c,  int16_t x)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_19",
            "text": "Prints a character to the display at the given location",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_15",
            "text": "char  c - The character to display.  int16_t  x - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_9",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_16",
            "text": "MicroBitImage i(5,5); \n i.print('a');",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-print-char-c-int16_t-x-int16_t-y",
            "text": "",
            "title": "int print( char c,  int16_t x,  int16_t y)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_20",
            "text": "Prints a character to the display at the given location",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_16",
            "text": "char  c - The character to display.  int16_t  x - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.  int16_t  y - The y co-ordinate of on the image to place the top left of the character. Defaults to 0.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_10",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_17",
            "text": "MicroBitImage i(5,5); \n i.print('a');",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#shiftleft",
            "text": "",
            "title": "shiftLeft"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-shiftleft-int16_t-n",
            "text": "",
            "title": "int shiftLeft( int16_t n)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_21",
            "text": "Shifts the pixels in this Image a given number of pixels to the left.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_17",
            "text": "int16_t  n - The number of pixels to shift.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_11",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_18",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#shiftright",
            "text": "",
            "title": "shiftRight"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-shiftright-int16_t-n",
            "text": "",
            "title": "int shiftRight( int16_t n)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_22",
            "text": "Shifts the pixels in this Image a given number of pixels to the right.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_18",
            "text": "int16_t  n - The number of pixels to shift.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_12",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_19",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n i.shiftRight(5); // a big heart",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#shiftup",
            "text": "",
            "title": "shiftUp"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-shiftup-int16_t-n",
            "text": "",
            "title": "int shiftUp( int16_t n)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_23",
            "text": "Shifts the pixels in this Image a given number of pixels to upward.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_19",
            "text": "int16_t  n - The number of pixels to shift.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_13",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_20",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#shiftdown",
            "text": "",
            "title": "shiftDown"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-shiftdown-int16_t-n",
            "text": "",
            "title": "int shiftDown( int16_t n)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_24",
            "text": "Shifts the pixels in this Image a given number of pixels to downward.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_20",
            "text": "int16_t  n - The number of pixels to shift.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_14",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_21",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#getwidth",
            "text": "",
            "title": "getWidth"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-getwidth",
            "text": "",
            "title": "int getWidth()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_25",
            "text": "Gets the width of this image.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_15",
            "text": "The width of this image.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_22",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); // equals 10...",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#getheight",
            "text": "",
            "title": "getHeight"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-getheight",
            "text": "",
            "title": "int getHeight()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_26",
            "text": "Gets the height of this image.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_16",
            "text": "The height of this image.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_23",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); // equals 5...",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#getsize",
            "text": "",
            "title": "getSize"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#int-getsize",
            "text": "",
            "title": "int getSize()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_27",
            "text": "Gets number of bytes in the bitmap, ie., width * height.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_17",
            "text": "The size of the bitmap.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_24",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); // equals 50...",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#tostring",
            "text": "",
            "title": "toString"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#managedstring-tostring",
            "text": "",
            "title": "ManagedString toString()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_28",
            "text": "Converts the bitmap to a csv  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_25",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); // \"0,1,0,1,0,0,0,0,0,0\\n...\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#crop",
            "text": "",
            "title": "crop"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-crop-int-startx-int-starty-int-finx-int-finy",
            "text": "",
            "title": "MicroBitImage crop( int startx,  int starty,  int finx,  int finy)"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_29",
            "text": "Crops the image to the given dimensions.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#parameters_21",
            "text": "int  startx - the location to start the crop in the x-axis  int  starty - the location to start the crop in the y-axis  int  finx  int  finy",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#example_26",
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.crop(0,0,2,2).toString() // \"0,1\\n1,1\\n\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#isreadonly",
            "text": "",
            "title": "isReadOnly"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#bool-isreadonly",
            "text": "",
            "title": "bool isReadOnly()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_30",
            "text": "Check if image is read-only (i.e., residing in flash).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#clone",
            "text": "",
            "title": "clone"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#microbitimage-clone",
            "text": "",
            "title": "MicroBitImage clone()"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#description_31",
            "text": "Create a copy of the image bitmap. Used particularly, when  isReadOnly()  is true.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/image/#returns_18",
            "text": "an instance of  MicroBitImage  which can be modified independently of the current instance",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/event/",
            "text": "MicroBitEvent\n#\n\n\nOverview\n#\n\n\nComputer programs execute sequentially - one line after another, following the logic of the program you have written.\nSometimes though, we want to be able to determine \nwhen\n something has happened, and write some code to decide what should\nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the micro:bit radio. For these sorts of cases, we create a \nMicroBitEvent\n.\n\n\nCreating Events\n#\n\n\nMany components will raise events when interesting things occur. For example, \n\u2018MicroBitAccelerometer\u2019\n will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall and \n\u2018MicroBitButton\u2019\n will send events on a range of button up, down, click and hold events.\nProgrammers are also free to send their own events whenever they feel it would be useful. \nMicroBitEvent\ns are \nvery\n simple, and consist of\nonly two numbers:\n\n\n\n\nsource\n - A number identifying the component that created the event.\n\n\nvalue\n - A number unique to the source that identifies the event.\n\n\n\n\nThe documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the \nbutton documentation\n to see that the source MICROBIT_ID_BUTTON_A has the value \u20181\u2019,\nand an event MICROBIT_BUTTON_EVT_CLICK with the value \u20183\u2019 is generated when a button is clicked.\n\n\nCreating an event is easy - just create a MicroBitEvent with the \nsource\n and \nvalue\n you need, and the runtime takes care of the rest:\n\n\nMicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);\n\n\n\n\nFeel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the \nmessageBus\n page for a complete table of the reserved source IDs.\n\n\nDetecting Events\n#\n\n\nThe micro:bit runtime has a component called the \nMicroBitMessageBus\n, and its job is remember which events your program is interested in, and\nto deliver \nMicroBitEvent\ns to your program as they occur.\n\n\nTo find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an \nevent handler\n.\n\n\nYou write an event handler through the \nMicroBitMessageBus\n \nlisten\n function.  \n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n source\n\n\nuint16_t\n value - A component specific code indicating the cause of the event.\n\n\n\n\nExample\n#\n\n\n // Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE); \n\n\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value,  \nMicroBitEventLaunchMode\n mode)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n source\n\n\nuint16_t\n value - A component specific code indicating the cause of the event.\n\n\nMicroBitEventLaunchMode\n mode - Optional definition of how the event should be processed after construction (if at all): CREATE_ONLY:  MicroBitEvent  is initialised, and no further processing takes place. CREATE_AND_FIRE:  MicroBitEvent  is initialised, and its event handlers are immediately fired (not suitable for use in interrupts!).\n\n\n\n\nExample\n#\n\n\n // Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE); \n\n\n\n\n\n\nMicroBitEvent()\n#\n\n\nDescription\n#\n\n\nDefault constructor - initialises all values, and sets timestamp to the current time.           \n\n\nfire\n#\n\n\n\n\nvoid\n \nfire\n()\n#\n\n\nDescription\n#\n\n\nFires this  MicroBitEvent  onto the Default  EventModel , or a custom one!",
            "title": "MicroBitEvent"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#microbitevent",
            "text": "",
            "title": "MicroBitEvent"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#overview",
            "text": "Computer programs execute sequentially - one line after another, following the logic of the program you have written.\nSometimes though, we want to be able to determine  when  something has happened, and write some code to decide what should\nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the micro:bit radio. For these sorts of cases, we create a  MicroBitEvent .",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#creating-events",
            "text": "Many components will raise events when interesting things occur. For example,  \u2018MicroBitAccelerometer\u2019  will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall and  \u2018MicroBitButton\u2019  will send events on a range of button up, down, click and hold events.\nProgrammers are also free to send their own events whenever they feel it would be useful.  MicroBitEvent s are  very  simple, and consist of\nonly two numbers:   source  - A number identifying the component that created the event.  value  - A number unique to the source that identifies the event.   The documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the  button documentation  to see that the source MICROBIT_ID_BUTTON_A has the value \u20181\u2019,\nand an event MICROBIT_BUTTON_EVT_CLICK with the value \u20183\u2019 is generated when a button is clicked.  Creating an event is easy - just create a MicroBitEvent with the  source  and  value  you need, and the runtime takes care of the rest:  MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);  Feel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the  messageBus  page for a complete table of the reserved source IDs.",
            "title": "Creating Events"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#detecting-events",
            "text": "The micro:bit runtime has a component called the  MicroBitMessageBus , and its job is remember which events your program is interested in, and\nto deliver  MicroBitEvent s to your program as they occur.  To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an  event handler .  You write an event handler through the  MicroBitMessageBus   listen  function.",
            "title": "Detecting Events"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#microbitevent-uint16_t-source-uint16_t-value",
            "text": "",
            "title": "MicroBitEvent( uint16_t source,  uint16_t value)"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#description",
            "text": "Constructor.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#parameters",
            "text": "uint16_t  source  uint16_t  value - A component specific code indicating the cause of the event.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#example",
            "text": "// Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#microbitevent-uint16_t-source-uint16_t-value-microbiteventlaunchmode-mode",
            "text": "",
            "title": "MicroBitEvent( uint16_t source,  uint16_t value,  MicroBitEventLaunchMode mode)"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#description_1",
            "text": "Constructor.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#parameters_1",
            "text": "uint16_t  source  uint16_t  value - A component specific code indicating the cause of the event.  MicroBitEventLaunchMode  mode - Optional definition of how the event should be processed after construction (if at all): CREATE_ONLY:  MicroBitEvent  is initialised, and no further processing takes place. CREATE_AND_FIRE:  MicroBitEvent  is initialised, and its event handlers are immediately fired (not suitable for use in interrupts!).",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#example_1",
            "text": "// Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#microbitevent_1",
            "text": "",
            "title": "MicroBitEvent()"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#description_2",
            "text": "Default constructor - initialises all values, and sets timestamp to the current time.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#fire",
            "text": "",
            "title": "fire"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#void-fire",
            "text": "",
            "title": "void fire()"
        },
        {
            "location": "/lancaster-mbed/data-types/event/#description_3",
            "text": "Fires this  MicroBitEvent  onto the Default  EventModel , or a custom one!",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/",
            "text": "ManagedString\n#\n\n\nOverview\n#\n\n\nManagedString\n represents a text string in the micro:bit runtime.\n\n\nA string is simply a sequence of characters such as \u201cjoe\u201d or \u201cmicro:bit\u201d.\n\n\nIn the C language, the end of the string is marked by a special character (a \nNULL\n character, commonly with the value zero).\n\n\nSimple strings are often represented as literal character arrays:\n\n\nuBit.display.scroll(\"HELLO\");\n\n\n\n\nWhich is almost exactly the same as:\n\n\nchar message[6] = {'H', 'E', 'L', 'L', 'O', 0};\nuBit.display.scroll(message);\n\n\n\n\nAlthough fantastically simple, strings of this form are well known to lead to memory leaks and be sources of bugs in code (especially when the programmers are still learning!).\n\n\nAs a result, most modern high level languages such as Java, C#, Javascript and TouchDevelop do not use strings of this format.\nInstead, they provide code that is capable of ensuring strings remain safe.\n\n\nManagedString\n provides this equivalent functionality for the micro:bit, as a building block for higher level languages. However, it can also makes programming the micro:bit in C easier too!\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating Strings\n#\n\n\nImages are simple to create - just create them like a variable, and provide the text or number you would like to build the string from.\n\n\nFor example:\n\n\nManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString n(42);\n\n\n\n\nThe runtime will also create a \nManagedString\n for you from a number or quoted literal anytime a function requires a \nManagedString\n.\n\n\nIn the example below, even though the scroll function of \nMicroBitDisplay\n expects a \nManagedString\n,\nit is totally fine to pass a literal value in quotes or a number (or in fact, any parameter that is listed in the API section as a legal constructor will work):\n\n\nManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString n(42);\n\n// All these calls are legal:\nuBit.display.scroll(hi);\nuBit.display.scroll(n);\nuBit.display.scroll(\"THANKS!\");\n\n\n\n\nManipulating Strings\n#\n\n\nManagedStrings are \nimmutable\n, meaning that once created, they cannot be changed. However, you can join them, search them, extract characters from them and create other strings!\n\n\nThe micro:bit runtime makes use of \noperator overloading\n to keep this easy to use.\n\n\nIn other words, we make use of the \n=\n \n+\n \n<\n \n>\n and \n==\n operators to let you easily assign and compare strings.\n\n\nAlthough this may sound complex, it is easy once you see how to do it.\n\n\nHere is how you would join together more than one string, and assign it to a new one:\n\n\nManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString space(\" \");\n\nManagedString s = hi + space + message;\n\n// This would say \"HELLO micro:bit\" on the LED display.\nuBit.display.scroll(s);\n\n\n\n\nYou can compare strings (alphabetically) in a similar way:\n\n\nManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\n\nif (hi == message)\n    uBit.display.scroll(\"SAME\");\n\nif (hi < message)\n    uBit.display.scroll(\"LESS\");\n\nif (hi > message)\n    uBit.display.scroll(\"MORE\");\n\n\n\n\nYou can also determine the length of a string, extract parts of strings, retrieve individual characters at a given index or convert a ManagedString to a C-style character array using the \nlength\n, \nsubstring\n, \ncharAt\n and \ntoCharArray\n functions respectively.\n\n\nSee the API documentation below for further details.\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nManagedString( \nStringData  *\n ptr)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a managed string from a specially prepared string literal.  \n\n\nParameters\n#\n\n\n\n\nStringData  *\n ptr - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n#\n\n\n static const char hello[] __attribute__ ((aligned (4))) = \"\\xff\\xff\\x05\\x00\" \"Hello\"; \n ManagedString s((StringData*)(void*)hello); \n\n\n\n\nleakData\n#\n\n\n\n\nStringData\n \nleakData\n()\n#\n\n\nDescription\n#\n\n\nGet current ptr, do not decr() it, and set the current instance to empty string.  \n\n\nThis is to be used by specialized runtimes which pass  StringData  around.           \n\n\nConstructor\n#\n\n\n\n\nManagedString( \nconst char *\n str)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a managed string from a pointer to an 8-bit character buffer.  \n\n\nThe buffer is copied to ensure safe memory management (the supplied character buffer may be declared on the stack for instance).  \n\n\nParameters\n#\n\n\n\n\nconst char *\n str - The character array on which to base the new  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\"); \n\n\n\n\n\n\nManagedString( \nconst int\n value)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a managed string from a given integer.  \n\n\nParameters\n#\n\n\n\n\nconst int\n value - The integer from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s(20); \n\n\n\n\n\n\nManagedString( \nconst char\n value)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a managed string from a given char.  \n\n\nParameters\n#\n\n\n\n\nconst char\n value - The character from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s('a'); \n\n\n\n\n\n\nManagedString( \nPacketBuffer\n buffer)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a  ManagedString  from a  PacketBuffer . All bytes in the  PacketBuffer  are added to the  ManagedString .  \n\n\nParameters\n#\n\n\n\n\nPacketBuffer\n buffer - The PacktBuffer from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s = radio.datagram.recv(); \n\n\n\n\n\n\nManagedString( \nconst char *\n str,  \nconst int16_t\n length)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a  ManagedString  from a pointer to an 8-bit character buffer of a given length.  \n\n\nThe buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).  \n\n\nParameters\n#\n\n\n\n\nconst char *\n str - The character array on which to base the new  ManagedString .\n\n\nconst int16_t\n length - The length of the character array\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\",7); \n\n\n\n\n\n\nManagedString( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nCopy constructor. Makes a new  ManagedString  identical to the one supplied.  \n\n\nShares the character buffer and reference count with the supplied  ManagedString .  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to copy.\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\"); \n ManagedString p(s); \n\n\n\n\n\n\nManagedString()\n#\n\n\nDescription\n#\n\n\nDefault constructor.  \n\n\nCreate an empty  ManagedString .  \n\n\nExample\n#\n\n\n ManagedString s(); \n\n\n\n\noperator=\n#\n\n\n\n\nManagedString\n \noperator=\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nCopy assign operation.  \n\n\nCalled when one  ManagedString  is assigned the value of another.  \n\n\nIf the  ManagedString  being assigned is already referring to a character buffer, decrement the reference count and free up the buffer as necessary.  \n\n\nThen, update our character buffer to refer to that of the supplied  ManagedString , and increase its reference count.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to copy.\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n p = s // p now points to s, s' ref is incremented \n\n\n\n\noperator==\n#\n\n\n\n\nbool\n \noperator==\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nEquality operation.  \n\n\nCalled when one  ManagedString  is tested to be equal to another using the \u2018==\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is identical to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n\n if(p == s) \n display.scroll(\"We are the same!\"); \n else \n display.scroll(\"We are different!\"); //p is not equal to s - this will be called \n\n\n\n\noperator<\n#\n\n\n\n\nbool\n \noperator<\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nInequality operation.  \n\n\nCalled when one  ManagedString  is tested to be less than another using the \u2018<\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(s < p) \n display.scroll(\"a is before b!\"); //a is before b \n else \n display.scroll(\"b is before a!\"); \n\n\n\n\noperator>\n#\n\n\n\n\nbool\n \noperator>\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nInequality operation.  \n\n\nCalled when one  ManagedString  is tested to be greater than another using the \u2018>\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(p>a) \n display.scroll(\"b is after a!\"); //b is after a \n else \n display.scroll(\"a is after b!\"); \n\n\n\n\nsubstring\n#\n\n\n\n\nManagedString\n \nsubstring\n( \nint16_t\n start,  \nint16_t\n length)\n#\n\n\nDescription\n#\n\n\nExtracts a  ManagedString  from this string, at the position provided.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n start - The index of the first character to extract, indexed from zero.\n\n\nint16_t\n length - The number of characters to extract from the start position\n\n\n\n\nReturns\n#\n\n\na  ManagedString  representing the requested substring.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcdefg\"); \n\n display.scroll(s.substring(0,2)) // displays \"ab\" \n\n\n\n\ncharAt\n#\n\n\n\n\nchar\n \ncharAt\n( \nint16_t\n index)\n#\n\n\nDescription\n#\n\n\nProvides a character value at a given position in the string, indexed from zero.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n index - The position of the character to return.\n\n\n\n\nReturns\n#\n\n\nthe character at posisiton index, zero if index is invalid.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.charAt(1)) // scrolls \"b\" \n\n\n\n\ntoCharArray\n#\n\n\n\n\nconst char *\n \ntoCharArray\n()\n#\n\n\nDescription\n#\n\n\nProvides an immutable 8 bit wide character buffer representing this string.  \n\n\nReturns\n#\n\n\na pointer to the character buffer. \n\n\nlength\n#\n\n\n\n\nint16_t\n \nlength\n()\n#\n\n\nDescription\n#\n\n\nDetermines the length of this  ManagedString  in characters.  \n\n\nReturns\n#\n\n\nthe length of the string in characters.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.length()) // scrolls \"4\"",
            "title": "ManagedString"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring",
            "text": "",
            "title": "ManagedString"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#overview",
            "text": "ManagedString  represents a text string in the micro:bit runtime.  A string is simply a sequence of characters such as \u201cjoe\u201d or \u201cmicro:bit\u201d.  In the C language, the end of the string is marked by a special character (a  NULL  character, commonly with the value zero).  Simple strings are often represented as literal character arrays:  uBit.display.scroll(\"HELLO\");  Which is almost exactly the same as:  char message[6] = {'H', 'E', 'L', 'L', 'O', 0};\nuBit.display.scroll(message);  Although fantastically simple, strings of this form are well known to lead to memory leaks and be sources of bugs in code (especially when the programmers are still learning!).  As a result, most modern high level languages such as Java, C#, Javascript and TouchDevelop do not use strings of this format.\nInstead, they provide code that is capable of ensuring strings remain safe.  ManagedString  provides this equivalent functionality for the micro:bit, as a building block for higher level languages. However, it can also makes programming the micro:bit in C easier too!   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#creating-strings",
            "text": "Images are simple to create - just create them like a variable, and provide the text or number you would like to build the string from.  For example:  ManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString n(42);  The runtime will also create a  ManagedString  for you from a number or quoted literal anytime a function requires a  ManagedString .  In the example below, even though the scroll function of  MicroBitDisplay  expects a  ManagedString ,\nit is totally fine to pass a literal value in quotes or a number (or in fact, any parameter that is listed in the API section as a legal constructor will work):  ManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString n(42);\n\n// All these calls are legal:\nuBit.display.scroll(hi);\nuBit.display.scroll(n);\nuBit.display.scroll(\"THANKS!\");",
            "title": "Creating Strings"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#manipulating-strings",
            "text": "ManagedStrings are  immutable , meaning that once created, they cannot be changed. However, you can join them, search them, extract characters from them and create other strings!  The micro:bit runtime makes use of  operator overloading  to keep this easy to use.  In other words, we make use of the  =   +   <   >  and  ==  operators to let you easily assign and compare strings.  Although this may sound complex, it is easy once you see how to do it.  Here is how you would join together more than one string, and assign it to a new one:  ManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\nManagedString space(\" \");\n\nManagedString s = hi + space + message;\n\n// This would say \"HELLO micro:bit\" on the LED display.\nuBit.display.scroll(s);  You can compare strings (alphabetically) in a similar way:  ManagedString hi(\"HELLO\");\nManagedString message(\"micro:bit\");\n\nif (hi == message)\n    uBit.display.scroll(\"SAME\");\n\nif (hi < message)\n    uBit.display.scroll(\"LESS\");\n\nif (hi > message)\n    uBit.display.scroll(\"MORE\");  You can also determine the length of a string, extract parts of strings, retrieve individual characters at a given index or convert a ManagedString to a C-style character array using the  length ,  substring ,  charAt  and  toCharArray  functions respectively.  See the API documentation below for further details.",
            "title": "Manipulating Strings"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-stringdata-42-ptr",
            "text": "",
            "title": "ManagedString( StringData  * ptr)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description",
            "text": "Constructor. Create a managed string from a specially prepared string literal.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters",
            "text": "StringData  *  ptr - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example",
            "text": "static const char hello[] __attribute__ ((aligned (4))) = \"\\xff\\xff\\x05\\x00\" \"Hello\"; \n ManagedString s((StringData*)(void*)hello);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#leakdata",
            "text": "",
            "title": "leakData"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#stringdata-leakdata",
            "text": "",
            "title": "StringData leakData()"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_1",
            "text": "Get current ptr, do not decr() it, and set the current instance to empty string.    This is to be used by specialized runtimes which pass  StringData  around.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#constructor_1",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-const-char-42-str",
            "text": "",
            "title": "ManagedString( const char * str)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_2",
            "text": "Constructor.    Create a managed string from a pointer to an 8-bit character buffer.    The buffer is copied to ensure safe memory management (the supplied character buffer may be declared on the stack for instance).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_1",
            "text": "const char *  str - The character array on which to base the new  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_1",
            "text": "ManagedString s(\"abcdefg\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-const-int-value",
            "text": "",
            "title": "ManagedString( const int value)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_3",
            "text": "Constructor.    Create a managed string from a given integer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_2",
            "text": "const int  value - The integer from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_2",
            "text": "ManagedString s(20);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-const-char-value",
            "text": "",
            "title": "ManagedString( const char value)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_4",
            "text": "Constructor. Create a managed string from a given char.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_3",
            "text": "const char  value - The character from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_3",
            "text": "ManagedString s('a');",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-packetbuffer-buffer",
            "text": "",
            "title": "ManagedString( PacketBuffer buffer)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_5",
            "text": "Constructor. Create a  ManagedString  from a  PacketBuffer . All bytes in the  PacketBuffer  are added to the  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_4",
            "text": "PacketBuffer  buffer - The PacktBuffer from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_4",
            "text": "ManagedString s = radio.datagram.recv();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-const-char-42-str-const-int16_t-length",
            "text": "",
            "title": "ManagedString( const char * str,  const int16_t length)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_6",
            "text": "Constructor. Create a  ManagedString  from a pointer to an 8-bit character buffer of a given length.    The buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_5",
            "text": "const char *  str - The character array on which to base the new  ManagedString .  const int16_t  length - The length of the character array",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_5",
            "text": "ManagedString s(\"abcdefg\",7);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-const-managedstring-s",
            "text": "",
            "title": "ManagedString( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_7",
            "text": "Copy constructor. Makes a new  ManagedString  identical to the one supplied.    Shares the character buffer and reference count with the supplied  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_6",
            "text": "const  ManagedString  &  s - The  ManagedString  to copy.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_6",
            "text": "ManagedString s(\"abcdefg\"); \n ManagedString p(s);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring_1",
            "text": "",
            "title": "ManagedString()"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_8",
            "text": "Default constructor.    Create an empty  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_7",
            "text": "ManagedString s();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#operator",
            "text": "",
            "title": "operator="
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-operator-const-managedstring-s",
            "text": "",
            "title": "ManagedString operator=( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_9",
            "text": "Copy assign operation.    Called when one  ManagedString  is assigned the value of another.    If the  ManagedString  being assigned is already referring to a character buffer, decrement the reference count and free up the buffer as necessary.    Then, update our character buffer to refer to that of the supplied  ManagedString , and increase its reference count.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_7",
            "text": "const  ManagedString  &  s - The  ManagedString  to copy.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_8",
            "text": "ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n p = s // p now points to s, s' ref is incremented",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#operator_1",
            "text": "",
            "title": "operator=="
        },
        {
            "location": "/lancaster-mbed/data-types/string/#bool-operator-const-managedstring-s",
            "text": "",
            "title": "bool operator==( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_10",
            "text": "Equality operation.    Called when one  ManagedString  is tested to be equal to another using the \u2018==\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_8",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns",
            "text": "true if this  ManagedString  is identical to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_9",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n\n if(p == s) \n display.scroll(\"We are the same!\"); \n else \n display.scroll(\"We are different!\"); //p is not equal to s - this will be called",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#operator_2",
            "text": "",
            "title": "operator&lt;"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#bool-operator-const-managedstring-s_1",
            "text": "",
            "title": "bool operator&lt;( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_11",
            "text": "Inequality operation.    Called when one  ManagedString  is tested to be less than another using the \u2018<\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_9",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_1",
            "text": "true if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_10",
            "text": "MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(s < p) \n display.scroll(\"a is before b!\"); //a is before b \n else \n display.scroll(\"b is before a!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#operator_3",
            "text": "",
            "title": "operator&gt;"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#bool-operator-const-managedstring-s_2",
            "text": "",
            "title": "bool operator&gt;( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_12",
            "text": "Inequality operation.    Called when one  ManagedString  is tested to be greater than another using the \u2018>\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_10",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_2",
            "text": "true if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_11",
            "text": "MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(p>a) \n display.scroll(\"b is after a!\"); //b is after a \n else \n display.scroll(\"a is after b!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#substring",
            "text": "",
            "title": "substring"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#managedstring-substring-int16_t-start-int16_t-length",
            "text": "",
            "title": "ManagedString substring( int16_t start,  int16_t length)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_13",
            "text": "Extracts a  ManagedString  from this string, at the position provided.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_11",
            "text": "int16_t  start - The index of the first character to extract, indexed from zero.  int16_t  length - The number of characters to extract from the start position",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_3",
            "text": "a  ManagedString  representing the requested substring.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_12",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcdefg\"); \n\n display.scroll(s.substring(0,2)) // displays \"ab\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#charat",
            "text": "",
            "title": "charAt"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#char-charat-int16_t-index",
            "text": "",
            "title": "char charAt( int16_t index)"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_14",
            "text": "Provides a character value at a given position in the string, indexed from zero.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#parameters_12",
            "text": "int16_t  index - The position of the character to return.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_4",
            "text": "the character at posisiton index, zero if index is invalid.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_13",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.charAt(1)) // scrolls \"b\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#tochararray",
            "text": "",
            "title": "toCharArray"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#const-char-42-tochararray",
            "text": "",
            "title": "const char * toCharArray()"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_15",
            "text": "Provides an immutable 8 bit wide character buffer representing this string.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_5",
            "text": "a pointer to the character buffer.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#length",
            "text": "",
            "title": "length"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#int16_t-length",
            "text": "",
            "title": "int16_t length()"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#description_16",
            "text": "Determines the length of this  ManagedString  in characters.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#returns_6",
            "text": "the length of the string in characters.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/string/#example_14",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.length()) // scrolls \"4\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/",
            "text": "PacketBuffer\n#\n\n\nOverview\n#\n\n\nThe \nMicroBitRadio\n class provides direct micro:bit to micro:bit communication.\n\n\nIt is often beneficial in both wired and wireless communication protocols to send\nand receive data in a raw format, viewed as an ordered sequence of bytes.\n\n\nThis class provides a basic set of functions for the creation, manipulation and\naccessing of a managed type for byte arrays used to hold network data packets.\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating PacketBuffers\n#\n\n\nPacketBuffer\ns are simple to create - just create them like a variable, and provide the size (in bytes) of the buffer you want to create.\n\n\nPacketBuffer b(16);\n\n\n\n\nAlternatively, if you already have an array of bytes allocated, then you can simply refer to that using a slightly different form:\n\n\nuint8_t data[16];\nPacketBuffer b(data,16);\n\n\n\n\nManipulating PacketBuffers\n#\n\n\nOnce created, the data inside \nPacketBuffer\ns can be freely changed at any time. The simplest way to do this is through the array operators \n[\n and \n]\n.\n\n\nYou can read or write bytes to the buffer by simply dereferencing it with square bracket.\n\n\nFor example: to create, set and send a PacketBuffer on the micro:bit radio, you could do the following:\n\n\nPacketBuffer b(2);\nb[0] = 255;\nb[1] = 10;\n\nuBit.radio.datagram.send(b);\n\n\n\n\nPacketBuffer\ns can also be assigned a value:\n\n\nPacketBuffer b;\nb = uBit.radio.datagram.recv();\n\n\n\n\nIf you need more granular access, the \ngetBytes\n function provides direct access to the memory buffer, presented as a byte array:\n\n\nPacketBuffer b(16);\nuint8_t *buf = b.getBytes();\n\nmemcpy(buf, \"HI\", 2);\n\n\n\n\nFinally, it is also possible to extract the received signal strength of a packet from a \nPacketBuffer\n.\n\n\nThis can provide both a rough indication of the reliability of the link, and a crude but moderately effective mechanism to estimate the distance between two micro:bits.\n\n\nPacketBuffer b;\nb = uBit.radio.datagram.recv();\n\nuBit.display.scroll(b.getRSSI());\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nManagedString( \nStringData  *\n ptr)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a managed string from a specially prepared string literal.  \n\n\nParameters\n#\n\n\n\n\nStringData  *\n ptr - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n#\n\n\n static const char hello[] __attribute__ ((aligned (4))) = \"\\xff\\xff\\x05\\x00\" \"Hello\"; \n ManagedString s((StringData*)(void*)hello); \n\n\n\n\nleakData\n#\n\n\n\n\nStringData\n \nleakData\n()\n#\n\n\nDescription\n#\n\n\nGet current ptr, do not decr() it, and set the current instance to empty string.  \n\n\nThis is to be used by specialized runtimes which pass  StringData  around.           \n\n\nConstructor\n#\n\n\n\n\nManagedString( \nconst char *\n str)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a managed string from a pointer to an 8-bit character buffer.  \n\n\nThe buffer is copied to ensure safe memory management (the supplied character buffer may be declared on the stack for instance).  \n\n\nParameters\n#\n\n\n\n\nconst char *\n str - The character array on which to base the new  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\"); \n\n\n\n\n\n\nManagedString( \nconst int\n value)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a managed string from a given integer.  \n\n\nParameters\n#\n\n\n\n\nconst int\n value - The integer from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s(20); \n\n\n\n\n\n\nManagedString( \nconst char\n value)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a managed string from a given char.  \n\n\nParameters\n#\n\n\n\n\nconst char\n value - The character from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s('a'); \n\n\n\n\n\n\nManagedString( \nPacketBuffer\n buffer)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a  ManagedString  from a  PacketBuffer . All bytes in the  PacketBuffer  are added to the  ManagedString .  \n\n\nParameters\n#\n\n\n\n\nPacketBuffer\n buffer - The PacktBuffer from which to create the  ManagedString .\n\n\n\n\nExample\n#\n\n\n ManagedString s = radio.datagram.recv(); \n\n\n\n\n\n\nManagedString( \nconst char *\n str,  \nconst int16_t\n length)\n#\n\n\nDescription\n#\n\n\nConstructor. Create a  ManagedString  from a pointer to an 8-bit character buffer of a given length.  \n\n\nThe buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).  \n\n\nParameters\n#\n\n\n\n\nconst char *\n str - The character array on which to base the new  ManagedString .\n\n\nconst int16_t\n length - The length of the character array\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\",7); \n\n\n\n\n\n\nManagedString( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nCopy constructor. Makes a new  ManagedString  identical to the one supplied.  \n\n\nShares the character buffer and reference count with the supplied  ManagedString .  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to copy.\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcdefg\"); \n ManagedString p(s); \n\n\n\n\n\n\nManagedString()\n#\n\n\nDescription\n#\n\n\nDefault constructor.  \n\n\nCreate an empty  ManagedString .  \n\n\nExample\n#\n\n\n ManagedString s(); \n\n\n\n\noperator=\n#\n\n\n\n\nManagedString\n \noperator=\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nCopy assign operation.  \n\n\nCalled when one  ManagedString  is assigned the value of another.  \n\n\nIf the  ManagedString  being assigned is already referring to a character buffer, decrement the reference count and free up the buffer as necessary.  \n\n\nThen, update our character buffer to refer to that of the supplied  ManagedString , and increase its reference count.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to copy.\n\n\n\n\nExample\n#\n\n\n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n p = s // p now points to s, s' ref is incremented \n\n\n\n\noperator==\n#\n\n\n\n\nbool\n \noperator==\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nEquality operation.  \n\n\nCalled when one  ManagedString  is tested to be equal to another using the \u2018==\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is identical to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n\n if(p == s) \n display.scroll(\"We are the same!\"); \n else \n display.scroll(\"We are different!\"); //p is not equal to s - this will be called \n\n\n\n\noperator<\n#\n\n\n\n\nbool\n \noperator<\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nInequality operation.  \n\n\nCalled when one  ManagedString  is tested to be less than another using the \u2018<\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(s < p) \n display.scroll(\"a is before b!\"); //a is before b \n else \n display.scroll(\"b is before a!\"); \n\n\n\n\noperator>\n#\n\n\n\n\nbool\n \noperator>\n( \nconst  ManagedString  &\n s)\n#\n\n\nDescription\n#\n\n\nInequality operation.  \n\n\nCalled when one  ManagedString  is tested to be greater than another using the \u2018>\u2019 operator.  \n\n\nParameters\n#\n\n\n\n\nconst  ManagedString  &\n s - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n#\n\n\ntrue if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(p>a) \n display.scroll(\"b is after a!\"); //b is after a \n else \n display.scroll(\"a is after b!\"); \n\n\n\n\nsubstring\n#\n\n\n\n\nManagedString\n \nsubstring\n( \nint16_t\n start,  \nint16_t\n length)\n#\n\n\nDescription\n#\n\n\nExtracts a  ManagedString  from this string, at the position provided.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n start - The index of the first character to extract, indexed from zero.\n\n\nint16_t\n length - The number of characters to extract from the start position\n\n\n\n\nReturns\n#\n\n\na  ManagedString  representing the requested substring.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcdefg\"); \n\n display.scroll(s.substring(0,2)) // displays \"ab\" \n\n\n\n\ncharAt\n#\n\n\n\n\nchar\n \ncharAt\n( \nint16_t\n index)\n#\n\n\nDescription\n#\n\n\nProvides a character value at a given position in the string, indexed from zero.  \n\n\nParameters\n#\n\n\n\n\nint16_t\n index - The position of the character to return.\n\n\n\n\nReturns\n#\n\n\nthe character at posisiton index, zero if index is invalid.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.charAt(1)) // scrolls \"b\" \n\n\n\n\ntoCharArray\n#\n\n\n\n\nconst char *\n \ntoCharArray\n()\n#\n\n\nDescription\n#\n\n\nProvides an immutable 8 bit wide character buffer representing this string.  \n\n\nReturns\n#\n\n\na pointer to the character buffer. \n\n\nlength\n#\n\n\n\n\nint16_t\n \nlength\n()\n#\n\n\nDescription\n#\n\n\nDetermines the length of this  ManagedString  in characters.  \n\n\nReturns\n#\n\n\nthe length of the string in characters.\n\n\nExample\n#\n\n\n MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.length()) // scrolls \"4\"",
            "title": "PacketBuffer"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#packetbuffer",
            "text": "",
            "title": "PacketBuffer"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#overview",
            "text": "The  MicroBitRadio  class provides direct micro:bit to micro:bit communication.  It is often beneficial in both wired and wireless communication protocols to send\nand receive data in a raw format, viewed as an ordered sequence of bytes.  This class provides a basic set of functions for the creation, manipulation and\naccessing of a managed type for byte arrays used to hold network data packets.   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#creating-packetbuffers",
            "text": "PacketBuffer s are simple to create - just create them like a variable, and provide the size (in bytes) of the buffer you want to create.  PacketBuffer b(16);  Alternatively, if you already have an array of bytes allocated, then you can simply refer to that using a slightly different form:  uint8_t data[16];\nPacketBuffer b(data,16);",
            "title": "Creating PacketBuffers"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#manipulating-packetbuffers",
            "text": "Once created, the data inside  PacketBuffer s can be freely changed at any time. The simplest way to do this is through the array operators  [  and  ] .  You can read or write bytes to the buffer by simply dereferencing it with square bracket.  For example: to create, set and send a PacketBuffer on the micro:bit radio, you could do the following:  PacketBuffer b(2);\nb[0] = 255;\nb[1] = 10;\n\nuBit.radio.datagram.send(b);  PacketBuffer s can also be assigned a value:  PacketBuffer b;\nb = uBit.radio.datagram.recv();  If you need more granular access, the  getBytes  function provides direct access to the memory buffer, presented as a byte array:  PacketBuffer b(16);\nuint8_t *buf = b.getBytes();\n\nmemcpy(buf, \"HI\", 2);  Finally, it is also possible to extract the received signal strength of a packet from a  PacketBuffer .  This can provide both a rough indication of the reliability of the link, and a crude but moderately effective mechanism to estimate the distance between two micro:bits.  PacketBuffer b;\nb = uBit.radio.datagram.recv();\n\nuBit.display.scroll(b.getRSSI());",
            "title": "Manipulating PacketBuffers"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-stringdata-42-ptr",
            "text": "",
            "title": "ManagedString( StringData  * ptr)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description",
            "text": "Constructor. Create a managed string from a specially prepared string literal.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters",
            "text": "StringData  *  ptr - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example",
            "text": "static const char hello[] __attribute__ ((aligned (4))) = \"\\xff\\xff\\x05\\x00\" \"Hello\"; \n ManagedString s((StringData*)(void*)hello);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#leakdata",
            "text": "",
            "title": "leakData"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#stringdata-leakdata",
            "text": "",
            "title": "StringData leakData()"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_1",
            "text": "Get current ptr, do not decr() it, and set the current instance to empty string.    This is to be used by specialized runtimes which pass  StringData  around.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#constructor_1",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-const-char-42-str",
            "text": "",
            "title": "ManagedString( const char * str)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_2",
            "text": "Constructor.    Create a managed string from a pointer to an 8-bit character buffer.    The buffer is copied to ensure safe memory management (the supplied character buffer may be declared on the stack for instance).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_1",
            "text": "const char *  str - The character array on which to base the new  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_1",
            "text": "ManagedString s(\"abcdefg\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-const-int-value",
            "text": "",
            "title": "ManagedString( const int value)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_3",
            "text": "Constructor.    Create a managed string from a given integer.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_2",
            "text": "const int  value - The integer from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_2",
            "text": "ManagedString s(20);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-const-char-value",
            "text": "",
            "title": "ManagedString( const char value)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_4",
            "text": "Constructor. Create a managed string from a given char.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_3",
            "text": "const char  value - The character from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_3",
            "text": "ManagedString s('a');",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-packetbuffer-buffer",
            "text": "",
            "title": "ManagedString( PacketBuffer buffer)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_5",
            "text": "Constructor. Create a  ManagedString  from a  PacketBuffer . All bytes in the  PacketBuffer  are added to the  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_4",
            "text": "PacketBuffer  buffer - The PacktBuffer from which to create the  ManagedString .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_4",
            "text": "ManagedString s = radio.datagram.recv();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-const-char-42-str-const-int16_t-length",
            "text": "",
            "title": "ManagedString( const char * str,  const int16_t length)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_6",
            "text": "Constructor. Create a  ManagedString  from a pointer to an 8-bit character buffer of a given length.    The buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_5",
            "text": "const char *  str - The character array on which to base the new  ManagedString .  const int16_t  length - The length of the character array",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_5",
            "text": "ManagedString s(\"abcdefg\",7);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-const-managedstring-s",
            "text": "",
            "title": "ManagedString( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_7",
            "text": "Copy constructor. Makes a new  ManagedString  identical to the one supplied.    Shares the character buffer and reference count with the supplied  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_6",
            "text": "const  ManagedString  &  s - The  ManagedString  to copy.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_6",
            "text": "ManagedString s(\"abcdefg\"); \n ManagedString p(s);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring",
            "text": "",
            "title": "ManagedString()"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_8",
            "text": "Default constructor.    Create an empty  ManagedString .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_7",
            "text": "ManagedString s();",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#operator",
            "text": "",
            "title": "operator="
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-operator-const-managedstring-s",
            "text": "",
            "title": "ManagedString operator=( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_9",
            "text": "Copy assign operation.    Called when one  ManagedString  is assigned the value of another.    If the  ManagedString  being assigned is already referring to a character buffer, decrement the reference count and free up the buffer as necessary.    Then, update our character buffer to refer to that of the supplied  ManagedString , and increase its reference count.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_7",
            "text": "const  ManagedString  &  s - The  ManagedString  to copy.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_8",
            "text": "ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n p = s // p now points to s, s' ref is incremented",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#operator_1",
            "text": "",
            "title": "operator=="
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#bool-operator-const-managedstring-s",
            "text": "",
            "title": "bool operator==( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_10",
            "text": "Equality operation.    Called when one  ManagedString  is tested to be equal to another using the \u2018==\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_8",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns",
            "text": "true if this  ManagedString  is identical to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_9",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n ManagedString p(\"efgh\"); \n\n if(p == s) \n display.scroll(\"We are the same!\"); \n else \n display.scroll(\"We are different!\"); //p is not equal to s - this will be called",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#operator_2",
            "text": "",
            "title": "operator&lt;"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#bool-operator-const-managedstring-s_1",
            "text": "",
            "title": "bool operator&lt;( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_11",
            "text": "Inequality operation.    Called when one  ManagedString  is tested to be less than another using the \u2018<\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_9",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_1",
            "text": "true if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_10",
            "text": "MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(s < p) \n display.scroll(\"a is before b!\"); //a is before b \n else \n display.scroll(\"b is before a!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#operator_3",
            "text": "",
            "title": "operator&gt;"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#bool-operator-const-managedstring-s_2",
            "text": "",
            "title": "bool operator&gt;( const  ManagedString  &amp; s)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_12",
            "text": "Inequality operation.    Called when one  ManagedString  is tested to be greater than another using the \u2018>\u2019 operator.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_10",
            "text": "const  ManagedString  &  s - The  ManagedString  to test ourselves against.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_2",
            "text": "true if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_11",
            "text": "MicroBitDisplay display; \n ManagedString s(\"a\"); \n ManagedString p(\"b\"); \n\n if(p>a) \n display.scroll(\"b is after a!\"); //b is after a \n else \n display.scroll(\"a is after b!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#substring",
            "text": "",
            "title": "substring"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#managedstring-substring-int16_t-start-int16_t-length",
            "text": "",
            "title": "ManagedString substring( int16_t start,  int16_t length)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_13",
            "text": "Extracts a  ManagedString  from this string, at the position provided.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_11",
            "text": "int16_t  start - The index of the first character to extract, indexed from zero.  int16_t  length - The number of characters to extract from the start position",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_3",
            "text": "a  ManagedString  representing the requested substring.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_12",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcdefg\"); \n\n display.scroll(s.substring(0,2)) // displays \"ab\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#charat",
            "text": "",
            "title": "charAt"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#char-charat-int16_t-index",
            "text": "",
            "title": "char charAt( int16_t index)"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_14",
            "text": "Provides a character value at a given position in the string, indexed from zero.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#parameters_12",
            "text": "int16_t  index - The position of the character to return.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_4",
            "text": "the character at posisiton index, zero if index is invalid.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_13",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.charAt(1)) // scrolls \"b\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#tochararray",
            "text": "",
            "title": "toCharArray"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#const-char-42-tochararray",
            "text": "",
            "title": "const char * toCharArray()"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_15",
            "text": "Provides an immutable 8 bit wide character buffer representing this string.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_5",
            "text": "a pointer to the character buffer.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#length",
            "text": "",
            "title": "length"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#int16_t-length",
            "text": "",
            "title": "int16_t length()"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#description_16",
            "text": "Determines the length of this  ManagedString  in characters.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#returns_6",
            "text": "the length of the string in characters.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/data-types/packetbuffer/#example_14",
            "text": "MicroBitDisplay display; \n ManagedString s(\"abcd\"); \n\n display.scroll(s.length()) // scrolls \"4\"",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ble/profile/",
            "text": "BBC micro:bit Bluetooth Profile\n#\n\n\nIntroduction\n#\n\n\nThe BBC micro:bit ships with a default Bluetooth profile included in the run-time firmware.\n\n\nThe profile consists of various \u201cservices\u201d and \u201ccharacteristics\u201d designed to give easy access to the micro:bit\u2019s hardware so that initial exploration of the device\u2019s capabilities may take place using a corresponding application on another, compatible Bluetooth device such as a smartphone.\n\n\nGiven the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer\u2019s own design. The latter case is out of scope for this document which focuses on the standard, default profile only.\n\n\nReference documentation: \nmicro:bit Bluetooth profile specification\n\n\nCredits\n#\n\n\n\n\n\n\nThe Bluetooth profile for micro:bit is the result of a close collaboration between Martin Woolley of Bluetooth SIG (Twitter: @bluetooth_mdw) and Dr Joe Finney of Lancaster University.\n\n\nProfile Design\n#\n\n\nmicro:bit acts as a Bluetooth GAP Peripheral and advertises so that GAP Central devices such as a smart phone can discover and connect to it.\n\n\nStandard Bluetooth SIG \u201cadopted\u201d services have been used where appropriate in conjunction with custom services designed specifically for micro:bit.\n\n\nThe micro:bit default profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.\n\n\nAll services are \u201cprimary services\u201d and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.\n\n\nEase of use has been considered to be more important than having absolute configurability of all aspects of the hardware in the default profile.\n\n\nThe profile was designed using Bluetooth Developer Studio, a free of charge tool available for download from www.bluetooth.com\n\n\nBluetooth Security\n#\n\n\nmicro:bit uses standard Bluetooth security. Bluetooth defines a series of optional security features of which the following are used for micro:bit:\n\n\n\n\n\n\nPairing with passkey and MITM protection\n\n\n\n\n\n\nWhite Listing\n\n\n\n\n\n\nEncrypted link for operations involving most characteristics\n\n\n\n\n\n\nPairing equips the micro:bit and a trusted peer device with the potential to perform security operations when interacting such as utilising an AES 128 bit encrypted link. All interactions involving custom services except for the DFU Control Service must be performed over an encrypted link. Note that encryption will be automatically applied whenever required. If a peer device is not paired with the micro:bit and a secure operation is attempted it will be rejected and the usual, expected behaviour of the peer is that it will initiate the pairing process automatically.\n\n\nWhite listing allows paired devices only to connect to and interact with the micro:bit. Attempts to connect from devices not in the white list are ignored by the Bluetooth Link Layer.\n\n\nAdvertising\n#\n\n\nThe micro:bit will advertise if in \u201cpairing mode\u201d or if it has been previously paired/bonded in which case it will advertise but a white list will be active and connections will only be accepted from previously paired devices. See below for more information on pairing.\n\n\nIn pairing mode the micro:bit will advertise with flags set indicating it is discoverable (LE General Discoverable Mode) as showing here:\n\n\n\n\nIn \u201cnormal mode\u201d (i.e. not pairing mode) advertising packets have neither the LE Limited Discoverable mode or the LE General Discoverable Mode flags set and so in this situation may not be listed in the \u201cavailable Bluetooth devices\u201d screen of some smartphones which have not paired with the micro:bit. This is by design.\n\n\n\n\nPairing\n#\n\n\nTo interact with any service on the micro:bit the peer device must first be paired/bonded with it.\n\n\n\n\n\nHow to pair your BBC micro:bit with an Android phone or tablet\n from \nMartin Woolley\n on \nVimeo\n.\n\n\n\nTo pair with a micro:bit it must first be placed in \u201cpairing mode\u201d. To do this, hold down both buttons A and B and press and hold the reset button. If powered by USB, let go of the reset button but keep holding both buttons A and B down. This will result in the micro:bit going into pairing mode and the words \u201cPAIRING MODE\u201d should be seen scrolling across the display followed by the graphical representation of the micro:bit 5 character identifier.\n\n\nNext, initiate pairing on the peer device. On Android for example, go into Settings/Bluetooth and allow the system to scan for and discover the advertising micro:bit. Select it and pairing will commence. The micro:bit will indicate it\u2019s ready to pair by displaying an arrow which points left towards button A. Press button A and a 6 digit number will be displayed on the micro:bit, one digit at a time. The peer device should now allow you to enter the 6 digit pass key. Do so and if the correct number was entered into the peer, micro:bit will display a tick/check to indicate pairing was achieved.\n\n\nA maximum of 4 devices may be paired with a micro:bit simultaneously (note though that only one paired device may connect to the micro:bit at a time).\n\n\nReference Documentation\n#\n\n\nDetails of the micro:bit\u2019s Bluetooth services, characteristics, the operations they each support and any associated descriptors along with UUID values can be found in the associated \nmicro:bit Bluetooth profile specification\n\n\nA simplified overview appears below.\n\n\nGATT Services\n#\n\n\n\n\n\n\n\n\nService\n\n\nType\n\n\nmicro:bit optionality\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGeneric Access Service\n\n\nAdopted\n\n\nmandatory\n\n\nProvides generic information about the device. Mandatory in GATT profiles.\n\n\n\n\n\n\nGeneric Attribute Service\n\n\nAdopted\n\n\nmandatory\n\n\nCan inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.\n\n\n\n\n\n\nDevice Information Service\n\n\nAdopted\n\n\nmandatory\n\n\nProvides more comprehensive details about the device and its manufacturer\n\n\n\n\n\n\nAccelerometer Service\n\n\nCustom\n\n\noptional\n\n\nProvides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.\n\n\n\n\n\n\nMagnetometer Service\n\n\nCustom\n\n\noptional\n\n\nProvides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \u201ccurrent bearing\u201d value in degrees.\n\n\n\n\n\n\nTemperature Service\n\n\nCustom\n\n\noptional\n\n\nProvides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.\n\n\n\n\n\n\nButton Service\n\n\nCustom\n\n\noptional\n\n\nAllow button state changes to be notified to the client\n\n\n\n\n\n\nLED Service\n\n\nCustom\n\n\noptional\n\n\nAllows access to both the LED \u201cdisplay\u201d grid and the system status LED\n\n\n\n\n\n\nIO Pin Service\n\n\nCustom\n\n\noptional\n\n\nAllows access to and configuration of IO pins on the edge connector.\n\n\n\n\n\n\nEvent Service\n\n\nCustom\n\n\noptional\n\n\nAllows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.\n\n\n\n\n\n\nDFU Control Service\n\n\nCustom\n\n\nmandatory\n\n\nUsed to initiate device firmware update. Defined by Nordic Semiconductor.\n\n\n\n\n\n\nUART Service\n\n\nCustom\n\n\noptional\n\n\nProvides pseudo serial data communications over Bluetooth low energy, allowing arbitrary byte sequences to be exchanged in either direction with a connected peer. Data from micro:bit to peer is transmitted using Bluetooth Indications. Data from the peer to the micro:bit is transmitted using Write or Write No Response PDUs. This is an implementation of Nordic Semicondutor\u2019s UART/Serial Port Emulation over Bluetooth low energy.\n\n\n\n\n\n\n\n\nThe maximum number of bytes which may be transmitted in one PDU is limited to the MTU minus three or 20 octets to be precise.\n\n\nSee https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00072.html for the original Nordic Semiconductor documentation by way of background.\n\n\nNote: This service was added after micro:bits initially shipped to school and so is not in the default image. |\n\n\nKnown issue: the firmware on micro:bits shipped initially to schools contains the full Bluetooth profile. Once the software has been changed by flashing an application created using any of the on-line code editors however, all services are lost except for Device Information Service, Event Service and DFU Control Service. If you need other services you must restore your micro:bit to its original state by installing the \ndefault hex file\n or better still \nthis hex file\n which does not use the display so you can use it over Bluetooth instead.\n\n\nThe following sections elaborate on the description of a service and/or its characteristics. For full details see the \nmicro:bit Bluetooth profile specification\n\n\nAbout the Device Information Service\n#\n\n\nThis is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 3 of those characteristics only.\n\n\nSee \nhttps://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml\n\n\nAbout the Accelerometer Service\n#\n\n\nCharacteristics\n#\n\n\nAccelerometer Data\n : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.\n\n\nAccelerometer Period:\n Determines the frequency with which accelerometer data is reported in milliseconds. Valid values are 1, 2, 5, 10, 20, 80, 160 and 640.\n\n\nAbout the Magnetometer Service\n#\n\n\nCharacteristics\n#\n\n\nMagnetometer Data\n : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.\n\n\nMagnetometer Period\n : Determines the frequency with which magnetometer data is reported in milliseconds. Valid values are 1, 2, 5, 10, 20, 80, 160 and 640.\n\n\nMagnetometer Bearing\n : Compass bearing in degrees from North.\n\n\nNote: to deliver meaningful data the micro:bit magnetometer must first be calibrated. The calibration procedure can be triggered by simply using the compass in your micro:bit program, or adding the MicroBitMagnetometer Bluetooth service to your Bluetooth profile*.\n\n\n* from v2.0.0 of the runtime onwards.\n\n\nAbout the Temperature Service\n#\n\n\nCharacteristics\n#\n\n\nTemperature\n : Signed integer 8 bit value in celsius.\n\n\nTemperature Period\n : Determines the frequency with which temperature data is updated in milliseconds.\n\n\nAbout the Button Service\n#\n\n\nThe Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.\n\n\nAbout the LED Service\n#\n\n\nThe service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.\n\n\nA single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.\n\n\nOther characteristics allow a text string to be written to it by the client for display and the scrolling delay may be set.\n\n\nCharacteristics\n#\n\n\nLED Matrix State\n : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.\n\n\nLED Text\n : A UTF-8 string to be shown on the LED display. Maximum length 20 octets.\n\n\nScrolling Delay\n : Specifies a millisecond delay to wait for in between showing each character on the display.\n\n\nAbout the IO Pin Service\n#\n\n\nCharacteristics\n#\n\n\nPin Data\n : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.\n\n\nWRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.\n\n\nNOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.\n\n\nREAD: A client reading this characteristic will receive Pin Number / Value pairs for \nall\n those pins defined as input pins by the Pin IO Configuration characteristic.\n\n\nThe associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.\n\n\nPin IO Configuration\n : A bit mask (32 bit) which defines which inputs will be read. If the Pin AD Configuration bit mask is also set the pin will be read as an analogue input, if not it will be read as a digital input.  \n\n\nNote that in practice, setting a pin\u2019s mask bit means that it will be read by the micro:bit runtime and, if notifications have been enabled on the Pin Data characteristic, data read will be transmitted to the connected Bluetooth peer device in a Pin Data notification. If the pin\u2019s bit is clear, it  simply means that it will not be read by the micro:bit runtime. By default, pins are configured for output.\n\n\nPin AD Configuration\n : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0 <= n < 19. A value of 0 means digital and 1 means analogue.\n\n\nPWM Control\n : Allows a client to use up to 2 micro:bit pins at a time for PWM output and to set the period and value of the pin(s). This is useful for applications such as the analogue control of LEDs and simple audio tone generation. Note that not all pins support PWM on micro:bit.\n\n\nAbout the Event Service\n#\n\n\nThe Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \u201cevent\u201d will be used here for both event and command types of data.\n\n\nEvents may have an associated value.\n\n\nNote that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.\n\n\nMultiple events of different types may be notified to the client or micro:bit at the same time.\n\n\nEvent data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.\n\n\n\n\n\n\n\n\nstruct event {  uint16 event_type;  uint16 event_value;};\n\n\n\n\n\n\n\n\n\n\nevent_type and event_value are each encoded in little endian format.\n\n\nThe Event Service has four characteristics in total:\n\n\nmicro:bit Requirements\n is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.\n\n\nNote that an event_type of zero means ANY event type and an event_value part set to zero means ANY event value.\n\n\nClient Requirements\n is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.\n\n\nNote that an event_type of zero means ANY event type and an event_value part set to zero means ANY event value.\n\n\nmicro:bit Event\n contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.\n\n\nClient Event\n is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.\n\n\nAbout the DFU Control Service\n#\n\n\nAllows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.\n\n\nCharacteristics\n#\n\n\nDFU Control\n : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this characteristic  means \u201crequest flash code\u201d.\n\n\nAbout the UART Service\n#\n\n\nProvides a pseudo serial interface to the micro:bit for the exchange of arbitrary sequences of bytes. A maximum of 20 octets (MTU of 23 minus 3) can be transmitted in a single operation but a series of operations can be executed to affect something like serial data communications.\n\n\nThis is an implementation of the Nordic Semiconductor UART service:\n\n\nhttps://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00072.html\n\n\nCharacteristics\n#\n\n\nTX Characteristic\n: Allows the micro:bit to transmit a byte array containing an arbitrary number of arbitrary octet values to a connected device. Uses Indications for this purpose.\n\n\nRX Characteristic\n: Allows a connected client to send a byte array containing an arbitrary number of arbitrary octet values to a connected micro:bit using with Write Requests or Write Commands.\n\n\nUsing the Bluetooth Profile\n#\n\n\nClick on the Bluetooth menu and then select one of the Bluetooth services for a page of information dedicated to that service including information for application developers.\n\n\nMartin Woolley\u2019s personal blog contains a series of micro:bit Bluetooth demonstration videos. See \nhttp://bluetooth-mdw.blogspot.co.uk/p/bbc-microbit.html\n\n\nThe Android application featured in the videos was written by Martin and contains a series of demonstrations, each exercising at least one of the micro:bit Bluetooth services. The application  available in github. Information regarding the use of each service appears in the individual service pages of this site.",
            "title": "Profile"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#bbc-microbit-bluetooth-profile",
            "text": "",
            "title": "BBC micro:bit Bluetooth Profile"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#introduction",
            "text": "The BBC micro:bit ships with a default Bluetooth profile included in the run-time firmware.  The profile consists of various \u201cservices\u201d and \u201ccharacteristics\u201d designed to give easy access to the micro:bit\u2019s hardware so that initial exploration of the device\u2019s capabilities may take place using a corresponding application on another, compatible Bluetooth device such as a smartphone.  Given the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer\u2019s own design. The latter case is out of scope for this document which focuses on the standard, default profile only.  Reference documentation:  micro:bit Bluetooth profile specification",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#credits",
            "text": "The Bluetooth profile for micro:bit is the result of a close collaboration between Martin Woolley of Bluetooth SIG (Twitter: @bluetooth_mdw) and Dr Joe Finney of Lancaster University.",
            "title": "Credits"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#profile-design",
            "text": "micro:bit acts as a Bluetooth GAP Peripheral and advertises so that GAP Central devices such as a smart phone can discover and connect to it.  Standard Bluetooth SIG \u201cadopted\u201d services have been used where appropriate in conjunction with custom services designed specifically for micro:bit.  The micro:bit default profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.  All services are \u201cprimary services\u201d and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.  Ease of use has been considered to be more important than having absolute configurability of all aspects of the hardware in the default profile.  The profile was designed using Bluetooth Developer Studio, a free of charge tool available for download from www.bluetooth.com",
            "title": "Profile Design"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#bluetooth-security",
            "text": "micro:bit uses standard Bluetooth security. Bluetooth defines a series of optional security features of which the following are used for micro:bit:    Pairing with passkey and MITM protection    White Listing    Encrypted link for operations involving most characteristics    Pairing equips the micro:bit and a trusted peer device with the potential to perform security operations when interacting such as utilising an AES 128 bit encrypted link. All interactions involving custom services except for the DFU Control Service must be performed over an encrypted link. Note that encryption will be automatically applied whenever required. If a peer device is not paired with the micro:bit and a secure operation is attempted it will be rejected and the usual, expected behaviour of the peer is that it will initiate the pairing process automatically.  White listing allows paired devices only to connect to and interact with the micro:bit. Attempts to connect from devices not in the white list are ignored by the Bluetooth Link Layer.",
            "title": "Bluetooth Security"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#advertising",
            "text": "The micro:bit will advertise if in \u201cpairing mode\u201d or if it has been previously paired/bonded in which case it will advertise but a white list will be active and connections will only be accepted from previously paired devices. See below for more information on pairing.  In pairing mode the micro:bit will advertise with flags set indicating it is discoverable (LE General Discoverable Mode) as showing here:   In \u201cnormal mode\u201d (i.e. not pairing mode) advertising packets have neither the LE Limited Discoverable mode or the LE General Discoverable Mode flags set and so in this situation may not be listed in the \u201cavailable Bluetooth devices\u201d screen of some smartphones which have not paired with the micro:bit. This is by design.",
            "title": "Advertising"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#pairing",
            "text": "To interact with any service on the micro:bit the peer device must first be paired/bonded with it.   How to pair your BBC micro:bit with an Android phone or tablet  from  Martin Woolley  on  Vimeo .  To pair with a micro:bit it must first be placed in \u201cpairing mode\u201d. To do this, hold down both buttons A and B and press and hold the reset button. If powered by USB, let go of the reset button but keep holding both buttons A and B down. This will result in the micro:bit going into pairing mode and the words \u201cPAIRING MODE\u201d should be seen scrolling across the display followed by the graphical representation of the micro:bit 5 character identifier.  Next, initiate pairing on the peer device. On Android for example, go into Settings/Bluetooth and allow the system to scan for and discover the advertising micro:bit. Select it and pairing will commence. The micro:bit will indicate it\u2019s ready to pair by displaying an arrow which points left towards button A. Press button A and a 6 digit number will be displayed on the micro:bit, one digit at a time. The peer device should now allow you to enter the 6 digit pass key. Do so and if the correct number was entered into the peer, micro:bit will display a tick/check to indicate pairing was achieved.  A maximum of 4 devices may be paired with a micro:bit simultaneously (note though that only one paired device may connect to the micro:bit at a time).",
            "title": "Pairing"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#reference-documentation",
            "text": "Details of the micro:bit\u2019s Bluetooth services, characteristics, the operations they each support and any associated descriptors along with UUID values can be found in the associated  micro:bit Bluetooth profile specification  A simplified overview appears below.",
            "title": "Reference Documentation"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#gatt-services",
            "text": "Service  Type  micro:bit optionality  Description      Generic Access Service  Adopted  mandatory  Provides generic information about the device. Mandatory in GATT profiles.    Generic Attribute Service  Adopted  mandatory  Can inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.    Device Information Service  Adopted  mandatory  Provides more comprehensive details about the device and its manufacturer    Accelerometer Service  Custom  optional  Provides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.    Magnetometer Service  Custom  optional  Provides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \u201ccurrent bearing\u201d value in degrees.    Temperature Service  Custom  optional  Provides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.    Button Service  Custom  optional  Allow button state changes to be notified to the client    LED Service  Custom  optional  Allows access to both the LED \u201cdisplay\u201d grid and the system status LED    IO Pin Service  Custom  optional  Allows access to and configuration of IO pins on the edge connector.    Event Service  Custom  optional  Allows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.    DFU Control Service  Custom  mandatory  Used to initiate device firmware update. Defined by Nordic Semiconductor.    UART Service  Custom  optional  Provides pseudo serial data communications over Bluetooth low energy, allowing arbitrary byte sequences to be exchanged in either direction with a connected peer. Data from micro:bit to peer is transmitted using Bluetooth Indications. Data from the peer to the micro:bit is transmitted using Write or Write No Response PDUs. This is an implementation of Nordic Semicondutor\u2019s UART/Serial Port Emulation over Bluetooth low energy.     The maximum number of bytes which may be transmitted in one PDU is limited to the MTU minus three or 20 octets to be precise.  See https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00072.html for the original Nordic Semiconductor documentation by way of background.  Note: This service was added after micro:bits initially shipped to school and so is not in the default image. |  Known issue: the firmware on micro:bits shipped initially to schools contains the full Bluetooth profile. Once the software has been changed by flashing an application created using any of the on-line code editors however, all services are lost except for Device Information Service, Event Service and DFU Control Service. If you need other services you must restore your micro:bit to its original state by installing the  default hex file  or better still  this hex file  which does not use the display so you can use it over Bluetooth instead.  The following sections elaborate on the description of a service and/or its characteristics. For full details see the  micro:bit Bluetooth profile specification",
            "title": "GATT Services"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-device-information-service",
            "text": "This is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 3 of those characteristics only.  See  https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml",
            "title": "About the Device Information Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-accelerometer-service",
            "text": "",
            "title": "About the Accelerometer Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics",
            "text": "Accelerometer Data  : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.  Accelerometer Period:  Determines the frequency with which accelerometer data is reported in milliseconds. Valid values are 1, 2, 5, 10, 20, 80, 160 and 640.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-magnetometer-service",
            "text": "",
            "title": "About the Magnetometer Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_1",
            "text": "Magnetometer Data  : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.  Magnetometer Period  : Determines the frequency with which magnetometer data is reported in milliseconds. Valid values are 1, 2, 5, 10, 20, 80, 160 and 640.  Magnetometer Bearing  : Compass bearing in degrees from North.  Note: to deliver meaningful data the micro:bit magnetometer must first be calibrated. The calibration procedure can be triggered by simply using the compass in your micro:bit program, or adding the MicroBitMagnetometer Bluetooth service to your Bluetooth profile*.  * from v2.0.0 of the runtime onwards.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-temperature-service",
            "text": "",
            "title": "About the Temperature Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_2",
            "text": "Temperature  : Signed integer 8 bit value in celsius.  Temperature Period  : Determines the frequency with which temperature data is updated in milliseconds.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-button-service",
            "text": "The Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.",
            "title": "About the Button Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-led-service",
            "text": "The service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.  A single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.  Other characteristics allow a text string to be written to it by the client for display and the scrolling delay may be set.",
            "title": "About the LED Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_3",
            "text": "LED Matrix State  : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.  LED Text  : A UTF-8 string to be shown on the LED display. Maximum length 20 octets.  Scrolling Delay  : Specifies a millisecond delay to wait for in between showing each character on the display.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-io-pin-service",
            "text": "",
            "title": "About the IO Pin Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_4",
            "text": "Pin Data  : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.  WRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.  NOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.  READ: A client reading this characteristic will receive Pin Number / Value pairs for  all  those pins defined as input pins by the Pin IO Configuration characteristic.  The associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.  Pin IO Configuration  : A bit mask (32 bit) which defines which inputs will be read. If the Pin AD Configuration bit mask is also set the pin will be read as an analogue input, if not it will be read as a digital input.    Note that in practice, setting a pin\u2019s mask bit means that it will be read by the micro:bit runtime and, if notifications have been enabled on the Pin Data characteristic, data read will be transmitted to the connected Bluetooth peer device in a Pin Data notification. If the pin\u2019s bit is clear, it  simply means that it will not be read by the micro:bit runtime. By default, pins are configured for output.  Pin AD Configuration  : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0 <= n < 19. A value of 0 means digital and 1 means analogue.  PWM Control  : Allows a client to use up to 2 micro:bit pins at a time for PWM output and to set the period and value of the pin(s). This is useful for applications such as the analogue control of LEDs and simple audio tone generation. Note that not all pins support PWM on micro:bit.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-event-service",
            "text": "The Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \u201cevent\u201d will be used here for both event and command types of data.  Events may have an associated value.  Note that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.  Multiple events of different types may be notified to the client or micro:bit at the same time.  Event data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.     struct event {  uint16 event_type;  uint16 event_value;};      event_type and event_value are each encoded in little endian format.  The Event Service has four characteristics in total:  micro:bit Requirements  is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.  Note that an event_type of zero means ANY event type and an event_value part set to zero means ANY event value.  Client Requirements  is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.  Note that an event_type of zero means ANY event type and an event_value part set to zero means ANY event value.  micro:bit Event  contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.  Client Event  is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.",
            "title": "About the Event Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-dfu-control-service",
            "text": "Allows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.",
            "title": "About the DFU Control Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_5",
            "text": "DFU Control  : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this characteristic  means \u201crequest flash code\u201d.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#about-the-uart-service",
            "text": "Provides a pseudo serial interface to the micro:bit for the exchange of arbitrary sequences of bytes. A maximum of 20 octets (MTU of 23 minus 3) can be transmitted in a single operation but a series of operations can be executed to affect something like serial data communications.  This is an implementation of the Nordic Semiconductor UART service:  https://developer.nordicsemi.com/nRF5_SDK/nRF51_SDK_v8.x.x/doc/8.0.0/s110/html/a00072.html",
            "title": "About the UART Service"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#characteristics_6",
            "text": "TX Characteristic : Allows the micro:bit to transmit a byte array containing an arbitrary number of arbitrary octet values to a connected device. Uses Indications for this purpose.  RX Characteristic : Allows a connected client to send a byte array containing an arbitrary number of arbitrary octet values to a connected micro:bit using with Write Requests or Write Commands.",
            "title": "Characteristics"
        },
        {
            "location": "/lancaster-mbed/ble/profile/#using-the-bluetooth-profile",
            "text": "Click on the Bluetooth menu and then select one of the Bluetooth services for a page of information dedicated to that service including information for application developers.  Martin Woolley\u2019s personal blog contains a series of micro:bit Bluetooth demonstration videos. See  http://bluetooth-mdw.blogspot.co.uk/p/bbc-microbit.html  The Android application featured in the videos was written by Martin and contains a series of demonstrations, each exercising at least one of the micro:bit Bluetooth services. The application  available in github. Information regarding the use of each service appears in the individual service pages of this site.",
            "title": "Using the Bluetooth Profile"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/",
            "text": "Bluetooth Accelerometer Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides live accelerometer data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service object to achieve this.\n\n\nEnabling the Service\n#\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitAccelerometerService(*uBit.ble, uBit.accelerometer);\n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nAccelerometer data may be obtained from the Bluetooth Accelerometer Service. Each time the accelerometer is polled, an X, Y and Z value becomes available. All three values may be transmitted to a connected client application as a Bluetooth Notification. To make this happen, the application must first subscribe to notifications relating to the Accelerometer Data characteristic by setting its associated Client Characteristic Configuration Descriptor (CCCD) to 0x0100. Once this has been done, notification messages will be delivered periodically.\n\n\nYou can control how often the accelerometer is polled and therefore how often Accelerometer Data notifications are received by the client application by writing a value in milliseconds to the Accelerometer Service\u2019s Accelerometer Period characteristic.\n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nRaw accelerometer data received from the micro:bit can be a bit \u201cjerky\u201d and so a low pass filter function should be used to smooth the data.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth accelerometer service. The main body of code for this demonstration can be found in ui.AccelerometerActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the accelerometer demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String ACCELEROMETERSERVICE_SERVICE_UUID = \"E95D0753251D470AA062FA1922DFA9A8\";\npublic static String ACCELEROMETERDATA_CHARACTERISTIC_UUID = \"E95DCA4B251D470AA062FA1922DFA9A8\";\npublic static String ACCELEROMETERPERIOD_CHARACTERISTIC_UUID = \"E95DFB24251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.AccelerometerActivity\n#\n\n\n// initiate reading of the accelerometer period characteristic to establish the current value\nbluetooth_le_adapter.readCharacteristic(Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.ACCELEROMETERPERIOD_CHARACTERISTIC_UUID));\n\n\n\n\n// changing the accelerometer polling period\nbluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.ACCELEROMETERPERIOD_CHARACTERISTIC_UUID), Utility.leBytesFromShort(Settings.getInstance().getAccelerometer_period()));\n\n\n\n\n// enabling accelerometer notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID),\n                    Utility.normaliseUUID(BleAdapterService.ACCELEROMETERDATA_CHARACTERISTIC_UUID), true);\n\n\n\n\n// receiving, decoding and smoothing a notification\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.ACCELEROMETERDATA_CHARACTERISTIC_UUID)))) {\n        notification_count++;\n        if (System.currentTimeMillis() - start_time >= 60000) {\n            showBenchmark();\n            notification_count = 0;\n            minute_number++;\n            start_time = System.currentTimeMillis();\n        }\n        byte[] x_bytes = new byte[2];\n        byte[] y_bytes = new byte[2];\n        byte[] z_bytes = new byte[2];\n        System.arraycopy(b, 0, x_bytes, 0, 2);\n        System.arraycopy(b, 2, y_bytes, 0, 2);\n        System.arraycopy(b, 4, z_bytes, 0, 2);\n        short raw_x = Utility.shortFromLittleEndianBytes(x_bytes);\n        short raw_y = Utility.shortFromLittleEndianBytes(y_bytes);\n        short raw_z = Utility.shortFromLittleEndianBytes(z_bytes);\n        Log.d(Constants.TAG, \"Accelerometer Data received: x=\" + raw_x + \" y=\" + raw_y + \" z=\" + raw_z);\n\n\n        // range is -1024 : +1024\n        // Starting with the LED display face up and level (perpendicular to gravity) and edge connector towards your body:\n        // A negative X value means tilting left, a positive X value means tilting right\n        // A negative Y value means tilting away from you, a positive Y value means tilting towards you\n        // A negative Z value means ?\n\n        float accel_x = raw_x / 1000f;\n        float accel_y = raw_y / 1000f;\n        float accel_z = raw_z / 1000f;\n        Log.d(Constants.TAG, \"Accelerometer data converted: x=\" + accel_x + \" y=\" + accel_y + \" z=\" + accel_z);\n\n        accel_input[0] = accel_x;\n        accel_input[1] = accel_y;\n        accel_input[2] = accel_z;\n        accel_output = Utility.lowPass(accel_input, accel_output);\n        Log.d(Constants.TAG, \"Smoothed accelerometer data: x=\" + accel_output[0] + \" y=\" + accel_output[1] + \" z=\" + accel_output[2]);\n\n        double pitch = Math.atan(accel_output[0] / Math.sqrt(Math.pow(accel_output[1], 2) + Math.pow(accel_output[2], 2)));\n        double roll = Math.atan(accel_output[1] / Math.sqrt(Math.pow(accel_output[0], 2) + Math.pow(accel_output[2], 2)));\n        //convert radians into degrees\n        pitch = pitch * (180.0 / Math.PI);\n        roll = -1 * roll * (180.0 / Math.PI);\n\n        showAccelerometerData(accel_output,pitch,roll);\n\n\n\n\nVideo Demonstration - starts at 0:18\n#",
            "title": "AccelerometerService"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#bluetooth-accelerometer-service",
            "text": "",
            "title": "Bluetooth Accelerometer Service"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides live accelerometer data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service object to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#enabling-the-service",
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitAccelerometerService(*uBit.ble, uBit.accelerometer);   Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#general-procedures",
            "text": "Accelerometer data may be obtained from the Bluetooth Accelerometer Service. Each time the accelerometer is polled, an X, Y and Z value becomes available. All three values may be transmitted to a connected client application as a Bluetooth Notification. To make this happen, the application must first subscribe to notifications relating to the Accelerometer Data characteristic by setting its associated Client Characteristic Configuration Descriptor (CCCD) to 0x0100. Once this has been done, notification messages will be delivered periodically.  You can control how often the accelerometer is polled and therefore how often Accelerometer Data notifications are received by the client application by writing a value in milliseconds to the Accelerometer Service\u2019s Accelerometer Period characteristic.  See the profile page and profile reference documentation for data format and UUID details.  Raw accelerometer data received from the micro:bit can be a bit \u201cjerky\u201d and so a low pass filter function should be used to smooth the data.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth accelerometer service. The main body of code for this demonstration can be found in ui.AccelerometerActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the accelerometer demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#in-bluetoothbleadapterservice",
            "text": "public static String ACCELEROMETERSERVICE_SERVICE_UUID = \"E95D0753251D470AA062FA1922DFA9A8\";\npublic static String ACCELEROMETERDATA_CHARACTERISTIC_UUID = \"E95DCA4B251D470AA062FA1922DFA9A8\";\npublic static String ACCELEROMETERPERIOD_CHARACTERISTIC_UUID = \"E95DFB24251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#in-uiaccelerometeractivity",
            "text": "// initiate reading of the accelerometer period characteristic to establish the current value\nbluetooth_le_adapter.readCharacteristic(Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.ACCELEROMETERPERIOD_CHARACTERISTIC_UUID));  // changing the accelerometer polling period\nbluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.ACCELEROMETERPERIOD_CHARACTERISTIC_UUID), Utility.leBytesFromShort(Settings.getInstance().getAccelerometer_period()));  // enabling accelerometer notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.ACCELEROMETERSERVICE_SERVICE_UUID),\n                    Utility.normaliseUUID(BleAdapterService.ACCELEROMETERDATA_CHARACTERISTIC_UUID), true);  // receiving, decoding and smoothing a notification\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.ACCELEROMETERDATA_CHARACTERISTIC_UUID)))) {\n        notification_count++;\n        if (System.currentTimeMillis() - start_time >= 60000) {\n            showBenchmark();\n            notification_count = 0;\n            minute_number++;\n            start_time = System.currentTimeMillis();\n        }\n        byte[] x_bytes = new byte[2];\n        byte[] y_bytes = new byte[2];\n        byte[] z_bytes = new byte[2];\n        System.arraycopy(b, 0, x_bytes, 0, 2);\n        System.arraycopy(b, 2, y_bytes, 0, 2);\n        System.arraycopy(b, 4, z_bytes, 0, 2);\n        short raw_x = Utility.shortFromLittleEndianBytes(x_bytes);\n        short raw_y = Utility.shortFromLittleEndianBytes(y_bytes);\n        short raw_z = Utility.shortFromLittleEndianBytes(z_bytes);\n        Log.d(Constants.TAG, \"Accelerometer Data received: x=\" + raw_x + \" y=\" + raw_y + \" z=\" + raw_z);\n\n\n        // range is -1024 : +1024\n        // Starting with the LED display face up and level (perpendicular to gravity) and edge connector towards your body:\n        // A negative X value means tilting left, a positive X value means tilting right\n        // A negative Y value means tilting away from you, a positive Y value means tilting towards you\n        // A negative Z value means ?\n\n        float accel_x = raw_x / 1000f;\n        float accel_y = raw_y / 1000f;\n        float accel_z = raw_z / 1000f;\n        Log.d(Constants.TAG, \"Accelerometer data converted: x=\" + accel_x + \" y=\" + accel_y + \" z=\" + accel_z);\n\n        accel_input[0] = accel_x;\n        accel_input[1] = accel_y;\n        accel_input[2] = accel_z;\n        accel_output = Utility.lowPass(accel_input, accel_output);\n        Log.d(Constants.TAG, \"Smoothed accelerometer data: x=\" + accel_output[0] + \" y=\" + accel_output[1] + \" z=\" + accel_output[2]);\n\n        double pitch = Math.atan(accel_output[0] / Math.sqrt(Math.pow(accel_output[1], 2) + Math.pow(accel_output[2], 2)));\n        double roll = Math.atan(accel_output[1] / Math.sqrt(Math.pow(accel_output[0], 2) + Math.pow(accel_output[2], 2)));\n        //convert radians into degrees\n        pitch = pitch * (180.0 / Math.PI);\n        roll = -1 * roll * (180.0 / Math.PI);\n\n        showAccelerometerData(accel_output,pitch,roll);",
            "title": "In ui.AccelerometerActivity"
        },
        {
            "location": "/lancaster-mbed/ble/accelerometer-service/#video-demonstration-starts-at-018",
            "text": "",
            "title": "Video Demonstration - starts at 0:18"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/",
            "text": "Bluetooth Button Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides live updates of the state of the physical buttons on the device to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.\n\n\nEnabling the Service\n#\n\n\nTo enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitButtonService(*uBit.ble);\n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nEach of the two front panel buttons, Button A and Button B is represented in the Bluetooth profile by a characteristic in the Button Service. The two characteristics are called Button A State and Button B State. Each supports read and notify operations, the most useful of which is notify.\n\n\nTo have your application notified of a change in the state of button A or button B, set the value of the Client Characteristic Configuration Descriptor (CCCD) associated with the appropriate characteristic to 0x0100. Once this has been done, notification messages will be received each time the state of a button changes. Note that buttons have 3 possible states; Not Pressed, Pressed and Long Press (pressed and held for at least 2 seconds) and these are represented by characteristic values 0, 1 and 2.\n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth accelerometer service. The main body of code for this demonstration can be found in ui.ButtonActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the button demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String BUTTONSERVICE_SERVICE_UUID = \"E95D9882251D470AA062FA1922DFA9A8\";\npublic static String BUTTON1STATE_CHARACTERISTIC_UUID = \"E95DDA90251D470AA062FA1922DFA9A8\";\npublic static String BUTTON2STATE_CHARACTERISTIC_UUID = \"E95DDA91251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.ButtonActivity\n#\n\n\n// enabling button state change notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.BUTTONSERVICE_SERVICE_UUID),\n                    Utility.normaliseUUID(BleAdapterService.BUTTON1STATE_CHARACTERISTIC_UUID), true)\n\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.BUTTONSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.BUTTON2STATE_CHARACTERISTIC_UUID), true)                    \n\n\n\n\n// receiving, decoding and responding to a notification\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    byte btn_state = b[0];\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.BUTTON1STATE_CHARACTERISTIC_UUID)))) {\n        Log.d(Constants.TAG, \"Button 1 State received: \" + btn_state);\n        ImageView b1_image = (ImageView) ButtonActivity.this.findViewById(R.id.button1);\n        setButtonImage(b1_image, btn_state);\n        TextView b1_label = (TextView) ButtonActivity.this.findViewById(R.id.button1_state);\n        setButtonLabel(b1_label, btn_state);\n    } else {\n        if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.BUTTON2STATE_CHARACTERISTIC_UUID)))) {\n            Log.d(Constants.TAG, \"Button 2 State received: \" + btn_state);\n            ImageView b2_image = (ImageView) ButtonActivity.this.findViewById(R.id.button2);\n            setButtonImage(b2_image, btn_state);\n            TextView b2_label = (TextView) ButtonActivity.this.findViewById(R.id.button2_state);\n            setButtonLabel(b2_label, btn_state);\n        }\n    }\n    break;\n\n\n\n\nVideo Demonstration - starts at 0:59\n#",
            "title": "ButtonService"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#bluetooth-button-service",
            "text": "",
            "title": "Bluetooth Button Service"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides live updates of the state of the physical buttons on the device to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#enabling-the-service",
            "text": "To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitButtonService(*uBit.ble);   Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#general-procedures",
            "text": "Each of the two front panel buttons, Button A and Button B is represented in the Bluetooth profile by a characteristic in the Button Service. The two characteristics are called Button A State and Button B State. Each supports read and notify operations, the most useful of which is notify.  To have your application notified of a change in the state of button A or button B, set the value of the Client Characteristic Configuration Descriptor (CCCD) associated with the appropriate characteristic to 0x0100. Once this has been done, notification messages will be received each time the state of a button changes. Note that buttons have 3 possible states; Not Pressed, Pressed and Long Press (pressed and held for at least 2 seconds) and these are represented by characteristic values 0, 1 and 2.  See the profile page and profile reference documentation for data format and UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth accelerometer service. The main body of code for this demonstration can be found in ui.ButtonActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the button demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#in-bluetoothbleadapterservice",
            "text": "public static String BUTTONSERVICE_SERVICE_UUID = \"E95D9882251D470AA062FA1922DFA9A8\";\npublic static String BUTTON1STATE_CHARACTERISTIC_UUID = \"E95DDA90251D470AA062FA1922DFA9A8\";\npublic static String BUTTON2STATE_CHARACTERISTIC_UUID = \"E95DDA91251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#in-uibuttonactivity",
            "text": "// enabling button state change notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.BUTTONSERVICE_SERVICE_UUID),\n                    Utility.normaliseUUID(BleAdapterService.BUTTON1STATE_CHARACTERISTIC_UUID), true)\n\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.BUTTONSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.BUTTON2STATE_CHARACTERISTIC_UUID), true)                      // receiving, decoding and responding to a notification\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    byte btn_state = b[0];\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.BUTTON1STATE_CHARACTERISTIC_UUID)))) {\n        Log.d(Constants.TAG, \"Button 1 State received: \" + btn_state);\n        ImageView b1_image = (ImageView) ButtonActivity.this.findViewById(R.id.button1);\n        setButtonImage(b1_image, btn_state);\n        TextView b1_label = (TextView) ButtonActivity.this.findViewById(R.id.button1_state);\n        setButtonLabel(b1_label, btn_state);\n    } else {\n        if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.BUTTON2STATE_CHARACTERISTIC_UUID)))) {\n            Log.d(Constants.TAG, \"Button 2 State received: \" + btn_state);\n            ImageView b2_image = (ImageView) ButtonActivity.this.findViewById(R.id.button2);\n            setButtonImage(b2_image, btn_state);\n            TextView b2_label = (TextView) ButtonActivity.this.findViewById(R.id.button2_state);\n            setButtonLabel(b2_label, btn_state);\n        }\n    }\n    break;",
            "title": "In ui.ButtonActivity"
        },
        {
            "location": "/lancaster-mbed/ble/button-service/#video-demonstration-starts-at-059",
            "text": "",
            "title": "Video Demonstration - starts at 0:59"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/",
            "text": "Bluetooth Device Firmware Update Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. This service provides a well defined mechanism through which an attached Bluetooth master device can request the micro:bit enter the Nordic\nFirmware Over The Air (FOTA) bootloader. It provides this data to any attached Bluetooth master device. You do not need to explicitly address and API on the service to achieve this.\n\n\nEnabling the Service\n#\n\n\nThis service is enabled by default.\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nCOMING SOON",
            "title": "DFUService"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/#bluetooth-device-firmware-update-service",
            "text": "",
            "title": "Bluetooth Device Firmware Update Service"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/#introduction",
            "text": "This Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. This service provides a well defined mechanism through which an attached Bluetooth master device can request the micro:bit enter the Nordic\nFirmware Over The Air (FOTA) bootloader. It provides this data to any attached Bluetooth master device. You do not need to explicitly address and API on the service to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/#enabling-the-service",
            "text": "This service is enabled by default.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/dfu-service/#example-applications-for-androidiosandroid",
            "text": "COMING SOON",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/",
            "text": "Bluetooth Event Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. This service extends the microBitMessageBus over Bluetooth, so that standard MicroBitEvents raised on the device can be transmitted transparently over\nBluetooth and received and processed by connected Bluetooth master device such as a smartphone.  You do not need to explicitly address and API on the service to achieve this.\n\n\nEnabling the Service\n#\n\n\nThis service is enabled by default.\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nmicro:bit uses an event bus which relays event objects from system components which generate them to other system components which have registered an interest in events of a given type. This principle and capability has been extended to remote devices connected over Bluetooth. Connected clients can indicate the types of event they are interested in and be informed via Bluetooth notifications as and when such events occur. Similarly, micro:bit application code can inform a connected client of events which might happen in or be observed by an application running on the connected device (the client application) and be informed when they occur via Bluetooth write operations. \n\n\nEvent objects consist of a short (2 octets) type and a short (2 octets) value.\n\n\nWhen either client application or micro:bit code registers an interest in an event type it may register for all events of that type regardless of the associated value or may specify a particular value which must accompany that event type for it to be of interest.\n\n\nThe Microbit Requirements characteristic allows micro:bit code to inform the client application of a list of one or more event types/values it wants to be informed about if they arise. For example if a client application monitors for incoming SMS messages and defines receipt of an SMS message to be event type 1234 then a micro:bit application could inform the client application it wants to be told when an SMS has been received by declaring its interest in event type 1234 in its MicrobitRequirements characteristic.\n\n\nThe Client Requirements characteristic has a similar purpose but is the mechanism the client application uses to tell the micro:bit application what events it is interested in. Should they arise and notifications have been enabled on the MicrobitEvent characteristic, the client application will receive a Bluetooth notification containing the event object. A micro:bit application which monitors temperature and notifies a smartphone application when the temperature falls below a specified limit or rises above another threshold could use events to notify the client application when either of these things happens.\n\n\nThe MicroBit Event characteristic is used to convey events which have happened on the micro:bit to the connected client. Notifications are normally used but the most recent events for which the client registered can be determined by reading the characteristic value at any time.\n\n\nThe Client Event characteristic is used to convey events which have happened on the client device to the micro:bit. This is achieved through the client application writing one or more events to the characteristic value.\n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a number of demonstrations of the micro:bit Bluetooth event service including Temperature Alarm and Squirrel Counter. The main body of code for the temperature alarm demonstration can be found in ui.TemperatureAlarmActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the temperature alarm demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String EVENTSERVICE_SERVICE_UUID = \"E95D93AF251D470AA062FA1922DFA9A8\";\npublic static String MICROBITREQUIREMENTS_CHARACTERISTIC_UUID = \"E95DB84C251D470AA062FA1922DFA9A8\";\npublic static String MICROBITEVENT_CHARACTERISTIC_UUID = \"E95D9775251D470AA062FA1922DFA9A8\";\npublic static String CLIENTREQUIREMENTS_CHARACTERISTIC_UUID = \"E95D23C4251D470AA062FA1922DFA9A8\";\npublic static String CLIENTEVENT_CHARACTERISTIC_UUID = \"E95D5404251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.TemperatureAlarmActivity\n#\n\n\n// event variables and values\nprivate byte upper_limit;\nprivate byte lower_limit;\n\n// LE here means Little Endian btw\n\n// micro:bit event codes:\n// 9000 = 0x2823 (LE) = temperature alarm. Value=0 means OK, 1 means cold, 2 means hot\n\n// client event codes:\n// 9001=0x2923 (LE) = set lower limit, value is the limit value in celsius\n// 9002=0x2A23 (LE) = set upper limit, value is the limit value in celsius\n\nprivate byte [] event_set_lower = { 0x29, 0x23, 0x00, 0x00}; // event 9001\nprivate byte [] event_set_upper = { 0x2A, 0x23, 0x00, 0x00}; // event 9002\n\n\n\n\n// enabling microbit event notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MICROBITEVENT_CHARACTERISTIC_UUID), true)                    \n\n\n\n\nshort MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM = 9000;\nshort MICROBIT_EVENT_VALUE_ANY = 0000;\n// informing micro:bit of the types of event we want to be informed about\nbluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTREQUIREMENTS_CHARACTERISTIC_UUID), Utility.leBytesFromTwoShorts(Constants.MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM,Constants.MICROBIT_EVENT_VALUE_ANY));\n\n\n\n\n// setting the upper and lower temperature limits \nprivate void setUpperLimit() {\n    // set the value part of this event data\n    event_set_upper[2] = Settings.getInstance().getUpper_temperature_limit();\n    bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTEVENT_CHARACTERISTIC_UUID), event_set_upper);\n}\n\nprivate void setLowerLimit() {\n    // set the value part of this event data\n    event_set_lower[2] = Settings.getInstance().getLower_temperature_limit();\n    bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTEVENT_CHARACTERISTIC_UUID), event_set_lower);\n}\n\n\n\n\n// handling a MicrobitEvent notification indicating a temperature alarm of \"too hot\" or \"too cold\"\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MICROBITEVENT_CHARACTERISTIC_UUID)))) {\n        byte[] event_bytes = new byte[2];\n        byte[] value_bytes = new byte[2];\n        System.arraycopy(b, 0, event_bytes, 0, 2);\n        System.arraycopy(b, 2, value_bytes, 0, 2);\n        short event = Utility.shortFromLittleEndianBytes(event_bytes);\n        short value = Utility.shortFromLittleEndianBytes(value_bytes);\n        Log.d(Constants.TAG, \"Temperature Alarm received: event=\" + event + \" value=\" + value);\n        if (event == Constants.MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM) {\n            setAlarmImage(alarm_image, value);\n            setAlarmMessage(value);\n        }\n    }\n    break;\n\n\n\n\nVideo Demonstrations\n#\n\n\nTemperature Alarm\n#\n\n\n\n\n\nBuggy Remote Control\n#\n\n\n\n\n\nmicro:bit code for the buggy controller\n#\n\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 British Broadcasting Corporation.\nThis software is provided by Lancaster University by arrangement with the BBC.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\n#include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\n\n#ifdef MICROBIT_GAMEPAD\n\nMicroBit uBit;\n\n#define MES_DPAD_CONTROLLER                 1104\n#define MES_DPAD_1_BUTTON_UP_ON             1\n#define MES_DPAD_1_BUTTON_UP_OFF            2\n#define MES_DPAD_1_BUTTON_DOWN_ON           3\n#define MES_DPAD_1_BUTTON_DOWN_OFF          4\n#define MES_DPAD_1_BUTTON_LEFT_ON           5\n#define MES_DPAD_1_BUTTON_LEFT_OFF          6\n#define MES_DPAD_1_BUTTON_RIGHT_ON          7\n#define MES_DPAD_1_BUTTON_RIGHT_OFF         8\n#define MES_DPAD_2_BUTTON_UP_ON             9\n#define MES_DPAD_2_BUTTON_UP_OFF            10\n#define MES_DPAD_2_BUTTON_DOWN_ON           11\n#define MES_DPAD_2_BUTTON_DOWN_OFF          12\n#define MES_DPAD_2_BUTTON_LEFT_ON           13\n#define MES_DPAD_2_BUTTON_LEFT_OFF          14\n#define MES_DPAD_2_BUTTON_RIGHT_ON          15\n#define MES_DPAD_2_BUTTON_RIGHT_OFF         16\n\nint pin0, pin8, pin12, pin16 = 0;\n\nint drive = 0;\n\nvoid onControllerEvent(MicroBitEvent e)\n{\n  if (e.value == MES_DPAD_2_BUTTON_UP_ON) {\n      pin12 = 1;\n      pin16 = 1;\n      drive = 1;\n  } else {\n    if (e.value == MES_DPAD_2_BUTTON_UP_OFF) {\n      pin12 = 0;\n      pin16 = 0;\n      drive = 0;\n    }\n  }\n\n  if (drive == 1) {\n      if (e.value == MES_DPAD_1_BUTTON_LEFT_ON) {\n          pin12 = 1;\n          pin16 = 0;\n      } else {\n          if (e.value == MES_DPAD_1_BUTTON_RIGHT_ON) {\n              pin12 = 0;\n              pin16 = 1;\n          } else {\n              if (e.value == MES_DPAD_1_BUTTON_LEFT_OFF || e.value == MES_DPAD_1_BUTTON_RIGHT_OFF) {\n                  pin12 = 1;\n                  pin16 = 1;\n              } else {\n              }\n          }\n      }\n  }\n\n  uBit.io.P0.setDigitalValue(pin0);\n  uBit.io.P8.setDigitalValue(pin8);\n  uBit.io.P12.setDigitalValue(pin12);\n  uBit.io.P16.setDigitalValue(pin16);\n\n}\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    uBit.display.scroll(\"BUGGY!\");\n    uBit.messageBus.listen(MES_DPAD_CONTROLLER, 0, onControllerEvent); \n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}\n\n#endif",
            "title": "EventService"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#bluetooth-event-service",
            "text": "",
            "title": "Bluetooth Event Service"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard Bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. This service extends the microBitMessageBus over Bluetooth, so that standard MicroBitEvents raised on the device can be transmitted transparently over\nBluetooth and received and processed by connected Bluetooth master device such as a smartphone.  You do not need to explicitly address and API on the service to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#enabling-the-service",
            "text": "This service is enabled by default.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#general-procedures",
            "text": "micro:bit uses an event bus which relays event objects from system components which generate them to other system components which have registered an interest in events of a given type. This principle and capability has been extended to remote devices connected over Bluetooth. Connected clients can indicate the types of event they are interested in and be informed via Bluetooth notifications as and when such events occur. Similarly, micro:bit application code can inform a connected client of events which might happen in or be observed by an application running on the connected device (the client application) and be informed when they occur via Bluetooth write operations.   Event objects consist of a short (2 octets) type and a short (2 octets) value.  When either client application or micro:bit code registers an interest in an event type it may register for all events of that type regardless of the associated value or may specify a particular value which must accompany that event type for it to be of interest.  The Microbit Requirements characteristic allows micro:bit code to inform the client application of a list of one or more event types/values it wants to be informed about if they arise. For example if a client application monitors for incoming SMS messages and defines receipt of an SMS message to be event type 1234 then a micro:bit application could inform the client application it wants to be told when an SMS has been received by declaring its interest in event type 1234 in its MicrobitRequirements characteristic.  The Client Requirements characteristic has a similar purpose but is the mechanism the client application uses to tell the micro:bit application what events it is interested in. Should they arise and notifications have been enabled on the MicrobitEvent characteristic, the client application will receive a Bluetooth notification containing the event object. A micro:bit application which monitors temperature and notifies a smartphone application when the temperature falls below a specified limit or rises above another threshold could use events to notify the client application when either of these things happens.  The MicroBit Event characteristic is used to convey events which have happened on the micro:bit to the connected client. Notifications are normally used but the most recent events for which the client registered can be determined by reading the characteristic value at any time.  The Client Event characteristic is used to convey events which have happened on the client device to the micro:bit. This is achieved through the client application writing one or more events to the characteristic value.  See the profile page and profile reference documentation for data format and UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a number of demonstrations of the micro:bit Bluetooth event service including Temperature Alarm and Squirrel Counter. The main body of code for the temperature alarm demonstration can be found in ui.TemperatureAlarmActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the temperature alarm demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#in-bluetoothbleadapterservice",
            "text": "public static String EVENTSERVICE_SERVICE_UUID = \"E95D93AF251D470AA062FA1922DFA9A8\";\npublic static String MICROBITREQUIREMENTS_CHARACTERISTIC_UUID = \"E95DB84C251D470AA062FA1922DFA9A8\";\npublic static String MICROBITEVENT_CHARACTERISTIC_UUID = \"E95D9775251D470AA062FA1922DFA9A8\";\npublic static String CLIENTREQUIREMENTS_CHARACTERISTIC_UUID = \"E95D23C4251D470AA062FA1922DFA9A8\";\npublic static String CLIENTEVENT_CHARACTERISTIC_UUID = \"E95D5404251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#in-uitemperaturealarmactivity",
            "text": "// event variables and values\nprivate byte upper_limit;\nprivate byte lower_limit;\n\n// LE here means Little Endian btw\n\n// micro:bit event codes:\n// 9000 = 0x2823 (LE) = temperature alarm. Value=0 means OK, 1 means cold, 2 means hot\n\n// client event codes:\n// 9001=0x2923 (LE) = set lower limit, value is the limit value in celsius\n// 9002=0x2A23 (LE) = set upper limit, value is the limit value in celsius\n\nprivate byte [] event_set_lower = { 0x29, 0x23, 0x00, 0x00}; // event 9001\nprivate byte [] event_set_upper = { 0x2A, 0x23, 0x00, 0x00}; // event 9002  // enabling microbit event notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MICROBITEVENT_CHARACTERISTIC_UUID), true)                      short MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM = 9000;\nshort MICROBIT_EVENT_VALUE_ANY = 0000;\n// informing micro:bit of the types of event we want to be informed about\nbluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTREQUIREMENTS_CHARACTERISTIC_UUID), Utility.leBytesFromTwoShorts(Constants.MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM,Constants.MICROBIT_EVENT_VALUE_ANY));  // setting the upper and lower temperature limits \nprivate void setUpperLimit() {\n    // set the value part of this event data\n    event_set_upper[2] = Settings.getInstance().getUpper_temperature_limit();\n    bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTEVENT_CHARACTERISTIC_UUID), event_set_upper);\n}\n\nprivate void setLowerLimit() {\n    // set the value part of this event data\n    event_set_lower[2] = Settings.getInstance().getLower_temperature_limit();\n    bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.EVENTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.CLIENTEVENT_CHARACTERISTIC_UUID), event_set_lower);\n}  // handling a MicrobitEvent notification indicating a temperature alarm of \"too hot\" or \"too cold\"\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MICROBITEVENT_CHARACTERISTIC_UUID)))) {\n        byte[] event_bytes = new byte[2];\n        byte[] value_bytes = new byte[2];\n        System.arraycopy(b, 0, event_bytes, 0, 2);\n        System.arraycopy(b, 2, value_bytes, 0, 2);\n        short event = Utility.shortFromLittleEndianBytes(event_bytes);\n        short value = Utility.shortFromLittleEndianBytes(value_bytes);\n        Log.d(Constants.TAG, \"Temperature Alarm received: event=\" + event + \" value=\" + value);\n        if (event == Constants.MICROBIT_EVENT_TYPE_TEMPERATURE_ALARM) {\n            setAlarmImage(alarm_image, value);\n            setAlarmMessage(value);\n        }\n    }\n    break;",
            "title": "In ui.TemperatureAlarmActivity"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#video-demonstrations",
            "text": "",
            "title": "Video Demonstrations"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#temperature-alarm",
            "text": "",
            "title": "Temperature Alarm"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#buggy-remote-control",
            "text": "",
            "title": "Buggy Remote Control"
        },
        {
            "location": "/lancaster-mbed/ble/event-service/#microbit-code-for-the-buggy-controller",
            "text": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 British Broadcasting Corporation.\nThis software is provided by Lancaster University by arrangement with the BBC.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\n#include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\n\n#ifdef MICROBIT_GAMEPAD\n\nMicroBit uBit;\n\n#define MES_DPAD_CONTROLLER                 1104\n#define MES_DPAD_1_BUTTON_UP_ON             1\n#define MES_DPAD_1_BUTTON_UP_OFF            2\n#define MES_DPAD_1_BUTTON_DOWN_ON           3\n#define MES_DPAD_1_BUTTON_DOWN_OFF          4\n#define MES_DPAD_1_BUTTON_LEFT_ON           5\n#define MES_DPAD_1_BUTTON_LEFT_OFF          6\n#define MES_DPAD_1_BUTTON_RIGHT_ON          7\n#define MES_DPAD_1_BUTTON_RIGHT_OFF         8\n#define MES_DPAD_2_BUTTON_UP_ON             9\n#define MES_DPAD_2_BUTTON_UP_OFF            10\n#define MES_DPAD_2_BUTTON_DOWN_ON           11\n#define MES_DPAD_2_BUTTON_DOWN_OFF          12\n#define MES_DPAD_2_BUTTON_LEFT_ON           13\n#define MES_DPAD_2_BUTTON_LEFT_OFF          14\n#define MES_DPAD_2_BUTTON_RIGHT_ON          15\n#define MES_DPAD_2_BUTTON_RIGHT_OFF         16\n\nint pin0, pin8, pin12, pin16 = 0;\n\nint drive = 0;\n\nvoid onControllerEvent(MicroBitEvent e)\n{\n  if (e.value == MES_DPAD_2_BUTTON_UP_ON) {\n      pin12 = 1;\n      pin16 = 1;\n      drive = 1;\n  } else {\n    if (e.value == MES_DPAD_2_BUTTON_UP_OFF) {\n      pin12 = 0;\n      pin16 = 0;\n      drive = 0;\n    }\n  }\n\n  if (drive == 1) {\n      if (e.value == MES_DPAD_1_BUTTON_LEFT_ON) {\n          pin12 = 1;\n          pin16 = 0;\n      } else {\n          if (e.value == MES_DPAD_1_BUTTON_RIGHT_ON) {\n              pin12 = 0;\n              pin16 = 1;\n          } else {\n              if (e.value == MES_DPAD_1_BUTTON_LEFT_OFF || e.value == MES_DPAD_1_BUTTON_RIGHT_OFF) {\n                  pin12 = 1;\n                  pin16 = 1;\n              } else {\n              }\n          }\n      }\n  }\n\n  uBit.io.P0.setDigitalValue(pin0);\n  uBit.io.P8.setDigitalValue(pin8);\n  uBit.io.P12.setDigitalValue(pin12);\n  uBit.io.P16.setDigitalValue(pin16);\n\n}\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    uBit.display.scroll(\"BUGGY!\");\n    uBit.messageBus.listen(MES_DPAD_CONTROLLER, 0, onControllerEvent); \n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}\n\n#endif",
            "title": "micro:bit code for the buggy controller"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/",
            "text": "Bluetooth IO Pin Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides the ability to read and write digital and analog values from/to any of the pins exposed on the micro:bit edge connector, including the 3 main ring ports.\nThis data can be transparently read and written by a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.\n\n\nEnabling the Service\n#\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitIOPinService(*uBit.ble, uBit.io);\n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nApplications should first configure the pins they wish to work with over Bluetooth. Configuration involves specifying that a pin is to be used for digital I/O or analogue I/O and that it is to be used for input or for output. These two types of configuration are handled by two characteristics in the IO Pin Service namely Pin AD Configuration and Pin IO Configuration. \n\n\nThe Pin AD Configuration characteristic contains A bit mask (32 bit) which defines which inputs will be read. If the Pin AD Configuration bit mask is also set the pin will be read as an analogue input, if not it will be read as a digital input.  \n\n\nNote that in practice, setting a pin\u2019s mask bit means that it will be read by the micro:bit runtime and, if notifications have been enabled on the Pin Data characteristic, data read will be transmitted to the connected Bluetooth peer device in a Pin Data notification. If the pin\u2019s bit is clear, it  simply means that it will not be read by the micro:bit runtime.By default, pins are configured for output.\n\n\nThe Pin Data characteristic  is used to read values from one or more pins concurrently via Bluetooth read operations or write data to pins using Bluetooth writes. Notifications are also supported as a means of receiving input data. See the reference documentation for further information.\n\n\nThe PWM Control characteristic allows a client to use up to 2 micro:bit pins at a time for PWM output and to set the period and value of the pin(s). This is useful for applications such as the analogue control of LEDs and simple audio tone generation. Note that not all pins support PWM on micro:bit.\n\n\n\n\nNote\n\n\nIf PWM is used for the generation of audio tones via speakers or similar, then tones will not sound as \u201cclean and pure\u201d as they would if the pins were set to the same period and value directly on a micro:bit which has Bluetooth disabled. This is due to a combination of factors including the fact that PWM on micro:bit is implemented partly in software and the Nordic Semiconductor Bluetooth stack takes priority with respect to interrupts.\n\n\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth IO Pin service which involves switching a connected LED on and off from a smartphone over Bluetooth. The main body of code for this demonstration can be found in ui.IoDigitalOutputActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the IO Pin demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String IOPINSERVICE_SERVICE_UUID = \"E95D127B251D470AA062FA1922DFA9A8\";\npublic static String PINDATA_CHARACTERISTIC_UUID = \"E95D8D00251D470AA062FA1922DFA9A8\";\npublic static String PINADCONFIGURATION_CHARACTERISTIC_UUID = \"E95D5899251D470AA062FA1922DFA9A8\";\npublic static String PINIOCONFIGURATION_CHARACTERISTIC_UUID = \"E95DB9FE251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.IoPinDigitalOutputActivity\n#\n\n\n// Configure pin 0\n//   Digital\nbyte[] ad_flags = {0x00};\nbluetooth_le_adapter.writeCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.PINADCONFIGURATION_CHARACTERISTIC_UUID), ad_flags)\n\n//   Output\nbyte[] io_flags_out = {0x00};\nbluetooth_le_adapter.writeCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.PINIOCONFIGURATION_CHARACTERISTIC_UUID), io_flags_out);\n\n\n\n\n// toggling the LED state when the user touches the graphical button on the screen\npublic boolean onTouch(View v, MotionEvent event) {\n    if (v == led_switch) {\n        if (on) {\n            byte[] switch_off_pin_0 = {0x00, 0x00};\n            bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.PINDATA_CHARACTERISTIC_UUID), switch_off_pin_0);\n        } else {\n            byte[] switch_on_pin_0 = {0x00, 0x01};\n            bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.PINDATA_CHARACTERISTIC_UUID), switch_on_pin_0);\n        }\n    }\n    return false;\n}\n\n\n\n\nVideo Demonstration - starts at 3:49\n#",
            "title": "IOPinService"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#bluetooth-io-pin-service",
            "text": "",
            "title": "Bluetooth IO Pin Service"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides the ability to read and write digital and analog values from/to any of the pins exposed on the micro:bit edge connector, including the 3 main ring ports.\nThis data can be transparently read and written by a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#enabling-the-service",
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitIOPinService(*uBit.ble, uBit.io);   Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#general-procedures",
            "text": "Applications should first configure the pins they wish to work with over Bluetooth. Configuration involves specifying that a pin is to be used for digital I/O or analogue I/O and that it is to be used for input or for output. These two types of configuration are handled by two characteristics in the IO Pin Service namely Pin AD Configuration and Pin IO Configuration.   The Pin AD Configuration characteristic contains A bit mask (32 bit) which defines which inputs will be read. If the Pin AD Configuration bit mask is also set the pin will be read as an analogue input, if not it will be read as a digital input.    Note that in practice, setting a pin\u2019s mask bit means that it will be read by the micro:bit runtime and, if notifications have been enabled on the Pin Data characteristic, data read will be transmitted to the connected Bluetooth peer device in a Pin Data notification. If the pin\u2019s bit is clear, it  simply means that it will not be read by the micro:bit runtime.By default, pins are configured for output.  The Pin Data characteristic  is used to read values from one or more pins concurrently via Bluetooth read operations or write data to pins using Bluetooth writes. Notifications are also supported as a means of receiving input data. See the reference documentation for further information.  The PWM Control characteristic allows a client to use up to 2 micro:bit pins at a time for PWM output and to set the period and value of the pin(s). This is useful for applications such as the analogue control of LEDs and simple audio tone generation. Note that not all pins support PWM on micro:bit.   Note  If PWM is used for the generation of audio tones via speakers or similar, then tones will not sound as \u201cclean and pure\u201d as they would if the pins were set to the same period and value directly on a micro:bit which has Bluetooth disabled. This is due to a combination of factors including the fact that PWM on micro:bit is implemented partly in software and the Nordic Semiconductor Bluetooth stack takes priority with respect to interrupts.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth IO Pin service which involves switching a connected LED on and off from a smartphone over Bluetooth. The main body of code for this demonstration can be found in ui.IoDigitalOutputActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the IO Pin demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#in-bluetoothbleadapterservice",
            "text": "public static String IOPINSERVICE_SERVICE_UUID = \"E95D127B251D470AA062FA1922DFA9A8\";\npublic static String PINDATA_CHARACTERISTIC_UUID = \"E95D8D00251D470AA062FA1922DFA9A8\";\npublic static String PINADCONFIGURATION_CHARACTERISTIC_UUID = \"E95D5899251D470AA062FA1922DFA9A8\";\npublic static String PINIOCONFIGURATION_CHARACTERISTIC_UUID = \"E95DB9FE251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#in-uiiopindigitaloutputactivity",
            "text": "// Configure pin 0\n//   Digital\nbyte[] ad_flags = {0x00};\nbluetooth_le_adapter.writeCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.PINADCONFIGURATION_CHARACTERISTIC_UUID), ad_flags)\n\n//   Output\nbyte[] io_flags_out = {0x00};\nbluetooth_le_adapter.writeCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.PINIOCONFIGURATION_CHARACTERISTIC_UUID), io_flags_out);  // toggling the LED state when the user touches the graphical button on the screen\npublic boolean onTouch(View v, MotionEvent event) {\n    if (v == led_switch) {\n        if (on) {\n            byte[] switch_off_pin_0 = {0x00, 0x00};\n            bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.PINDATA_CHARACTERISTIC_UUID), switch_off_pin_0);\n        } else {\n            byte[] switch_on_pin_0 = {0x00, 0x01};\n            bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.IOPINSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.PINDATA_CHARACTERISTIC_UUID), switch_on_pin_0);\n        }\n    }\n    return false;\n}",
            "title": "In ui.IoPinDigitalOutputActivity"
        },
        {
            "location": "/lancaster-mbed/ble/iopin-service/#video-demonstration-starts-at-349",
            "text": "",
            "title": "Video Demonstration - starts at 3:49"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/",
            "text": "Bluetooth LED Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It allows a connected Bluetooth master device such as a smartphone to read and write the status of the LEDs on the display. This includes reading and writing\nbitmap pattern values and sending text messages to be scrolled across the display. Scrolling speed may also be controlled over Bluetooth via a control point characteristic designed for this purpose.\n\n\nEnabling the Service\n#\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitLEDService(*uBit.ble, uBit.display);\n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nmicro:bit has an LED display with 5 rows and 5 columns i.e. 25 LEDs in total. The Bluetooth LED service allows the entire grid to be addressed as a bitmap using the LED Matrix State characteristic which supports both read and write operations. Text strings can be sent to the micro:bit for display by writing to the LED Text characteristic and the speed with which it is scrolled can be controlled by setting a delay value in milliseconds by writing to the Scrolling Delay characteristic.\n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth LED service. The main body of code for this demonstration can be found in ui.LEDsActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the button demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String LEDSERVICE_SERVICE_UUID = \"E95DD91D251D470AA062FA1922DFA9A8\";\npublic static String LEDMATRIXSTATE_CHARACTERISTIC_UUID = \"E95D7B77251D470AA062FA1922DFA9A8\";\npublic static String LEDTEXT_CHARACTERISTIC_UUID = \"E95D93EE251D470AA062FA1922DFA9A8\";\npublic static String SCROLLINGDELAY_CHARACTERISTIC_UUID = \"E95D0D2D251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.LEDsActivity\n#\n\n\nprivate short scrolling_delay;\n//    Octet 0, LED Row 1: bit4 bit3 bit2 bit1 bit0\n//    Octet 1, LED Row 2: bit4 bit3 bit2 bit1 bit0\n//    Octet 2, LED Row 3: bit4 bit3 bit2 bit1 bit0\n//    Octet 3, LED Row 4: bit4 bit3 bit2 bit1 bit0\n//    Octet 4, LED Row 5: bit4 bit3 bit2 bit1 bit0\nprivate byte[] led_matrix_state;\n\n\n\n\n// read the current LED matrix state so the application UI can be initialised to match the current micro:bit display state\nbluetooth_le_adapter.readCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.LEDMATRIXSTATE_CHARACTERISTIC_UUID))\n\n\n\n\n// send a short text string from the application to the micro:bit\npublic void onSendText(View view) {\n    EditText text = (EditText) LEDsActivity.this.findViewById(R.id.display_text);\n    try {\n        byte[] utf8_bytes = text.getText().toString().getBytes(\"UTF-8\");\n        Log.d(Constants.TAG, \"UTF8 bytes: 0x\" + Utility.byteArrayAsHexString(utf8_bytes));\n        bluetooth_le_adapter.writeCharacteristic(\n                            Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                            Utility.normaliseUUID(BleAdapterService.LEDTEXT_CHARACTERISTIC_UUID), \n                            utf8_bytes);\n    } catch (UnsupportedEncodingException e) {\n        showMsg(\"Unable to convert text to UTF8 bytes\");\n    }\n}\n\n\n\n\n// update the local state and UI in response to user interactions\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        Log.d(Constants.TAG, \"onTouch - \" + event.actionToString((event.getAction())));\n        if (led_matrix_state == null) {\n            Log.d(Constants.TAG, \"onTouch - LED state array has not yet been initialised so ignoring touch\");\n            return true;\n        }\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            GridLayout grid = (GridLayout) LEDsActivity.this.findViewById(R.id.grid);\n            int count = grid.getChildCount();\n            int display_row = 0;\n            int led_in_row = 4;\n            for (int i = 0; i < count; i++) {\n                View child = grid.getChildAt(i);\n                if (child == v) {\n                    Log.d(Constants.TAG,\"Touched row \"+display_row+\", LED \"+led_in_row);\n                    if ((led_matrix_state[display_row] & (1 << led_in_row)) != 0) {\n                        child.setBackgroundColor(Color.parseColor(\"#C0C0C0\"));\n                        led_matrix_state[display_row] = (byte) (led_matrix_state[display_row] & ~(1 << led_in_row));\n                    } else {\n                        child.setBackgroundColor(Color.RED);\n                        led_matrix_state[display_row] = (byte) (led_matrix_state[display_row] | (1 << led_in_row));\n                    }\n                    return true;\n                }\n                led_in_row = led_in_row - 1;\n                if (led_in_row < 0) {\n                    led_in_row = 4;\n                    display_row++;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n\n\n\n// send new display state to micro:bit so it mirrors that shown on the application UI\npublic void onSetDisplay(View view) {\n    bluetooth_le_adapter.writeCharacteristic(\n                        Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                        Utility.normaliseUUID(BleAdapterService.LEDMATRIXSTATE_CHARACTERISTIC_UUID), led_matrix_state);\n}\n\n\n\n\nVideo Demonstration - starts at 2:00\n#",
            "title": "LEDService"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#bluetooth-led-service",
            "text": "",
            "title": "Bluetooth LED Service"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It allows a connected Bluetooth master device such as a smartphone to read and write the status of the LEDs on the display. This includes reading and writing\nbitmap pattern values and sending text messages to be scrolled across the display. Scrolling speed may also be controlled over Bluetooth via a control point characteristic designed for this purpose.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#enabling-the-service",
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitLEDService(*uBit.ble, uBit.display);   Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#general-procedures",
            "text": "micro:bit has an LED display with 5 rows and 5 columns i.e. 25 LEDs in total. The Bluetooth LED service allows the entire grid to be addressed as a bitmap using the LED Matrix State characteristic which supports both read and write operations. Text strings can be sent to the micro:bit for display by writing to the LED Text characteristic and the speed with which it is scrolled can be controlled by setting a delay value in milliseconds by writing to the Scrolling Delay characteristic.  See the profile page and profile reference documentation for data format and UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth LED service. The main body of code for this demonstration can be found in ui.LEDsActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the button demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#in-bluetoothbleadapterservice",
            "text": "public static String LEDSERVICE_SERVICE_UUID = \"E95DD91D251D470AA062FA1922DFA9A8\";\npublic static String LEDMATRIXSTATE_CHARACTERISTIC_UUID = \"E95D7B77251D470AA062FA1922DFA9A8\";\npublic static String LEDTEXT_CHARACTERISTIC_UUID = \"E95D93EE251D470AA062FA1922DFA9A8\";\npublic static String SCROLLINGDELAY_CHARACTERISTIC_UUID = \"E95D0D2D251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#in-uiledsactivity",
            "text": "private short scrolling_delay;\n//    Octet 0, LED Row 1: bit4 bit3 bit2 bit1 bit0\n//    Octet 1, LED Row 2: bit4 bit3 bit2 bit1 bit0\n//    Octet 2, LED Row 3: bit4 bit3 bit2 bit1 bit0\n//    Octet 3, LED Row 4: bit4 bit3 bit2 bit1 bit0\n//    Octet 4, LED Row 5: bit4 bit3 bit2 bit1 bit0\nprivate byte[] led_matrix_state;  // read the current LED matrix state so the application UI can be initialised to match the current micro:bit display state\nbluetooth_le_adapter.readCharacteristic(\n                    Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.LEDMATRIXSTATE_CHARACTERISTIC_UUID))  // send a short text string from the application to the micro:bit\npublic void onSendText(View view) {\n    EditText text = (EditText) LEDsActivity.this.findViewById(R.id.display_text);\n    try {\n        byte[] utf8_bytes = text.getText().toString().getBytes(\"UTF-8\");\n        Log.d(Constants.TAG, \"UTF8 bytes: 0x\" + Utility.byteArrayAsHexString(utf8_bytes));\n        bluetooth_le_adapter.writeCharacteristic(\n                            Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                            Utility.normaliseUUID(BleAdapterService.LEDTEXT_CHARACTERISTIC_UUID), \n                            utf8_bytes);\n    } catch (UnsupportedEncodingException e) {\n        showMsg(\"Unable to convert text to UTF8 bytes\");\n    }\n}  // update the local state and UI in response to user interactions\n    @Override\n    public boolean onTouch(View v, MotionEvent event) {\n        Log.d(Constants.TAG, \"onTouch - \" + event.actionToString((event.getAction())));\n        if (led_matrix_state == null) {\n            Log.d(Constants.TAG, \"onTouch - LED state array has not yet been initialised so ignoring touch\");\n            return true;\n        }\n        if (event.getAction() == MotionEvent.ACTION_DOWN) {\n            GridLayout grid = (GridLayout) LEDsActivity.this.findViewById(R.id.grid);\n            int count = grid.getChildCount();\n            int display_row = 0;\n            int led_in_row = 4;\n            for (int i = 0; i < count; i++) {\n                View child = grid.getChildAt(i);\n                if (child == v) {\n                    Log.d(Constants.TAG,\"Touched row \"+display_row+\", LED \"+led_in_row);\n                    if ((led_matrix_state[display_row] & (1 << led_in_row)) != 0) {\n                        child.setBackgroundColor(Color.parseColor(\"#C0C0C0\"));\n                        led_matrix_state[display_row] = (byte) (led_matrix_state[display_row] & ~(1 << led_in_row));\n                    } else {\n                        child.setBackgroundColor(Color.RED);\n                        led_matrix_state[display_row] = (byte) (led_matrix_state[display_row] | (1 << led_in_row));\n                    }\n                    return true;\n                }\n                led_in_row = led_in_row - 1;\n                if (led_in_row < 0) {\n                    led_in_row = 4;\n                    display_row++;\n                }\n            }\n            return true;\n        }\n        return false;\n    }  // send new display state to micro:bit so it mirrors that shown on the application UI\npublic void onSetDisplay(View view) {\n    bluetooth_le_adapter.writeCharacteristic(\n                        Utility.normaliseUUID(BleAdapterService.LEDSERVICE_SERVICE_UUID), \n                        Utility.normaliseUUID(BleAdapterService.LEDMATRIXSTATE_CHARACTERISTIC_UUID), led_matrix_state);\n}",
            "title": "In ui.LEDsActivity"
        },
        {
            "location": "/lancaster-mbed/ble/led-service/#video-demonstration-starts-at-200",
            "text": "",
            "title": "Video Demonstration - starts at 2:00"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/",
            "text": "Bluetooth Magnetometer Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides live electronic compass / magnetometer data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.\n\n\nEnabling the Service\n#\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitMagnetometerService(*uBit.ble, uBit.compass);    \n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nmicro:bit includes a magnetometer or \u201cdigital compass\u201d. The Bluetooth profile gives access to magnetometer data via the Magnetometer Service which includes 3 characteristics. Magnetometer Period controls the frequency with which magnetometer data is reported over Bluetooth. Magnetometer Bearing can deliver compass bearing measurements in degrees from North as Bluetooth notifications. Similarly, Magnetometer Data supports notifications and can deliver \u201craw\u201d X, Y, Z values which describe the current bearing as a 3D vector. \n\n\n\n\nX is the magnetic field strength in the direction of magnetic north\n\n\nY is the magnetic field strength in the direction of magnetic east i.e. 90 degrees from magnetic north\n\n\nZ is the magnetic field strength vertically down \n\n\n\n\nFrom the X, Y and Z vector values it\u2019s possible to calculate the direction of magnetic north and its strength in micro-Teslas.\n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth Magnetometer service. The main body of code for this demonstration can be found in ui.MagnetometerActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the magnetometer demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String MAGNETOMETERSERVICE_SERVICE_UUID = \"E95DF2D8251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERDATA_CHARACTERISTIC_UUID = \"E95DFB11251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERPERIOD_CHARACTERISTIC_UUID = \"E95D386C251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERBEARING_CHARACTERISTIC_UUID = \"E95D9715251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.MagnetometerActivity\n#\n\n\n// enabling notifications on the Magnetometer Bearing characteristic\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERBEARING_CHARACTERISTIC_UUID), true)\n\n// enabling notifications on the Magnetometer Data characteristic\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERDATA_CHARACTERISTIC_UUID), true)                    \n\n\n\n\n// handling notifications\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MAGNETOMETERDATA_CHARACTERISTIC_UUID)))) {\n        byte[] x_bytes = new byte[2];\n        byte[] y_bytes = new byte[2];\n        byte[] z_bytes = new byte[2];\n        System.arraycopy(b, 0, x_bytes, 0, 2);\n        System.arraycopy(b, 2, y_bytes, 0, 2);\n        System.arraycopy(b, 4, z_bytes, 0, 2);\n        short raw_x = Utility.shortFromLittleEndianBytes(x_bytes);\n        short raw_y = Utility.shortFromLittleEndianBytes(y_bytes);\n        short raw_z = Utility.shortFromLittleEndianBytes(z_bytes);\n        Log.d(Constants.TAG, \"Magnetometer Data received: x=\" + raw_x + \" y=\" + raw_y + \" z=\" + raw_z);\n\n        float magnet_x = raw_x / 1000f;\n        float magnet_y = raw_y / 1000f;\n        float magnet_z = raw_z / 1000f;\n        Log.d(Constants.TAG, \"magnetometer data converted: x=\" + magnet_x + \" y=\" + magnet_y + \" z=\" + magnet_z);\n\n        magnet_input[0] = magnet_x;\n        magnet_input[1] = magnet_y;\n        magnet_input[2] = magnet_z;\n        magnet_output = Utility.lowPass(magnet_input, magnet_output);\n        Log.d(Constants.TAG, \"Smoothed magnetometer data: x=\" + magnet_output[0] + \" y=\" + magnet_output[1] + \" z=\" + magnet_output[2]);\n\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_x)).setText(\"X: \" + String.format(\"%.3f\", magnet_output[0]));\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_y)).setText(\"Y: \" + String.format(\"%.3f\", magnet_output[1]));\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_z)).setText(\"Z: \" + String.format(\"%.3f\", magnet_output[2]));\n\n    } else {\n        if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MAGNETOMETERBEARING_CHARACTERISTIC_UUID)))) {\n            byte[] bearing_bytes = new byte[2];\n            System.arraycopy(b, 0, bearing_bytes, 0, 2);\n            short bearing = Utility.shortFromLittleEndianBytes(bearing_bytes);\n            Log.d(Constants.TAG, \"Magnetometer Bearing received: \" + bearing);\n            ((TextView) MagnetometerActivity.this.findViewById(R.id.bearing)).setText(bearing + \" degrees\");\n            current_bearing = bearing;\n            String point_name = compassPoint(current_bearing);\n            Log.d(Constants.TAG, \"Point Name: \" + point_name);\n            ((TextView) MagnetometerActivity.this.findViewById(R.id.compass_point)).setText(point_name);\n        }\n    }\n    break;\n\n\n\n\nVideo Demonstration\n#",
            "title": "MagnetometerService"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#bluetooth-magnetometer-service",
            "text": "",
            "title": "Bluetooth Magnetometer Service"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#introduction",
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides live electronic compass / magnetometer data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#enabling-the-service",
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitMagnetometerService(*uBit.ble, uBit.compass);       Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#general-procedures",
            "text": "micro:bit includes a magnetometer or \u201cdigital compass\u201d. The Bluetooth profile gives access to magnetometer data via the Magnetometer Service which includes 3 characteristics. Magnetometer Period controls the frequency with which magnetometer data is reported over Bluetooth. Magnetometer Bearing can deliver compass bearing measurements in degrees from North as Bluetooth notifications. Similarly, Magnetometer Data supports notifications and can deliver \u201craw\u201d X, Y, Z values which describe the current bearing as a 3D vector.    X is the magnetic field strength in the direction of magnetic north  Y is the magnetic field strength in the direction of magnetic east i.e. 90 degrees from magnetic north  Z is the magnetic field strength vertically down    From the X, Y and Z vector values it\u2019s possible to calculate the direction of magnetic north and its strength in micro-Teslas.  See the profile page and profile reference documentation for data format and UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth Magnetometer service. The main body of code for this demonstration can be found in ui.MagnetometerActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the magnetometer demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#in-bluetoothbleadapterservice",
            "text": "public static String MAGNETOMETERSERVICE_SERVICE_UUID = \"E95DF2D8251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERDATA_CHARACTERISTIC_UUID = \"E95DFB11251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERPERIOD_CHARACTERISTIC_UUID = \"E95D386C251D470AA062FA1922DFA9A8\";\npublic static String MAGNETOMETERBEARING_CHARACTERISTIC_UUID = \"E95D9715251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#in-uimagnetometeractivity",
            "text": "// enabling notifications on the Magnetometer Bearing characteristic\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERBEARING_CHARACTERISTIC_UUID), true)\n\n// enabling notifications on the Magnetometer Data characteristic\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERSERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.MAGNETOMETERDATA_CHARACTERISTIC_UUID), true)                      // handling notifications\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MAGNETOMETERDATA_CHARACTERISTIC_UUID)))) {\n        byte[] x_bytes = new byte[2];\n        byte[] y_bytes = new byte[2];\n        byte[] z_bytes = new byte[2];\n        System.arraycopy(b, 0, x_bytes, 0, 2);\n        System.arraycopy(b, 2, y_bytes, 0, 2);\n        System.arraycopy(b, 4, z_bytes, 0, 2);\n        short raw_x = Utility.shortFromLittleEndianBytes(x_bytes);\n        short raw_y = Utility.shortFromLittleEndianBytes(y_bytes);\n        short raw_z = Utility.shortFromLittleEndianBytes(z_bytes);\n        Log.d(Constants.TAG, \"Magnetometer Data received: x=\" + raw_x + \" y=\" + raw_y + \" z=\" + raw_z);\n\n        float magnet_x = raw_x / 1000f;\n        float magnet_y = raw_y / 1000f;\n        float magnet_z = raw_z / 1000f;\n        Log.d(Constants.TAG, \"magnetometer data converted: x=\" + magnet_x + \" y=\" + magnet_y + \" z=\" + magnet_z);\n\n        magnet_input[0] = magnet_x;\n        magnet_input[1] = magnet_y;\n        magnet_input[2] = magnet_z;\n        magnet_output = Utility.lowPass(magnet_input, magnet_output);\n        Log.d(Constants.TAG, \"Smoothed magnetometer data: x=\" + magnet_output[0] + \" y=\" + magnet_output[1] + \" z=\" + magnet_output[2]);\n\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_x)).setText(\"X: \" + String.format(\"%.3f\", magnet_output[0]));\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_y)).setText(\"Y: \" + String.format(\"%.3f\", magnet_output[1]));\n        ((TextView) MagnetometerActivity.this.findViewById(R.id.magnet_z)).setText(\"Z: \" + String.format(\"%.3f\", magnet_output[2]));\n\n    } else {\n        if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.MAGNETOMETERBEARING_CHARACTERISTIC_UUID)))) {\n            byte[] bearing_bytes = new byte[2];\n            System.arraycopy(b, 0, bearing_bytes, 0, 2);\n            short bearing = Utility.shortFromLittleEndianBytes(bearing_bytes);\n            Log.d(Constants.TAG, \"Magnetometer Bearing received: \" + bearing);\n            ((TextView) MagnetometerActivity.this.findViewById(R.id.bearing)).setText(bearing + \" degrees\");\n            current_bearing = bearing;\n            String point_name = compassPoint(current_bearing);\n            Log.d(Constants.TAG, \"Point Name: \" + point_name);\n            ((TextView) MagnetometerActivity.this.findViewById(R.id.compass_point)).setText(point_name);\n        }\n    }\n    break;",
            "title": "In ui.MagnetometerActivity"
        },
        {
            "location": "/lancaster-mbed/ble/magnetometer-service/#video-demonstration",
            "text": "",
            "title": "Video Demonstration"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/",
            "text": "Bluetooth Temperature Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides live temperature data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.\nPlease note that the temperature data is inferred from the die temperature of the Nordic nrf51822 CPU. Whilst this sensor has a high precision, it is not calibrated, so will exhibit\na linear shift (although changes in temperature will be accurate). See \nMicroBitThermometer\n for information on the API to allow calibration.\n\n\nEnabling the Service\n#\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitTemperatureService(*uBit.ble, uBit.thermometer);\n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nmicro:bit can acquire a temperature reading from the surface of the nrf51822 processor and this can be shared with connected Bluetooth clients, either via Bluetooth notifications or by the client reading the current value of the Temperature characteristic. The frequency with which Temperature notifications are sent (more accurately, the frequency with which the temperature is sampled) may be configured by writing a ms value to the Temperature Period characteristic.  \n\n\nSee the profile page and profile reference documentation for data format and UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth temperature service. The main body of code for this demonstration can be found in ui.TemperatureActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the button demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String TEMPERATURESERVICE_SERVICE_UUID = \"E95D6100251D470AA062FA1922DFA9A8\";\npublic static String TEMPERATURE_CHARACTERISTIC_UUID = \"E95D9250251D470AA062FA1922DFA9A8\";\n\n\n\n\nIn ui.TemperatureActivity\n#\n\n\n// enable temperature notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.TEMPERATURESERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.TEMPERATURE_CHARACTERISTIC_UUID), true)\n\n\n\n\n// receiving temperature notifications\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    byte temperature = b[0];\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.TEMPERATURE_CHARACTERISTIC_UUID)))) {\n        Log.d(Constants.TAG, \"Temperature received: \" + temperature);\n        TextView temp = (TextView) TemperatureActivity.this.findViewById(R.id.temperature);\n        temp.setText(\"\"+temperature);\n    }\n    break;\n}\n\n\n\n\nVideo Demonstration - starts at 3:05\n#",
            "title": "TemperatureService"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#bluetooth-temperature-service",
            "text": "",
            "title": "Bluetooth Temperature Service"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#introduction",
            "text": "This Bluetooth service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the\nbackground as your main program is running. It provides live temperature data to a connected Bluetooth master device such as a smartphone. You do not need to explicitly address an API on the service to achieve this.\nPlease note that the temperature data is inferred from the die temperature of the Nordic nrf51822 CPU. Whilst this sensor has a high precision, it is not calibrated, so will exhibit\na linear shift (although changes in temperature will be accurate). See  MicroBitThermometer  for information on the API to allow calibration.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#enabling-the-service",
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitTemperatureService(*uBit.ble, uBit.thermometer);   Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling the Service"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#general-procedures",
            "text": "micro:bit can acquire a temperature reading from the surface of the nrf51822 processor and this can be shared with connected Bluetooth clients, either via Bluetooth notifications or by the client reading the current value of the Temperature characteristic. The frequency with which Temperature notifications are sent (more accurately, the frequency with which the temperature is sampled) may be configured by writing a ms value to the Temperature Period characteristic.    See the profile page and profile reference documentation for data format and UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a full demonstration of the micro:bit Bluetooth temperature service. The main body of code for this demonstration can be found in ui.TemperatureActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the button demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#in-bluetoothbleadapterservice",
            "text": "public static String TEMPERATURESERVICE_SERVICE_UUID = \"E95D6100251D470AA062FA1922DFA9A8\";\npublic static String TEMPERATURE_CHARACTERISTIC_UUID = \"E95D9250251D470AA062FA1922DFA9A8\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#in-uitemperatureactivity",
            "text": "// enable temperature notifications\nbluetooth_le_adapter.setNotificationsState(\n                    Utility.normaliseUUID(BleAdapterService.TEMPERATURESERVICE_SERVICE_UUID), \n                    Utility.normaliseUUID(BleAdapterService.TEMPERATURE_CHARACTERISTIC_UUID), true)  // receiving temperature notifications\ncase BleAdapterService.NOTIFICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    byte temperature = b[0];\n    Log.d(Constants.TAG, \"Value=\" + Utility.byteArrayAsHexString(b));\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.TEMPERATURE_CHARACTERISTIC_UUID)))) {\n        Log.d(Constants.TAG, \"Temperature received: \" + temperature);\n        TextView temp = (TextView) TemperatureActivity.this.findViewById(R.id.temperature);\n        temp.setText(\"\"+temperature);\n    }\n    break;\n}",
            "title": "In ui.TemperatureActivity"
        },
        {
            "location": "/lancaster-mbed/ble/temperature-service/#video-demonstration-starts-at-305",
            "text": "",
            "title": "Video Demonstration - starts at 3:05"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/",
            "text": "Bluetooth UART Service\n#\n\n\nIntroduction\n#\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides a form of serial data communications capability over Bluetooth low energy and can be used to exchange arbitrary sequences of bytes in either direction between micro:bit and connected peer.\n\n\nEnabling and Using the Service\n#\n\n\nThis service is disabled by default. To enable the service, create an instance of this class in your program at any time after the uBit object has been initialised. Send data from the micro:bit to the connected peer at any time using one of the send methods of the MicroBitUARTService class. To receive data from the connected peer use one of several methods such as readUntil which blocks until a specified delimiter value is received and then returns all previous octets in the receive buffer. Consult the API for details.\n\n\nNote that it may make sense to coordinate use of the UART service with the state of the Bluetooth connection, only reading or sending serial data when there is an active Bluetooth connection. Two micro:bit message bus events are provided for this purpose. A full example appears below.\n\n\nMicroBitUARTService *uart;   \n\n\n\n\n\n\nNote\n\n\nUsing Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBluetooth Service Specification\n#\n\n\nPlease see the \nmicro:bit Bluetooth profile specification\n.\n\n\nExample micro:bit application - Animal Vegetable Mineral game\n#\n\n\n#include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\n#include \"MicroBitUARTService.h\"\nMicroBit uBit;\nMicroBitUARTService *uart;\n\nint connected = 0;\n\nvoid onConnected(MicroBitEvent e)\n{\n    uBit.display.scroll(\"C\");\n\n    connected = 1;\n\n    // my client will send ASCII strings terminated with the colon character\n    ManagedString eom(\":\");\n\n    while (connected == 1) {\n        ManagedString msg = uart->readUntil(eom);\n        uBit.display.scroll(msg);\n    }\n\n}\n\nvoid onDisconnected(MicroBitEvent e)\n{\n    uBit.display.scroll(\"D\");\n    connected = 0;\n}\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"YES\");\n    uBit.display.scroll(\"YES\");\n}\n\nvoid onButtonB(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"NO\");\n    uBit.display.scroll(\"NO\");\n}\n\nvoid onButtonAB(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"GOT IT!!\");\n    uBit.display.scroll(\"GOT IT!!\");\n}\n\n/*\nRecommend disabling the DFU and Event services in MicroBitConfig.h since they are not needed here:\n\n#ifndef MICROBIT_BLE_DFU_SERVICE\n#define MICROBIT_BLE_DFU_SERVICE                0\n#endif\n\n#ifndef MICROBIT_BLE_EVENT_SERVICE\n#define MICROBIT_BLE_EVENT_SERVICE              0\n#endif\n*/\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    // listen for Bluetooth connection state changes\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);\n\n    // listen for user button interactions\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonB);\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_AB, MICROBIT_BUTTON_EVT_CLICK, onButtonAB);\n\n\n    // Note GATT table size increased from default in MicroBitConfig.h\n    // #define MICROBIT_SD_GATT_TABLE_SIZE             0x500\n    uart = new MicroBitUARTService(*uBit.ble, 32, 32); \n    uBit.display.scroll(\"AVM\");\n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}\n\n\n\n\nKnown Issue\n In the onConnected event handler method, the call to ManagedString msg = uart->readUntil(eom); blocks until the specified end of message character is received. This prevents the event handler from exiting. Under normal circumstances this is fine. If however the connected application loses its connection and then reconnects, the onConnected method will not execute and therefore the \u2018connected\u2019 variable which tracks the Bluetooth connection state will not update. The micro:bit application will now behave as though it is not in a connection and therefore functions such as sending text by pressing a button will not work. In this situation the user should simply reset their micro:bit and reconnect their smartphone application. An API which allows serial reads to unblock or perhaps threads to be terminated is under consideration for a future release of the micro:bit runtime.  \n\n\nExample Applications for Android/IOS/Android\n#\n\n\nGeneral Procedures\n#\n\n\nA connected peer such as a smartphone application can transmit data to the micro:bit, up to a maximum of 20 octets at a time by writing to the RX Characteristic. Either of the Write Request or Write Command (i.e. write with no response) PDUs may be used by the client. \n\n\nSee the profile page and profile reference documentation UUID details.\n\n\nAndroid\n#\n\n\n\n\nAndroid Bluetooth APIs\n#\n\n\nAndroid developers should make themselves familiar with the \nAndroid Bluetooth low energy APIs\n\n\nmicrobit-ble-demo-android\n#\n\n\nThe open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth UART service in the form of a guessing game called Animal Vegetable Mineral. The main body of code for this demonstration can be found in ui.UartAvmActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.\n\n\nKey parts of the magnetometer demonstration in this application are explained next.\n\n\nIn bluetooth.BleAdapterService\n#\n\n\npublic static String UARTSERVICE_SERVICE_UUID = \"6E400001B5A3F393E0A9E50E24DCCA9E\";\npublic static String UART_RX_CHARACTERISTIC_UUID = \"6E400002B5A3F393E0A9E50E24DCCA9E\";\npublic static String UART_TX_CHARACTERISTIC_UUID = \"6E400003B5A3F393E0A9E50E24DCCA9E\";\n\n\n\n\nIn ui.UartAvmActivity\n#\n\n\n// enabling indications on the UART TX characteristic\nif (bluetooth_le_adapter.setIndicationsState(Utility.normaliseUUID(BleAdapterService.UARTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.UART_TX_CHARACTERISTIC_UUID), true)) {\n    showMsg(Utility.htmlColorGreen(\"UART TX indications ON\"));\n} else {\n    showMsg(Utility.htmlColorRed(\"Failed to set UART TX indications ON\"));\n}\n\n\n\n\n// handling indications\ncase BleAdapterService.NOTIFICATION_OR_INDICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.UART_TX_CHARACTERISTIC_UUID)))) {\n        String ascii=\"\";\n        try {\n            ascii = new String(b,\"US-ASCII\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            showMsg(Utility.htmlColorGreen(\"Could not convert TX data to ASCII\"));\n            return;\n        }\n        if (!ascii.equals(Constants.AVM_CORRECT_RESPONSE)) {\n            showAnswer(ascii);\n        } else {\n            showAnswer(ascii+\" You only needed \"+guess_count+\" guesses!\");\n        }\n    }\n    break; \n\n\n\n\n// sending data to the micro:bit by writing to the RX Characteristic\npublic void onSendText(View view) {\n    EditText text = (EditText) UartAvmActivity.this.findViewById(R.id.avm_question_text);\n    try {\n        String question = text.getText().toString() + \":\";\n        byte[] ascii_bytes = question.getBytes(\"US-ASCII\");\n        bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.UARTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.UART_RX_CHARACTERISTIC_UUID), ascii_bytes);\n        guess_count++;\n        showGuessCount();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        showMsg(\"Unable to convert text to ASCII bytes\");\n    }\n}\n\n\n\n\nVideo Demonstration\n#",
            "title": "UARTService"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#bluetooth-uart-service",
            "text": "",
            "title": "Bluetooth UART Service"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#introduction",
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the background as your main program is running. It provides a form of serial data communications capability over Bluetooth low energy and can be used to exchange arbitrary sequences of bytes in either direction between micro:bit and connected peer.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#enabling-and-using-the-service",
            "text": "This service is disabled by default. To enable the service, create an instance of this class in your program at any time after the uBit object has been initialised. Send data from the micro:bit to the connected peer at any time using one of the send methods of the MicroBitUARTService class. To receive data from the connected peer use one of several methods such as readUntil which blocks until a specified delimiter value is received and then returns all previous octets in the receive buffer. Consult the API for details.  Note that it may make sense to coordinate use of the UART service with the state of the Bluetooth connection, only reading or sending serial data when there is an active Bluetooth connection. Two micro:bit message bus events are provided for this purpose. A full example appears below.  MicroBitUARTService *uart;      Note  Using Bluetooth services is memory hungry. By default, some of the memory normally used by Nordic\u2019s Bluetooth protocol stack (known as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more Bluetooth services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your Bluetooth application cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.",
            "title": "Enabling and Using the Service"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#bluetooth-service-specification",
            "text": "Please see the  micro:bit Bluetooth profile specification .",
            "title": "Bluetooth Service Specification"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#example-microbit-application-animal-vegetable-mineral-game",
            "text": "#include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\n#include \"MicroBitUARTService.h\"\nMicroBit uBit;\nMicroBitUARTService *uart;\n\nint connected = 0;\n\nvoid onConnected(MicroBitEvent e)\n{\n    uBit.display.scroll(\"C\");\n\n    connected = 1;\n\n    // my client will send ASCII strings terminated with the colon character\n    ManagedString eom(\":\");\n\n    while (connected == 1) {\n        ManagedString msg = uart->readUntil(eom);\n        uBit.display.scroll(msg);\n    }\n\n}\n\nvoid onDisconnected(MicroBitEvent e)\n{\n    uBit.display.scroll(\"D\");\n    connected = 0;\n}\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"YES\");\n    uBit.display.scroll(\"YES\");\n}\n\nvoid onButtonB(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"NO\");\n    uBit.display.scroll(\"NO\");\n}\n\nvoid onButtonAB(MicroBitEvent e)\n{\n    if (connected == 0) {\n        uBit.display.scroll(\"NC\");\n        return;\n    }\n    uart->send(\"GOT IT!!\");\n    uBit.display.scroll(\"GOT IT!!\");\n}\n\n/*\nRecommend disabling the DFU and Event services in MicroBitConfig.h since they are not needed here:\n\n#ifndef MICROBIT_BLE_DFU_SERVICE\n#define MICROBIT_BLE_DFU_SERVICE                0\n#endif\n\n#ifndef MICROBIT_BLE_EVENT_SERVICE\n#define MICROBIT_BLE_EVENT_SERVICE              0\n#endif\n*/\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    // listen for Bluetooth connection state changes\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);\n\n    // listen for user button interactions\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonB);\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_AB, MICROBIT_BUTTON_EVT_CLICK, onButtonAB);\n\n\n    // Note GATT table size increased from default in MicroBitConfig.h\n    // #define MICROBIT_SD_GATT_TABLE_SIZE             0x500\n    uart = new MicroBitUARTService(*uBit.ble, 32, 32); \n    uBit.display.scroll(\"AVM\");\n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}  Known Issue  In the onConnected event handler method, the call to ManagedString msg = uart->readUntil(eom); blocks until the specified end of message character is received. This prevents the event handler from exiting. Under normal circumstances this is fine. If however the connected application loses its connection and then reconnects, the onConnected method will not execute and therefore the \u2018connected\u2019 variable which tracks the Bluetooth connection state will not update. The micro:bit application will now behave as though it is not in a connection and therefore functions such as sending text by pressing a button will not work. In this situation the user should simply reset their micro:bit and reconnect their smartphone application. An API which allows serial reads to unblock or perhaps threads to be terminated is under consideration for a future release of the micro:bit runtime.",
            "title": "Example micro:bit application - Animal Vegetable Mineral game"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#example-applications-for-androidiosandroid",
            "text": "",
            "title": "Example Applications for Android/IOS/Android"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#general-procedures",
            "text": "A connected peer such as a smartphone application can transmit data to the micro:bit, up to a maximum of 20 octets at a time by writing to the RX Characteristic. Either of the Write Request or Write Command (i.e. write with no response) PDUs may be used by the client.   See the profile page and profile reference documentation UUID details.",
            "title": "General Procedures"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#android",
            "text": "",
            "title": "Android"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#android-bluetooth-apis",
            "text": "Android developers should make themselves familiar with the  Android Bluetooth low energy APIs",
            "title": "Android Bluetooth APIs"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#microbit-ble-demo-android",
            "text": "The open source microbit-ble-demo-android application contains a demonstration of the micro:bit Bluetooth UART service in the form of a guessing game called Animal Vegetable Mineral. The main body of code for this demonstration can be found in ui.UartAvmActivity.java except for the Bluetooth operations themselves which are in bluetooth.BleAdapterService which acts as a kind of higher level Bluetooth API for activities to use without needing to directly concern themselves too closely with the Android APIs themselves. In most cases, operations are asynchronous so that the activity code initiates a Bluetooth operation by calling one of the methods in bluetooth.BleAdapterService (e.g. readCharacteristic(....) ) and later receives a message containing the result of the operation from this object via a Handler object. The message is examined in the Handler code and acted upon.  Key parts of the magnetometer demonstration in this application are explained next.",
            "title": "microbit-ble-demo-android"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#in-bluetoothbleadapterservice",
            "text": "public static String UARTSERVICE_SERVICE_UUID = \"6E400001B5A3F393E0A9E50E24DCCA9E\";\npublic static String UART_RX_CHARACTERISTIC_UUID = \"6E400002B5A3F393E0A9E50E24DCCA9E\";\npublic static String UART_TX_CHARACTERISTIC_UUID = \"6E400003B5A3F393E0A9E50E24DCCA9E\";",
            "title": "In bluetooth.BleAdapterService"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#in-uiuartavmactivity",
            "text": "// enabling indications on the UART TX characteristic\nif (bluetooth_le_adapter.setIndicationsState(Utility.normaliseUUID(BleAdapterService.UARTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.UART_TX_CHARACTERISTIC_UUID), true)) {\n    showMsg(Utility.htmlColorGreen(\"UART TX indications ON\"));\n} else {\n    showMsg(Utility.htmlColorRed(\"Failed to set UART TX indications ON\"));\n}  // handling indications\ncase BleAdapterService.NOTIFICATION_OR_INDICATION_RECEIVED:\n    bundle = msg.getData();\n    service_uuid = bundle.getString(BleAdapterService.PARCEL_SERVICE_UUID);\n    characteristic_uuid = bundle.getString(BleAdapterService.PARCEL_CHARACTERISTIC_UUID);\n    b = bundle.getByteArray(BleAdapterService.PARCEL_VALUE);\n    if (characteristic_uuid.equalsIgnoreCase((Utility.normaliseUUID(BleAdapterService.UART_TX_CHARACTERISTIC_UUID)))) {\n        String ascii=\"\";\n        try {\n            ascii = new String(b,\"US-ASCII\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            showMsg(Utility.htmlColorGreen(\"Could not convert TX data to ASCII\"));\n            return;\n        }\n        if (!ascii.equals(Constants.AVM_CORRECT_RESPONSE)) {\n            showAnswer(ascii);\n        } else {\n            showAnswer(ascii+\" You only needed \"+guess_count+\" guesses!\");\n        }\n    }\n    break;   // sending data to the micro:bit by writing to the RX Characteristic\npublic void onSendText(View view) {\n    EditText text = (EditText) UartAvmActivity.this.findViewById(R.id.avm_question_text);\n    try {\n        String question = text.getText().toString() + \":\";\n        byte[] ascii_bytes = question.getBytes(\"US-ASCII\");\n        bluetooth_le_adapter.writeCharacteristic(Utility.normaliseUUID(BleAdapterService.UARTSERVICE_SERVICE_UUID), Utility.normaliseUUID(BleAdapterService.UART_RX_CHARACTERISTIC_UUID), ascii_bytes);\n        guess_count++;\n        showGuessCount();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        showMsg(\"Unable to convert text to ASCII bytes\");\n    }\n}",
            "title": "In ui.UartAvmActivity"
        },
        {
            "location": "/lancaster-mbed/ble/uart-service/#video-demonstration",
            "text": "",
            "title": "Video Demonstration"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/",
            "text": "Bluetooth Connection Events\n#\n\n\nIntroduction\n#\n\n\nTwo MicroBitEvent types are available for tracking changes in the state of Bluetooth connections between remote devices and the micro:bit.\n\n\nMICROBIT_BLE_EVT_CONNECTED\n#\n\n\nThis event is produced when a remote peer device connects to the micro:bit over Bluetooth.\n\n\nTo listen for this event:\n\n\nuBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);\n\n\n\n\nMICROBIT_BLE_EVT_DISCONNECTED\n#\n\n\nThis event is produced when a remote Bluetooth device disconnects from the micro:bit.\n\n\nTo listen for this event:\n\n\nuBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);\n\n\n\n\nExample micro:bit application - Keeping track of connection state\n#\n\n\n\n\n\n\n\n\nConnected\n\n\nDisconnected\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\nMicroBit uBit;\nint connected = 0;\n\nvoid onConnected(MicroBitEvent e)\n{\n    uBit.display.print(\"C\");\n    connected = 1;\n}\n\nvoid onDisconnected(MicroBitEvent e)\n{\n    uBit.display.print(\"D\");\n    connected = 0;\n}\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    // listen for Bluetooth connection state changes\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);\n\n    uBit.display.scroll(\"READY\");\n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}",
            "title": "Connection Events"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/#bluetooth-connection-events",
            "text": "",
            "title": "Bluetooth Connection Events"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/#introduction",
            "text": "Two MicroBitEvent types are available for tracking changes in the state of Bluetooth connections between remote devices and the micro:bit.",
            "title": "Introduction"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/#microbit_ble_evt_connected",
            "text": "This event is produced when a remote peer device connects to the micro:bit over Bluetooth.  To listen for this event:  uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);",
            "title": "MICROBIT_BLE_EVT_CONNECTED"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/#microbit_ble_evt_disconnected",
            "text": "This event is produced when a remote Bluetooth device disconnects from the micro:bit.  To listen for this event:  uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);",
            "title": "MICROBIT_BLE_EVT_DISCONNECTED"
        },
        {
            "location": "/lancaster-mbed/ble/ble-connection-events/#example-microbit-application-keeping-track-of-connection-state",
            "text": "Connected  Disconnected           #include \"MicroBit.h\"\n#include \"MicroBitSamples.h\"\nMicroBit uBit;\nint connected = 0;\n\nvoid onConnected(MicroBitEvent e)\n{\n    uBit.display.print(\"C\");\n    connected = 1;\n}\n\nvoid onDisconnected(MicroBitEvent e)\n{\n    uBit.display.print(\"D\");\n    connected = 0;\n}\n\nint main()\n{\n    // Initialise the micro:bit runtime.\n    uBit.init();\n\n    // listen for Bluetooth connection state changes\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_CONNECTED, onConnected);\n    uBit.messageBus.listen(MICROBIT_ID_BLE, MICROBIT_BLE_EVT_DISCONNECTED, onDisconnected);\n\n    uBit.display.scroll(\"READY\");\n\n    // If main exits, there may still be other fibers running or registered event handlers etc.\n    // Simply release this fiber, which will mean we enter the scheduler. Worse case, we then\n    // sit in the idle task forever, in a power efficient sleep.\n    release_fiber();\n}",
            "title": "Example micro:bit application - Keeping track of connection state"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/",
            "text": "MicroBitLightSensor\n#\n\n\nOperation\n#\n\n\nSensing Pins\n#\n\n\nIf the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the \nsame colour\n of light it emits.\n\n\nYou will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.\n\n\nThe display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:\n\n\n\n\nWhere the format is: \nROW\n.\nCOLUMN\n\n\nOn the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.\n\n\nThis means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.\n\n\nThe 9 sense pins are illustrated below:\n\n\n\n\n _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nThe ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.\n\n\nInterleaving\n#\n\n\nIn the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the \ndisplay\n\nwhich is automatically activated when \nreadLightLevel\n is called by the user.\n\n\nThis special mode (\nDISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n), increases the rate of the \nsystemTick\n callback to 5ms, and the\n\ndisplay\n is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.\n\n\nTo signify the window for user processing, the display will fire an event:\n\n\n\n\nID\n: \nMICROBIT_ID_DISPLAY\n\n\nValue\n: \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n\n\n\n\nThis will trigger an event handler in the \nMicroBitLightSensor\n class.\n\n\nSensing Life Cycle\n#\n\n\nIn the previous section we discussed how the \ndisplay\n and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n event.\n\n\n\n\n\n\nNote\n\n\nIf you would like to manually trigger the Light Sensor, a few steps must be taken:\n\n1) Disable the display so that the column pins are under the users\u2019 control.\n\n2) Construct an instance of \nMicroBitLightSensor\n\n3) Trigger the Light Sensor by firing a \nMicroBitEvent\n with the ID \nMICROBIT_ID_DISPLAY\n and the value \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n.\n\n\n\n\nThe Concept of Channels\n#\n\n\nAs we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.\n\n\nWe found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:\n\n\n\n\n _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nWhere each number represents a different column, now named a channel as it is a collection of 3 rows\n\n\nThis reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.\n\n\nHowever, we do gain an accurate picture of the overall brightness detected by the display.\n\n\nWe expose a mean representation of the light level from the 3 channels on the display.\n\n\nThe Algorithm\n#\n\n\nUpon receiving an event:\n\n\n\n\nSet all rows to be a DigitalOut, with a value of 0.\n\n\nFor the current channel:\n\n\nSet the current channel pin HI.\n\n\nImmediately transition the current channel to be an AnalogIn\n\n\n\n\n\n\nAttach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)\n\n\n\n\nUpon interrupt:\n\n\n\n\nObtain our analog value.\n\n\nRelease the pin from GPIOTE control. (\nIf we do not do these, this column will not\nbe useable in the display driver\n)\n\n\nMove onto the next channel.\n\n\n\n\nAfter these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.\n\n\nMessage Bus ID\n#\n\n\nMessage Bus Events\n#\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitLightSensor( \nconst  MatrixMap  &\n map)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a representation of the light sensor.  \n\n\nmap \n\n\nThe mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .   \n\n\nParameters\n#\n\n\n\n\nconst  MatrixMap  &\n map - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h . \n\n\n\n\nread\n#\n\n\n\n\nint\n \nread\n()\n#\n\n\nDescription\n#\n\n\nThis method returns a summed average of the three sections of the display.  \n\n\nA section is defined as: \n\n | 1 | | 2 | | 3 | \n\n\n    \n    \n    \n    ___     \n\n\n    \n    \n    \n    ___    \n\n\n2         3         1    \n\n\n    \n    \n    \n    ___    \n\n\n    \n    \n    \n    ___    \n\n\n3         1         2    \n\n\n    \n    \n    \n    ___    \n\n\nWhere each number represents a different section on the 5 x 5 matrix display.  \n\n\nReturns\n#\n\n\nreturns a value in the range 0 - 255 where 0 is dark, and 255 is very bright \n\n\nstartSensing\n#\n\n\n\n\nvoid\n \nstartSensing\n( \nMicroBitEvent\n )\n#\n\n\nDescription\n#\n\n\nThe method that is invoked by sending MICROBIT_DISPLAY_EVT_LIGHT_SENSE using the id MICROBIT_ID_DISPLAY.  \n\n\nParameters\n#\n\n\n\n\nMicroBitEvent\n \n\n\n\n\n\n\nNote\n\n\nthis can be manually driven by calling this member function, with a  MicroBitEvent  using the CREATE_ONLY option of the  MicroBitEvent  constructor.",
            "title": "MicroBitLightSensor"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#microbitlightsensor",
            "text": "",
            "title": "MicroBitLightSensor"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#operation",
            "text": "",
            "title": "Operation"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#sensing-pins",
            "text": "If the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the  same colour  of light it emits.  You will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.  The display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:   Where the format is:  ROW . COLUMN  On the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.  This means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.  The 9 sense pins are illustrated below:    _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|   The ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.",
            "title": "Sensing Pins"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#interleaving",
            "text": "In the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the  display \nwhich is automatically activated when  readLightLevel  is called by the user.  This special mode ( DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE ), increases the rate of the  systemTick  callback to 5ms, and the display  is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.  To signify the window for user processing, the display will fire an event:   ID :  MICROBIT_ID_DISPLAY  Value :  MICROBIT_DISPLAY_EVT_LIGHT_SENSE   This will trigger an event handler in the  MicroBitLightSensor  class.",
            "title": "Interleaving"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#sensing-life-cycle",
            "text": "In the previous section we discussed how the  display  and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe  MICROBIT_DISPLAY_EVT_LIGHT_SENSE  event.    Note  If you would like to manually trigger the Light Sensor, a few steps must be taken: \n1) Disable the display so that the column pins are under the users\u2019 control. \n2) Construct an instance of  MicroBitLightSensor \n3) Trigger the Light Sensor by firing a  MicroBitEvent  with the ID  MICROBIT_ID_DISPLAY  and the value  MICROBIT_DISPLAY_EVT_LIGHT_SENSE .",
            "title": "Sensing Life Cycle"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#the-concept-of-channels",
            "text": "As we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.  We found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:    _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|   Where each number represents a different column, now named a channel as it is a collection of 3 rows  This reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.  However, we do gain an accurate picture of the overall brightness detected by the display.  We expose a mean representation of the light level from the 3 channels on the display.",
            "title": "The Concept of Channels"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#the-algorithm",
            "text": "Upon receiving an event:   Set all rows to be a DigitalOut, with a value of 0.  For the current channel:  Set the current channel pin HI.  Immediately transition the current channel to be an AnalogIn    Attach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)   Upon interrupt:   Obtain our analog value.  Release the pin from GPIOTE control. ( If we do not do these, this column will not\nbe useable in the display driver )  Move onto the next channel.   After these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.",
            "title": "The Algorithm"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#message-bus-id",
            "text": "",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#message-bus-events",
            "text": "",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#microbitlightsensor-const-matrixmap-map",
            "text": "",
            "title": "MicroBitLightSensor( const  MatrixMap  &amp; map)"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#description",
            "text": "Constructor.    Create a representation of the light sensor.    map   The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#parameters",
            "text": "const  MatrixMap  &  map - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#read",
            "text": "",
            "title": "read"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#int-read",
            "text": "",
            "title": "int read()"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#description_1",
            "text": "This method returns a summed average of the three sections of the display.    A section is defined as:  \n | 1 | | 2 | | 3 |                      ___                          ___      2         3         1                         ___                         ___      3         1         2                         ___      Where each number represents a different section on the 5 x 5 matrix display.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#returns",
            "text": "returns a value in the range 0 - 255 where 0 is dark, and 255 is very bright",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#startsensing",
            "text": "",
            "title": "startSensing"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#void-startsensing-microbitevent",
            "text": "",
            "title": "void startSensing( MicroBitEvent )"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#description_2",
            "text": "The method that is invoked by sending MICROBIT_DISPLAY_EVT_LIGHT_SENSE using the id MICROBIT_ID_DISPLAY.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/extras/light-sensing/#parameters_1",
            "text": "MicroBitEvent      Note  this can be manually driven by calling this member function, with a  MicroBitEvent  using the CREATE_ONLY option of the  MicroBitEvent  constructor.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/extras/spi/",
            "text": "SPI\n#\n\n\nSPI on the micro:bit is supported in the micro:bit runtime through the ARM mbed \nSPI\n class.\nHowever, by design, this is this is not initialised by default as part of the uBit object.\n\n\nThe reasons for this are:\n\n\n\n\nSPI requires the dedicated use of three GPIO pins. Committing these pins would prevent them from being used as general purpose I/O\n\n\nThe SPI module also requires a small amount of additional memory to operate, and this is not necessary for the majority of applications\n\n\n\n\n\n\nNote\n\n\nWe may wrap SPI in the future and attach it to the \nMicroBit\n class\nto provide lazy initialisation of the SPI module.\n\n\n\n\nIn the meantime we recommend you instantiate your own instance of \nSPI\n, using the mbed \nSPI\n class:\n\n\nSPI spi(MOSI, MISO, SCK);",
            "title": "SPI"
        },
        {
            "location": "/lancaster-mbed/extras/spi/#spi",
            "text": "SPI on the micro:bit is supported in the micro:bit runtime through the ARM mbed  SPI  class.\nHowever, by design, this is this is not initialised by default as part of the uBit object.  The reasons for this are:   SPI requires the dedicated use of three GPIO pins. Committing these pins would prevent them from being used as general purpose I/O  The SPI module also requires a small amount of additional memory to operate, and this is not necessary for the majority of applications    Note  We may wrap SPI in the future and attach it to the  MicroBit  class\nto provide lazy initialisation of the SPI module.   In the meantime we recommend you instantiate your own instance of  SPI , using the mbed  SPI  class:  SPI spi(MOSI, MISO, SCK);",
            "title": "SPI"
        },
        {
            "location": "/lancaster-mbed/ubit/blemanager/",
            "text": "",
            "title": "_blemanager"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/",
            "text": "uBit.buttonAB\n#\n\n\nOverview\n#\n\n\nA \nMicroBitMultiButton\n mirrors the state of two \nMicroBitButton\ns\nusing the message bus eventing mechanism. It provides a similar API and emits\nthe same events as as a \nMicroBitButton\n.\n\n\nMessage Bus ID\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_AB\n\n\n26\n\n\n\n\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitMultiButton( \nuint16_t\n button1,  \nuint16_t\n button2,  \nuint16_t\n id)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreate a representation of a virtual button, that generates events based upon the combination of two given buttons.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n button1 - the unique ID of the first button to watch.\n\n\nuint16_t\n button2 - the unique ID of the second button to watch.\n\n\nuint16_t\n id - the unique  EventModel  id of this  MicroBitMultiButton  instance.\n\n\n\n\nExample\n#\n\n\n multiButton(MICROBIT_ID_BUTTON_A, MICROBIT_ID_BUTTON_B, MICROBIT_ID_BUTTON_AB); \n\n\n\n\nisPressed\n#\n\n\n\n\nint\n \nisPressed\n()\n#\n\n\nDescription\n#\n\n\nTests if this  MicroBitMultiButton  instance is virtually pressed.  \n\n\nReturns\n#\n\n\n1 if both physical buttons are pressed simultaneously.\n\n\nExample\n#\n\n\n if(buttonAB.isPressed()) \n display.scroll(\"Pressed!\"); \n\n\n\n\nsetEventConfiguration\n#\n\n\n\n\nvoid\n \nsetEventConfiguration\n( \nMicroBitButtonEventConfiguration\n config)\n#\n\n\nDescription\n#\n\n\nChanges the event configuration of this button to the given MicroBitButtonEventConfiguration. All subsequent events generated by this button will then be informed by this configuration.  \n\n\nParameters\n#\n\n\n\n\nMicroBitButtonEventConfiguration\n config - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.\n\n\n\n\nExample\n#\n\n\n // Configure a button to generate all possible events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);",
            "title": "_buttonAB"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#ubitbuttonab",
            "text": "",
            "title": "uBit.buttonAB"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#overview",
            "text": "A  MicroBitMultiButton  mirrors the state of two  MicroBitButton s\nusing the message bus eventing mechanism. It provides a similar API and emits\nthe same events as as a  MicroBitButton .",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#message-bus-id",
            "text": "Constant  Value      MICROBIT_ID_BUTTON_AB  26",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#message-bus-events",
            "text": "Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#microbitmultibutton-uint16_t-button1-uint16_t-button2-uint16_t-id",
            "text": "",
            "title": "MicroBitMultiButton( uint16_t button1,  uint16_t button2,  uint16_t id)"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#description",
            "text": "Constructor.    Create a representation of a virtual button, that generates events based upon the combination of two given buttons.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#parameters",
            "text": "uint16_t  button1 - the unique ID of the first button to watch.  uint16_t  button2 - the unique ID of the second button to watch.  uint16_t  id - the unique  EventModel  id of this  MicroBitMultiButton  instance.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#example",
            "text": "multiButton(MICROBIT_ID_BUTTON_A, MICROBIT_ID_BUTTON_B, MICROBIT_ID_BUTTON_AB);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#ispressed",
            "text": "",
            "title": "isPressed"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#int-ispressed",
            "text": "",
            "title": "int isPressed()"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#description_1",
            "text": "Tests if this  MicroBitMultiButton  instance is virtually pressed.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#returns",
            "text": "1 if both physical buttons are pressed simultaneously.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#example_1",
            "text": "if(buttonAB.isPressed()) \n display.scroll(\"Pressed!\");",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#seteventconfiguration",
            "text": "",
            "title": "setEventConfiguration"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#void-seteventconfiguration-microbitbuttoneventconfiguration-config",
            "text": "",
            "title": "void setEventConfiguration( MicroBitButtonEventConfiguration config)"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#description_2",
            "text": "Changes the event configuration of this button to the given MicroBitButtonEventConfiguration. All subsequent events generated by this button will then be informed by this configuration.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#parameters_1",
            "text": "MicroBitButtonEventConfiguration  config - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/multibutton/#example_2",
            "text": "// Configure a button to generate all possible events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);",
            "title": "Example"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/",
            "text": "uBit.radio.event\n#\n\n\nOverview\n#\n\n\nIt is also possible to transparently send and receive events over the \nMicroBitRadio\n channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.\n\n\nTo use this functionality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the \nMicroBitMessageBus\n for details of how to write\nevent handlers.\n\n\nFor example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:\n\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.radio.enable();\n\n    // Ensure the radio is listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(1000);\n    }\n}\n\n\n\n\n\u2026and on the micro:bits wanting to receive the event:\n\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync(\"Something!\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\nNone.\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitRadioEvent( \nMicroBitRadio  &\n r)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreates an instance of  MicroBitRadioEvent  which offers the ability to extend the micro:bit\u2019s default  EventModel  to other micro:bits in the vicinity.  \n\n\nr \n\n\nThe underlying radio module used to send and receive data.   \n\n\nParameters\n#\n\n\n\n\nMicroBitRadio  &\n r - The underlying radio module used to send and receive data. \n\n\n\n\nlisten\n#\n\n\n\n\nint\n \nlisten\n( \nuint16_t\n id,  \nuint16_t\n value)\n#\n\n\nDescription\n#\n\n\nAssociates the given event with the radio channel.  \n\n\nOnce registered, all events matching the given registration sent to this micro:bit\u2019s default  EventModel  will be automatically retransmitted on the radio.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id of the event to register.\n\n\nuint16_t\n value - the value of the event to register.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if no default  EventModel  is available.\n\n\n\n\nNote\n\n\nThe wildcards MICROBIT_ID_ANY and MICROBIT_EVT_ANY can also be in place of the id and value fields. \n\n\n\n\n\n\nint\n \nlisten\n( \nuint16_t\n id,  \nuint16_t\n value,  \nEventModel  &\n eventBus)\n#\n\n\nDescription\n#\n\n\nAssociates the given event with the radio channel.  \n\n\nOnce registered, all events matching the given registration sent to the given  EventModel  will be automatically retransmitted on the radio.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id of the events to register.\n\n\nuint16_t\n value - the value of the event to register.\n\n\nEventModel  &\n eventBus - The  EventModel  to listen for events on.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success.\n\n\n\n\nNote\n\n\nThe wildcards MICROBIT_ID_ANY and MICROBIT_EVT_ANY can also be in place of the id and value fields. \n\n\n\n\nignore\n#\n\n\n\n\nint\n \nignore\n( \nuint16_t\n id,  \nuint16_t\n value)\n#\n\n\nDescription\n#\n\n\nDisassociates the given event with the radio channel.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id of the events to deregister.\n\n\nuint16_t\n value - The value of the event to deregister.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the default message bus does not exist.\n\n\n\n\nNote\n\n\nMICROBIT_EVT_ANY can be used to deregister all event values matching the given id. \n\n\n\n\n\n\nint\n \nignore\n( \nuint16_t\n id,  \nuint16_t\n value,  \nEventModel  &\n eventBus)\n#\n\n\nDescription\n#\n\n\nDisassociates the given events with the radio channel.  \n\n\nParameters\n#\n\n\n\n\nuint16_t\n id - The id of the events to deregister.\n\n\nuint16_t\n value - The value of the event to deregister.\n\n\nEventModel  &\n eventBus - The  EventModel  to deregister on.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success.\n\n\n\n\nNote\n\n\nMICROBIT_EVT_ANY can be used to deregister all event values matching the given id. \n\n\n\n\npacketReceived\n#\n\n\n\n\nvoid\n \npacketReceived\n()\n#\n\n\nDescription\n#\n\n\nProtocol handler callback. This is called when the radio receives a packet marked as using the event protocol.  \n\n\nThis function process this packet, and fires the event contained inside onto the default  EventModel .           \n\n\neventReceived\n#\n\n\n\n\nvoid\n \neventReceived\n( \nMicroBitEvent\n e)\n#\n\n\nDescription\n#\n\n\nEvent handler callback. This is called whenever an event is received matching one of those registered through the registerEvent() method described above. Upon receiving such an event, it is wrapped into a radio packet and transmitted to any other micro:bits in the same group.           \n\n\nParameters\n#\n\n\n\n\nMicroBitEvent\n e",
            "title": "_radioevent"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#ubitradioevent",
            "text": "",
            "title": "uBit.radio.event"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#overview",
            "text": "It is also possible to transparently send and receive events over the  MicroBitRadio  channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.  To use this functionality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the  MicroBitMessageBus  for details of how to write\nevent handlers.  For example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:  #define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.radio.enable();\n\n    // Ensure the radio is listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(1000);\n    }\n}  \u2026and on the micro:bits wanting to receive the event:  #define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync(\"Something!\");\n}\n\nint main()\n{\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#message-bus-id",
            "text": "None.",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#message-bus-events",
            "text": "None.",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#microbitradioevent-microbitradio-r",
            "text": "",
            "title": "MicroBitRadioEvent( MicroBitRadio  &amp; r)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description",
            "text": "Constructor.    Creates an instance of  MicroBitRadioEvent  which offers the ability to extend the micro:bit\u2019s default  EventModel  to other micro:bits in the vicinity.    r   The underlying radio module used to send and receive data.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters",
            "text": "MicroBitRadio  &  r - The underlying radio module used to send and receive data.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#listen",
            "text": "",
            "title": "listen"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#int-listen-uint16_t-id-uint16_t-value",
            "text": "",
            "title": "int listen( uint16_t id,  uint16_t value)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_1",
            "text": "Associates the given event with the radio channel.    Once registered, all events matching the given registration sent to this micro:bit\u2019s default  EventModel  will be automatically retransmitted on the radio.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters_1",
            "text": "uint16_t  id - The id of the event to register.  uint16_t  value - the value of the event to register.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#returns",
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if no default  EventModel  is available.   Note  The wildcards MICROBIT_ID_ANY and MICROBIT_EVT_ANY can also be in place of the id and value fields.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#int-listen-uint16_t-id-uint16_t-value-eventmodel-eventbus",
            "text": "",
            "title": "int listen( uint16_t id,  uint16_t value,  EventModel  &amp; eventBus)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_2",
            "text": "Associates the given event with the radio channel.    Once registered, all events matching the given registration sent to the given  EventModel  will be automatically retransmitted on the radio.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters_2",
            "text": "uint16_t  id - The id of the events to register.  uint16_t  value - the value of the event to register.  EventModel  &  eventBus - The  EventModel  to listen for events on.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#returns_1",
            "text": "MICROBIT_OK on success.   Note  The wildcards MICROBIT_ID_ANY and MICROBIT_EVT_ANY can also be in place of the id and value fields.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#ignore",
            "text": "",
            "title": "ignore"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#int-ignore-uint16_t-id-uint16_t-value",
            "text": "",
            "title": "int ignore( uint16_t id,  uint16_t value)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_3",
            "text": "Disassociates the given event with the radio channel.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters_3",
            "text": "uint16_t  id - The id of the events to deregister.  uint16_t  value - The value of the event to deregister.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#returns_2",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the default message bus does not exist.   Note  MICROBIT_EVT_ANY can be used to deregister all event values matching the given id.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#int-ignore-uint16_t-id-uint16_t-value-eventmodel-eventbus",
            "text": "",
            "title": "int ignore( uint16_t id,  uint16_t value,  EventModel  &amp; eventBus)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_4",
            "text": "Disassociates the given events with the radio channel.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters_4",
            "text": "uint16_t  id - The id of the events to deregister.  uint16_t  value - The value of the event to deregister.  EventModel  &  eventBus - The  EventModel  to deregister on.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#returns_3",
            "text": "MICROBIT_OK on success.   Note  MICROBIT_EVT_ANY can be used to deregister all event values matching the given id.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#packetreceived",
            "text": "",
            "title": "packetReceived"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#void-packetreceived",
            "text": "",
            "title": "void packetReceived()"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_5",
            "text": "Protocol handler callback. This is called when the radio receives a packet marked as using the event protocol.    This function process this packet, and fires the event contained inside onto the default  EventModel .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#eventreceived",
            "text": "",
            "title": "eventReceived"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#void-eventreceived-microbitevent-e",
            "text": "",
            "title": "void eventReceived( MicroBitEvent e)"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#description_6",
            "text": "Event handler callback. This is called whenever an event is received matching one of those registered through the registerEvent() method described above. Upon receiving such an event, it is wrapped into a radio packet and transmitted to any other micro:bits in the same group.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radioevent/#parameters_5",
            "text": "MicroBitEvent  e",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/",
            "text": "uBit.radio.datagram\n#\n\n\nOverview\n#\n\n\nThis is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time.\nThis data can be provided as array of bytes, a text string, or \nPacketBuffer\n.\n\n\nYou can send a packet at any time using the \nuBit.radio.datagram.send\n function.\n\n\nAny other micro:bits in range will detect the transmitted packet, and make the packet available through the\n\nuBit.radio.datagram.recv\n function.\n\n\nAny micro:bits receiving a datagram packet will also raise a \nMICROBIT_RADIO_EVT_DATAGRAM\n event to indicate\nthat some data is ready to be read.\n\n\nFor example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car.\n\n\nYou might decide that simply sending a \n1\n means turn left, and a \n2\n means turn right, so you may write a program like this for the remote control:\n\n\nint main()\n{\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send(\"1\");\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send(\"2\");\n\n        uBit.sleep(100);\n    }\n}\n\n\n\n\n\u2026and one like this for the remote control car:\n\n\nvoid onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s == \"1\")\n        uBit.io.P0.setServoValue(0);\n\n    if (s == \"2\")\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nMessage Bus ID\n#\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n#\n\n\n\n\nNone.\n\n\n\n\nAPI\n#\n\n\nConstructor\n#\n\n\n\n\nMicroBitRadioDatagram( \nMicroBitRadio  &\n r)\n#\n\n\nDescription\n#\n\n\nConstructor.  \n\n\nCreates an instance of a  MicroBitRadioDatagram  which offers the ability to broadcast simple text or binary messages to other micro:bits in the vicinity  \n\n\nr \n\n\nThe underlying radio module used to send and receive data.   \n\n\nParameters\n#\n\n\n\n\nMicroBitRadio  &\n r - The underlying radio module used to send and receive data. \n\n\n\n\nrecv\n#\n\n\n\n\nint\n \nrecv\n( \nuint8_t *\n buf,  \nint\n len)\n#\n\n\nDescription\n#\n\n\nRetrieves packet payload data into the given buffer.  \n\n\nIf a data packet is already available, then it will be returned immediately to the caller. If no data is available then MICROBIT_INVALID_PARAMETER is returned.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buf - A pointer to a valid memory location where the received data is to be stored\n\n\nint\n len - The maximum amount of data that can safely be stored in \u2018buf\u2019\n\n\n\n\nReturns\n#\n\n\nThe length of the data stored, or MICROBIT_INVALID_PARAMETER if no data is available, or the memory regions provided are invalid. \n\n\n\nPacketBuffer\n \nrecv\n()\n#\n\n\nDescription\n#\n\n\nRetreives packet payload data into the given buffer.  \n\n\nIf a data packet is already available, then it will be returned immediately to the caller in the form of a  PacketBuffer .  \n\n\nReturns\n#\n\n\nthe data received, or an empty  PacketBuffer  if no data is available. \n\n\nsend\n#\n\n\n\n\nint\n \nsend\n( \nuint8_t *\n buffer,  \nint\n len)\n#\n\n\nDescription\n#\n\n\nTransmits the given buffer onto the broadcast radio.  \n\n\nThis is a synchronous call that will wait until the transmission of the packet has completed before returning.  \n\n\nParameters\n#\n\n\n\n\nuint8_t *\n buffer - The packet contents to transmit.\n\n\nint\n len - The number of bytes to transmit.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE . \n\n\n\nint\n \nsend\n( \nPacketBuffer\n data)\n#\n\n\nDescription\n#\n\n\nTransmits the given string onto the broadcast radio.  \n\n\nThis is a synchronous call that will wait until the transmission of the packet has completed before returning.  \n\n\nParameters\n#\n\n\n\n\nPacketBuffer\n data - The packet contents to transmit.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE . \n\n\n\nint\n \nsend\n( \nManagedString\n data)\n#\n\n\nDescription\n#\n\n\nTransmits the given string onto the broadcast radio.  \n\n\nThis is a synchronous call that will wait until the transmission of the packet has completed before returning.  \n\n\nParameters\n#\n\n\n\n\nManagedString\n data - The packet contents to transmit.\n\n\n\n\nReturns\n#\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE . \n\n\npacketReceived\n#\n\n\n\n\nvoid\n \npacketReceived\n()\n#\n\n\nDescription\n#\n\n\nProtocol handler callback. This is called when the radio receives a packet marked as a datagram.  \n\n\nThis function process this packet, and queues it for user reception.",
            "title": "_radiodatagram"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#ubitradiodatagram",
            "text": "",
            "title": "uBit.radio.datagram"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#overview",
            "text": "This is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time.\nThis data can be provided as array of bytes, a text string, or  PacketBuffer .  You can send a packet at any time using the  uBit.radio.datagram.send  function.  Any other micro:bits in range will detect the transmitted packet, and make the packet available through the uBit.radio.datagram.recv  function.  Any micro:bits receiving a datagram packet will also raise a  MICROBIT_RADIO_EVT_DATAGRAM  event to indicate\nthat some data is ready to be read.  For example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car.  You might decide that simply sending a  1  means turn left, and a  2  means turn right, so you may write a program like this for the remote control:  int main()\n{\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send(\"1\");\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send(\"2\");\n\n        uBit.sleep(100);\n    }\n}  \u2026and one like this for the remote control car:  void onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s == \"1\")\n        uBit.io.P0.setServoValue(0);\n\n    if (s == \"2\")\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}",
            "title": "Overview"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#message-bus-id",
            "text": "None.",
            "title": "Message Bus ID"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#message-bus-events",
            "text": "None.",
            "title": "Message Bus Events"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#api",
            "text": "",
            "title": "API"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#constructor",
            "text": "",
            "title": "Constructor"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#microbitradiodatagram-microbitradio-r",
            "text": "",
            "title": "MicroBitRadioDatagram( MicroBitRadio  &amp; r)"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description",
            "text": "Constructor.    Creates an instance of a  MicroBitRadioDatagram  which offers the ability to broadcast simple text or binary messages to other micro:bits in the vicinity    r   The underlying radio module used to send and receive data.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#parameters",
            "text": "MicroBitRadio  &  r - The underlying radio module used to send and receive data.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#recv",
            "text": "",
            "title": "recv"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#int-recv-uint8_t-42-buf-int-len",
            "text": "",
            "title": "int recv( uint8_t * buf,  int len)"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_1",
            "text": "Retrieves packet payload data into the given buffer.    If a data packet is already available, then it will be returned immediately to the caller. If no data is available then MICROBIT_INVALID_PARAMETER is returned.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#parameters_1",
            "text": "uint8_t *  buf - A pointer to a valid memory location where the received data is to be stored  int  len - The maximum amount of data that can safely be stored in \u2018buf\u2019",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#returns",
            "text": "The length of the data stored, or MICROBIT_INVALID_PARAMETER if no data is available, or the memory regions provided are invalid.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#packetbuffer-recv",
            "text": "",
            "title": "PacketBuffer recv()"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_2",
            "text": "Retreives packet payload data into the given buffer.    If a data packet is already available, then it will be returned immediately to the caller in the form of a  PacketBuffer .",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#returns_1",
            "text": "the data received, or an empty  PacketBuffer  if no data is available.",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#send",
            "text": "",
            "title": "send"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#int-send-uint8_t-42-buffer-int-len",
            "text": "",
            "title": "int send( uint8_t * buffer,  int len)"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_3",
            "text": "Transmits the given buffer onto the broadcast radio.    This is a synchronous call that will wait until the transmission of the packet has completed before returning.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#parameters_2",
            "text": "uint8_t *  buffer - The packet contents to transmit.  int  len - The number of bytes to transmit.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#returns_2",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE .",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#int-send-packetbuffer-data",
            "text": "",
            "title": "int send( PacketBuffer data)"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_4",
            "text": "Transmits the given string onto the broadcast radio.    This is a synchronous call that will wait until the transmission of the packet has completed before returning.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#parameters_3",
            "text": "PacketBuffer  data - The packet contents to transmit.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#returns_3",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE .",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#int-send-managedstring-data",
            "text": "",
            "title": "int send( ManagedString data)"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_5",
            "text": "Transmits the given string onto the broadcast radio.    This is a synchronous call that will wait until the transmission of the packet has completed before returning.",
            "title": "Description"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#parameters_4",
            "text": "ManagedString  data - The packet contents to transmit.",
            "title": "Parameters"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#returns_4",
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the buffer is invalid, or the number of bytes to transmit is greater than  MICROBIT_RADIO_MAX_PACKET_SIZE + MICROBIT_RADIO_HEADER_SIZE .",
            "title": "Returns"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#packetreceived",
            "text": "",
            "title": "packetReceived"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#void-packetreceived",
            "text": "",
            "title": "void packetReceived()"
        },
        {
            "location": "/lancaster-mbed/ubit/radiodatagram/#description_6",
            "text": "Protocol handler callback. This is called when the radio receives a packet marked as a datagram.    This function process this packet, and queues it for user reception.",
            "title": "Description"
        },
        {
            "location": "/projects/projects/",
            "text": "C\u00e1c d\u1ef1 \u00e1n\n#",
            "title": "C\u00e1c d\u1ef1 \u00e1n"
        },
        {
            "location": "/projects/projects/#cac-du-an",
            "text": "",
            "title": "C\u00e1c d\u1ef1 \u00e1n"
        },
        {
            "location": "/license/",
            "text": "B\u1ea3n quy\u1ec1n\n#\n\n\nTo\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA\n\n\nGhi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, v\u00e0 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.\n\n\nB\u1ea5t k\u1ef3 nh\u1eefng n\u1ed9i dung ph\u00e2n ph\u1ed1i b\u1edfi website n\u00e0y c\u00f3 gi\u1ea5y ph\u00e9p ri\u00eang th\u00ec tu\u00e2n th\u1ee7 theo gi\u1ea5y ph\u00e9p c\u1ee7a n\u1ed9i dung \u0111\u00f3.",
            "title": "B\u1ea3n quy\u1ec1n"
        },
        {
            "location": "/license/#ban-quyen",
            "text": "To\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA  Ghi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, v\u00e0 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.  B\u1ea5t k\u1ef3 nh\u1eefng n\u1ed9i dung ph\u00e2n ph\u1ed1i b\u1edfi website n\u00e0y c\u00f3 gi\u1ea5y ph\u00e9p ri\u00eang th\u00ec tu\u00e2n th\u1ee7 theo gi\u1ea5y ph\u00e9p c\u1ee7a n\u1ed9i dung \u0111\u00f3.",
            "title": "B\u1ea3n quy\u1ec1n"
        },
        {
            "location": "/contributor/",
            "text": "Danh s\u00e1ch th\u00e0nh vi\u00ean \u0111\u00f3ng g\u00f3p:\n#\n\n\n\n\nDo\u00e3n Minh \u0110\u0103ng\n\n\nTu\u1ea5n PM",
            "title": "\u0110\u00f3ng g\u00f3p"
        },
        {
            "location": "/contributor/#danh-sach-thanh-vien-ong-gop",
            "text": "Do\u00e3n Minh \u0110\u0103ng  Tu\u1ea5n PM",
            "title": "Danh s\u00e1ch th\u00e0nh vi\u00ean \u0111\u00f3ng g\u00f3p:"
        }
    ]
}